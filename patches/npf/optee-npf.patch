diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..89923f5
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,3 @@
+tzr-out-libnpf/
+nw-out-libnpf/
+nw-out-npfctl/
diff --git a/Makefile b/Makefile
new file mode 100644
index 0000000..91b6996
--- /dev/null
+++ b/Makefile
@@ -0,0 +1,37 @@
+export V ?= 0
+
+OUTPUT_LIBNPF_DIR := $(CURDIR)/tzr-out-libnpf
+
+.PHONY: all
+all: libnpf npfctl libnpf-tzr prepare-for-rootfs
+
+.PHONY: clean
+clean: libnpf-clean npfctl-clean libnpf-tzr-clean prepare-for-rootfs-clean
+
+libnpf:
+	$(MAKE) -C src CROSS_COMPILE="$(HOST_CROSS_COMPILE)" $(LIBNPF_NW_FLAGS) libnpf || exit -1;
+
+libnpf-clean:
+	$(MAKE) -C src libnpf-clean || exit -1;
+
+npfctl:
+	$(MAKE) -C src CROSS_COMPILE="$(HOST_CROSS_COMPILE)" $(LIBNPF_NW_FLAGS) npfctl || exit -1;
+
+npfctl-clean:
+	$(MAKE) -C src CROSS_COMPILE="$(HOST_CROSS_COMPILE)" $(LIBNPF_NW_FLAGS) npfctl-clean || exit -1;
+
+libnpf-tzr:
+	$(MAKE) -C src CROSS_COMPILE="$(TA_CROSS_COMPILE)" libnpf-tzr || exit -1;
+
+libnpf-clean-tzr:
+	$(MAKE) -C src libnpf-tzr-clean || exit -1;
+
+prepare-for-rootfs: libnpf-tzr
+	@echo "Copying example TLIB to $(OUTPUT_LIBNPF_DIR)..."
+	@mkdir -p $(OUTPUT_LIBNPF_DIR)
+	@mkdir -p $(OUTPUT_LIBNPF_DIR)/tlib
+	cp -pr src/libnpf/tzr-build/*.a $(OUTPUT_LIBNPF_DIR)/tlib/; \
+
+prepare-for-rootfs-clean:
+	@rm -rf $(OUTPUT_LIBNPF_DIR)/tlib
+	@rmdir --ignore-fail-on-non-empty $(OUTPUT_LIBNPF_DIR) || test ! -e $(OUTPUT_LIBNPF_DIR)
diff --git a/src/.gitignore b/src/.gitignore
new file mode 100644
index 0000000..72c32f3
--- /dev/null
+++ b/src/.gitignore
@@ -0,0 +1,3 @@
+*.lo
+*.la
+.libs/
diff --git a/src/Makefile b/src/Makefile
index 9b48d05..cd8f57e 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -1,23 +1,76 @@
-SYSARCH:=	$(shell uname -m)
+export V?=0
 
-ifeq ($(SYSARCH),x86_64)
-NJOBS:=		$(shell getconf _NPROCESSORS_ONLN)
-MKFLAGS=	-j $(NJOBS)
-else
-MKFLAGS=
-endif
+# If _HOST or _TA specific compilers are not specified, then use CROSS_COMPILE
+HOST_CROSS_COMPILE ?= $(CROSS_COMPILE)
+TA_CROSS_COMPILE ?= $(CROSS_COMPILE)
 
-all:
-	make $(MKFLAGS) -C kern lib
-	make $(MKFLAGS) -C libnpf lib
+.PHONY: libnpf
+libnpf: CROSS_COMPILE="$(HOST_CROSS_COMPILE)"
+libnpf: export CC      ?= $(CROSS_COMPILE)gcc
+libnpf: export LD      ?= $(CROSS_COMPILE)ld
+libnpf: export AR      ?= $(CROSS_COMPILE)ar
+libnpf: export NM      ?= $(CROSS_COMPILE)nm
+libnpf: export OBJCOPY ?= $(CROSS_COMPILE)objcopy
+libnpf: export OBJDUMP ?= $(CROSS_COMPILE)objdump
+libnpf: export READELF ?= $(CROSS_COMPILE)readelf
 
-install:
-	make -C kern install
-	make -C libnpf install
+libnpf: export CFLAGS  += -Wall -I$(TEEC_EXPORT)/include -I$(NV_NW_OUT) -I$(CDB_NW_OUT) \
+	-I$(QSBR_NW_OUT) -I../../../thmap/src/ -I../../../liblpm/src/ \
+	-DTA_SUBMIT_API \
+	-Iexternal/include/ #TODO: fix! this is just dummy include of empty pcap/bpf.h file
+libnpf: export LDFLAGS   += -lteec -L$(TEEC_EXPORT)/lib -L$(NV_NW_OUT) -L$(CDB_NW_OUT)
 
-clean:
-	make -C kern clean
-	make -C libnpf clean
-	make -C npfctl clean
+libnpf:
+	$(MAKE) -C libnpf LIBDIR=`pwd`/../nw-out-libnpf/ lib || exit -1;
+	$(MAKE) -C libnpf LIBDIR=. DESTDIR=`pwd`/../nw-out-libnpf install || exit -1;
+
+.PHONY: libnpf-clean
+libnpf-clean:
+	$(MAKE) -C libnpf clean
+
+.PHONY: npfctl
+# TODO: get rid of this copy
+npfctl: CROSS_COMPILE="$(HOST_CROSS_COMPILE)"
+npfctl: export CC      ?= $(CROSS_COMPILE)gcc
+npfctl: export LD      ?= $(CROSS_COMPILE)ld
+npfctl: export AR      ?= $(CROSS_COMPILE)ar
+npfctl: export NM      ?= $(CROSS_COMPILE)nm
+npfctl: export OBJCOPY ?= $(CROSS_COMPILE)objcopy
+npfctl: export OBJDUMP ?= $(CROSS_COMPILE)objdump
+npfctl: export READELF ?= $(CROSS_COMPILE)readelf
+# /TODO
+
+npfctl: export YACC = `which yacc`
+npfctl: export LEX = `which lex`
+
+npfctl: export CFLAGS  += -Wall -I$(TEEC_EXPORT)/include -I$(NV_NW_OUT) -I$(CDB_NW_OUT) \
+	-I$(QSBR_NW_OUT) -I../../../thmap/src/ -I../../../liblpm/src/ \
+	-Iexternal/libpcap/usr/include/ \
+	-Iexternal/libssl/usr/include/ -Iexternal/libssl/usr/include/arm-linux-gnueabihf/ \
+	-Iexternal/libssl/usr/include/aarch64-linux-gnu/ \
+	-DTA_SUBMIT_API
+npfctl: export LDFLAGS   += -lteec -L$(TEEC_EXPORT)/lib \
+	-Lexternal/libpcap/usr/lib/arm-linux-gnueabihf/ \
+	-Lexternal/libssl/usr/lib/arm-linux-gnueabihf/ \
+	-Lexternal/libpcap/usr/lib/aarch64-linux-gnu/ \
+	-Lexternal/libssl/usr/lib/aarch64-linux-gnu/ \
+	-L../../nw-out-libnpf/ \
+	-Wl,-rpath-link=$(NV_NW_OUT),-rpath-link=$(CDB_NW_OUT)
+	#note: could specify -rpath to install dirs on HiKey960 board, but standard paths will suffice
+
+npfctl:
+	$(MAKE) -C npfctl BINDIR=`pwd`/../nw-out-npfctl/ all || exit -1;
+	$(MAKE) -C npfctl BINDIR=. DESTDIR=`pwd`/../nw-out-npfctl install || exit -1;
+
+.PHONY: npfctl-clean
+npfctl-clean:
+	$(MAKE) -C npfctl clean
+
+.PHONY: libnpf-tzr
+libnpf-tzr:
+	$(MAKE) -C libnpf -f TZRMakefile CROSS_COMPILE="$(TA_CROSS_COMPILE)" LDFLAGS=""
+
+.PHONY: libnpf-tzr-clean
+libnpf-tzr-clean:
+	$(MAKE) -C libnpf -f TZRMakefile clean
 
-.PHONY: all install clean
diff --git a/src/kern/files.npf b/src/kern/files.npf
index 00747c8..09e14f7 100644
--- a/src/kern/files.npf
+++ b/src/kern/files.npf
@@ -46,7 +46,7 @@ file	net/npf/npf_ext_rndblock.c		npf
 
 # ALGs
 file	net/npf/npf_alg_icmp.c			npf
-file	net/npf/npf_alg_pptp.c			npf
+#file	net/npf/npf_alg_pptp.c			npf
 
 # Interfaces
 file	net/npf/if_npflog.c			npf
diff --git a/src/kern/if_npflog.c b/src/kern/if_npflog.c
index 98ffea7..b211bd8 100644
--- a/src/kern/if_npflog.c
+++ b/src/kern/if_npflog.c
@@ -31,24 +31,6 @@
  * NPF logging extension.
  */
 
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD: if_npflog.c,v 1.6 2018/09/29 14:41:36 rmind Exp $");
-
-#include <sys/types.h>
-#include <sys/module.h>
-
-#include <sys/conf.h>
-#include <sys/kmem.h>
-#include <sys/mbuf.h>
-#include <sys/mutex.h>
-#include <sys/queue.h>
-#include <sys/sockio.h>
-
-#include <net/if.h>
-#include <net/if_types.h>
-#include <net/bpf.h>
-#endif
 
 #include "npf_impl.h"
 #include "if_npflog.h"
@@ -57,7 +39,7 @@ MODULE(MODULE_CLASS_DRIVER, if_npflog, NULL);
 
 typedef struct npflog_softc {
 	LIST_ENTRY(npflog_softc)	sc_entry;
-	kmutex_t			sc_lock;
+	npfk_kmutex_t			sc_lock;
 	ifnet_t				sc_if;
 	int				sc_unit;
 } npflog_softc_t;
@@ -94,7 +76,7 @@ npflog_ioctl(ifnet_t *ifp, u_long cmd, void *data)
 	npflog_softc_t *sc = ifp->if_softc;
 	int error = 0;
 
-	mutex_enter(&sc->sc_lock);
+	npfk_mutex_enter(&sc->sc_lock);
 	switch (cmd) {
 	case SIOCINITIFADDR:
 		ifp->if_flags |= (IFF_UP | IFF_RUNNING);
@@ -103,7 +85,7 @@ npflog_ioctl(ifnet_t *ifp, u_long cmd, void *data)
 		error = ifioctl_common(ifp, cmd, data);
 		break;
 	}
-	mutex_exit(&sc->sc_lock);
+	npfk_mutex_exit(&sc->sc_lock);
 	return error;
 }
 
@@ -114,7 +96,8 @@ npflog_clone_create(struct if_clone *ifc, int unit)
 	ifnet_t *ifp;
 
 	sc = kmem_zalloc(sizeof(npflog_softc_t), KM_SLEEP);
-	mutex_init(&sc->sc_lock, MUTEX_DEFAULT, IPL_SOFTNET);
+	//npfk_mutex_init(&sc->sc_lock, MUTEX_DEFAULT, IPL_SOFTNET);
+	npfk_mutex_init(&sc->sc_lock);
 
 	ifp = &sc->sc_if;
 	ifp->if_softc = sc;
@@ -145,7 +128,7 @@ npflog_clone_destroy(ifnet_t *ifp)
 	if_detach(ifp);
 	KERNEL_UNLOCK_ONE(NULL);
 
-	mutex_destroy(&sc->sc_lock);
+	npfk_mutex_destroy(&sc->sc_lock);
 	kmem_free(sc, sizeof(npflog_softc_t));
 	return 0;
 }
diff --git a/src/kern/if_npflog.h b/src/kern/if_npflog.h
index a13bc37..07fe7ad 100644
--- a/src/kern/if_npflog.h
+++ b/src/kern/if_npflog.h
@@ -25,9 +25,7 @@
 #ifndef _NET_NPF_IF_NPFLOG_H_
 #define _NET_NPF_IF_NPFLOG_H_
 
-#ifndef _KERNEL
 #error "not supposed to be exposed to userland"
-#endif
 
 #define NPFLOG_RULESET_NAME_SIZE	16
 
diff --git a/src/kern/npf.c b/src/kern/npf.c
index 0d5a84c..f73b926 100644
--- a/src/kern/npf.c
+++ b/src/kern/npf.c
@@ -31,18 +31,6 @@
  * NPF main: dynamic load/initialisation and unload routines.
  */
 
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD$");
-
-#include <sys/param.h>
-#include <sys/types.h>
-
-#include <sys/conf.h>
-#include <sys/kmem.h>
-#include <sys/percpu.h>
-#include <sys/xcall.h>
-#endif
 
 #include "npf_impl.h"
 #include "npf_conn.h"
@@ -50,12 +38,12 @@ __KERNEL_RCSID(0, "$NetBSD$");
 static __read_mostly npf_t *	npf_kernel_ctx = NULL;
 
 __dso_public int
-npfk_sysinit(unsigned nworkers)
+npfk_sysinit(void)
 {
 	npf_bpf_sysinit();
 	npf_tableset_sysinit();
 	npf_nat_sysinit();
-	return npf_worker_sysinit(nworkers);
+	return npf_worker_sysinit();
 }
 
 __dso_public void
diff --git a/src/kern/npf.h b/src/kern/npf.h
index 8d4bf47..35b1a74 100644
--- a/src/kern/npf.h
+++ b/src/kern/npf.h
@@ -34,18 +34,20 @@
 #ifndef _NPF_NET_H_
 #define _NPF_NET_H_
 
-#include <sys/param.h>
 #include <sys/types.h>
 
 #define	NPF_VERSION		22
 
-#if defined(_NPF_STANDALONE)
-#include "npf_stand.h"
+#ifdef TZR_TRIMMED_NPF
+#include "npf_tzr_trimmed_stand.h"
+#elif defined(TZR_PTA_OPTEE)
+#include "npf_optee.h"
 #else
-#include <sys/ioctl.h>
-#include <netinet/in_systm.h>
-#include <netinet/in.h>
-#endif
+#include  "npf_tzr_stand.h"
+#endif /* TZR_TIMMED_NPF */
+
+// for __predict_true/false()
+#include <newlib/sys/cdefs.h>
 
 struct npf;
 typedef struct npf npf_t;
@@ -80,7 +82,6 @@ typedef uint8_t			npf_netmask_t;
  * In-kernel declarations and definitions.
  */
 
-#if defined(_KERNEL) || defined(_NPF_STANDALONE)
 
 #define	NPF_DECISION_BLOCK	0
 #define	NPF_DECISION_PASS	1
@@ -88,13 +89,13 @@ typedef uint8_t			npf_netmask_t;
 #define	NPF_EXT_MODULE(name, req)	\
     MODULE(MODULE_CLASS_MISC, name, (sizeof(req) - 1) ? ("npf," req) : "npf")
 
-#include <net/if.h>
-#include <netinet/ip.h>
-#include <netinet/ip6.h>
-#include <netinet/tcp.h>
-#include <netinet/udp.h>
-#include <netinet/ip_icmp.h>
-#include <netinet/icmp6.h>
+#include <newlib/net/if.h>
+#include <newlib/netinet/ip.h>
+#include <newlib/netinet/ip6.h>
+#include <newlib/netinet/tcp.h>
+#include <newlib/netinet/udp.h>
+#include <newlib/netinet/ip_icmp.h>
+#include <newlib/netinet/icmp6.h>
 
 /*
  * Network buffer interface.
@@ -199,7 +200,6 @@ npf_iscached(const npf_cache_t *npc, const int inf)
 
 bool		npf_autounload_p(void);
 
-#endif	/* _KERNEL */
 
 #define	NPF_SRC		0
 #define	NPF_DST		1
@@ -322,6 +322,9 @@ typedef struct npf_ioctl_table {
 #define	IOC_NPF_CONN_LOOKUP	_IOWR('N', 108, nvlist_ref_t)
 #define	IOC_NPF_TABLE_REPLACE	_IOWR('N', 109, nvlist_ref_t)
 
+// bstgw
+#define IOC_BSTGW_QUERY_NETIFS  _IOR('N', 120, nvlist_ret_t)
+
 /*
  * NPF error report.
  */
diff --git a/src/kern/npf_alg.c b/src/kern/npf_alg.c
index 03e1e9c..6380691 100644
--- a/src/kern/npf_alg.c
+++ b/src/kern/npf_alg.c
@@ -31,16 +31,6 @@
  * NPF interface for the Application Level Gateways (ALGs).
  */
 
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD$");
-
-#include <sys/param.h>
-#include <sys/types.h>
-
-#include <sys/kmem.h>
-#include <sys/module.h>
-#endif
 
 #include "npf_impl.h"
 
diff --git a/src/kern/npf_alg_icmp.c b/src/kern/npf_alg_icmp.c
index 54923ab..acf6ea5 100644
--- a/src/kern/npf_alg_icmp.c
+++ b/src/kern/npf_alg_icmp.c
@@ -31,22 +31,6 @@
  * NPF ALG for ICMP and traceroute translations.
  */
 
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD$");
-
-#include <sys/param.h>
-#include <sys/module.h>
-
-#include <netinet/in_systm.h>
-#include <netinet/in.h>
-#include <netinet/ip.h>
-#include <netinet/tcp.h>
-#include <netinet/udp.h>
-#include <netinet/ip_icmp.h>
-#include <netinet/icmp6.h>
-#include <net/pfil.h>
-#endif
 
 #include "npf_impl.h"
 #include "npf_conn.h"
@@ -473,22 +457,3 @@ npf_alg_icmp_fini(npf_t *npf)
 	return npf_alg_unregister(npf, alg_icmp);
 }
 
-#ifdef _KERNEL
-static int
-npf_alg_icmp_modcmd(modcmd_t cmd, void *arg)
-{
-	npf_t *npf = npf_getkernctx();
-
-	switch (cmd) {
-	case MODULE_CMD_INIT:
-		return npf_alg_icmp_init(npf);
-	case MODULE_CMD_FINI:
-		return npf_alg_icmp_fini(npf);
-	case MODULE_CMD_AUTOUNLOAD:
-		return EBUSY;
-	default:
-		return ENOTTY;
-	}
-	return 0;
-}
-#endif
diff --git a/src/kern/npf_alg_pptp.c b/src/kern/npf_alg_pptp.c
index ff16f87..dfbabd4 100644
--- a/src/kern/npf_alg_pptp.c
+++ b/src/kern/npf_alg_pptp.c
@@ -28,19 +28,6 @@
  * NPF ALG for PPTP translations.
  */
 
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD$");
-
-#include <sys/param.h>
-#include <sys/module.h>
-
-#include <netinet/in_systm.h>
-#include <netinet/in.h>
-#include <netinet/ip.h>
-#include <netinet/tcp.h>
-#include <net/pfil.h>
-#endif
 
 #include "npf_impl.h"
 #include "npf_conn.h"
@@ -388,7 +375,7 @@ pptp_tcp_ctx_alloc(npf_nat_t *nt)
 	if (ctx == NULL) {
 		return NULL;
 	}
-	mutex_init(&ctx->lock, MUTEX_DEFAULT, IPL_SOFTNET);
+	npfk_mutex_init(&ctx->lock);
 	return ctx;
 }
 
@@ -815,22 +802,3 @@ npf_alg_pptp_fini(npf_t *npf)
 	return 0;
 }
 
-#ifdef _KERNEL
-static int
-npf_alg_pptp_modcmd(modcmd_t cmd, void *arg)
-{
-	npf_t *npf = npf_getkernctx();
-
-	switch (cmd) {
-	case MODULE_CMD_INIT:
-		return npf_alg_pptp_init(npf);
-	case MODULE_CMD_FINI:
-		return npf_alg_pptp_fini(npf);
-	case MODULE_CMD_AUTOUNLOAD:
-		return EBUSY;
-	default:
-		return ENOTTY;
-	}
-	return 0;
-}
-#endif
diff --git a/src/kern/npf_bpf.c b/src/kern/npf_bpf.c
index 41363ac..2d5f89a 100644
--- a/src/kern/npf_bpf.c
+++ b/src/kern/npf_bpf.c
@@ -31,24 +31,11 @@
  * NPF byte-code processing.
  */
 
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD: npf_bpf.c,v 1.14 2018/09/29 14:41:36 rmind Exp $");
-
-#include <sys/types.h>
-#include <sys/param.h>
-
-#include <sys/bitops.h>
-#include <sys/mbuf.h>
-#include <net/bpf.h>
-#endif
 
 #define NPF_BPFCOP
 #include "npf_impl.h"
 
-#if defined(_NPF_STANDALONE)
 #define	m_length(m)		(nbuf)->nb_mops->getchainlen(m)
-#endif
 
 /*
  * BPF context and the coprocessor.
@@ -89,14 +76,8 @@ npf_bpf_prepare(npf_cache_t *npc, bpf_args_t *args, uint32_t *M)
 	const size_t pktlen = m_length(mbuf);
 
 	/* Prepare the arguments for the BPF programs. */
-#ifdef _NPF_STANDALONE
 	args->pkt = (const uint8_t *)nbuf_dataptr(nbuf);
 	args->wirelen = args->buflen = pktlen;
-#else
-	args->pkt = (const uint8_t *)mbuf;
-	args->wirelen = pktlen;
-	args->buflen = 0;
-#endif
 	args->mem = M;
 	args->arg = npc;
 
diff --git a/src/kern/npf_conf.c b/src/kern/npf_conf.c
index d7b1ad4..be691d9 100644
--- a/src/kern/npf_conf.c
+++ b/src/kern/npf_conf.c
@@ -45,17 +45,6 @@
  *	is used with, when necessary, the writer-side barrier of EBR.
  */
 
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD$");
-
-#include <sys/param.h>
-#include <sys/types.h>
-
-#include <sys/atomic.h>
-#include <sys/kmem.h>
-#include <sys/mutex.h>
-#endif
 
 #include "npf_impl.h"
 #include "npf_conn.h"
@@ -65,7 +54,7 @@ npf_config_init(npf_t *npf)
 {
 	npf_config_t *nc;
 
-	mutex_init(&npf->config_lock, MUTEX_DEFAULT, IPL_SOFTNET);
+	npfk_mutex_init(&npf->config_lock);
 	nc = npf_config_create();
 
 	/*
@@ -115,15 +104,15 @@ npf_config_fini(npf_t *npf)
 	npf_conndb_t *cd = npf_conndb_create();
 
 	/* Flush the connections. */
-	mutex_enter(&npf->config_lock);
+	npfk_mutex_enter(&npf->config_lock);
 	npf_conn_tracking(npf, false);
 	npf_ebr_full_sync(npf->ebr);
 	npf_conn_load(npf, cd, false);
 	npf_ifmap_flush(npf);
-	mutex_exit(&npf->config_lock);
+	npfk_mutex_exit(&npf->config_lock);
 
 	npf_config_destroy(npf->config);
-	mutex_destroy(&npf->config_lock);
+	npfk_mutex_destroy(&npf->config_lock);
 }
 
 /*
@@ -143,7 +132,7 @@ npf_config_load(npf_t *npf, npf_config_t *nc, npf_conndb_t *conns, bool flush)
 	 * - Scan and use existing dynamic tables, reload only static.
 	 * - Scan and use matching NAT policies to preserve the connections.
 	 */
-	mutex_enter(&npf->config_lock);
+	npfk_mutex_enter(&npf->config_lock);
 	if ((onc = atomic_load_relaxed(&npf->config)) != NULL) {
 		npf_ruleset_reload(npf, nc->ruleset, onc->ruleset, load);
 		npf_tableset_reload(npf, nc->tableset, onc->tableset);
@@ -159,7 +148,7 @@ npf_config_load(npf_t *npf, npf_config_t *nc, npf_conndb_t *conns, bool flush)
 		/* Initial load, done. */
 		npf_ifmap_flush(npf);
 		npf_conn_load(npf, conns, !flush);
-		mutex_exit(&npf->config_lock);
+		npfk_mutex_exit(&npf->config_lock);
 		goto done;
 	}
 
@@ -183,7 +172,7 @@ npf_config_load(npf_t *npf, npf_config_t *nc, npf_conndb_t *conns, bool flush)
 	 * If not flushing - enable the connection tracking.
 	 */
 	npf_conn_load(npf, conns, !flush);
-	mutex_exit(&npf->config_lock);
+	npfk_mutex_exit(&npf->config_lock);
 
 	/* Finally, it is safe to destroy the old config. */
 	npf_config_destroy(onc);
@@ -199,20 +188,20 @@ done:
 npf_config_t *
 npf_config_enter(npf_t *npf)
 {
-	mutex_enter(&npf->config_lock);
+	npfk_mutex_enter(&npf->config_lock);
 	return npf->config;
 }
 
 void
 npf_config_exit(npf_t *npf)
 {
-	mutex_exit(&npf->config_lock);
+	npfk_mutex_exit(&npf->config_lock);
 }
 
 bool
 npf_config_locked_p(npf_t *npf)
 {
-	return mutex_owned(&npf->config_lock);
+	return npfk_mutex_owned(&npf->config_lock);
 }
 
 void
diff --git a/src/kern/npf_conn.c b/src/kern/npf_conn.c
index ec6b147..a48fdbb 100644
--- a/src/kern/npf_conn.c
+++ b/src/kern/npf_conn.c
@@ -102,24 +102,8 @@
  *			npf_conn_t::c_lock
  */
 
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD$");
-
-#include <sys/param.h>
-#include <sys/types.h>
-
-#include <netinet/in.h>
-#include <netinet/tcp.h>
-
-#include <sys/atomic.h>
-#include <sys/kmem.h>
-#include <sys/mutex.h>
-#include <net/pfil.h>
-#include <sys/pool.h>
-#include <sys/queue.h>
-#include <sys/systm.h>
-#endif
+
+#include <trace.h>
 
 #define __NPF_CONN_PRIVATE
 #include "npf_conn.h"
@@ -173,7 +157,7 @@ npf_conn_init(npf_t *npf)
 	    offsetof(npf_conn_t, c_keys[NPF_CONNKEY_V6WORDS * 2]),
 	    0, 0, 0, "npfcn6pl", NULL, IPL_NET, NULL, NULL, NULL);
 
-	mutex_init(&npf->conn_lock, MUTEX_DEFAULT, IPL_NONE);
+	npfk_mutex_init(&npf->conn_lock);
 	atomic_store_relaxed(&npf->conn_tracking, CONN_TRACKING_OFF);
 	npf->conn_db = npf_conndb_create();
 	npf_conndb_sysinit(npf);
@@ -192,7 +176,7 @@ npf_conn_fini(npf_t *npf)
 	npf_conndb_destroy(npf->conn_db);
 	pool_cache_destroy(npf->conn_cache[0]);
 	pool_cache_destroy(npf->conn_cache[1]);
-	mutex_destroy(&npf->conn_lock);
+	npfk_mutex_destroy(&npf->conn_lock);
 
 	npf_param_freegroup(npf, NPF_PARAMS_CONN, len);
 	npf_conndb_sysfini(npf);
@@ -216,7 +200,7 @@ npf_conn_load(npf_t *npf, npf_conndb_t *ndb, bool track)
 	 * The connection database is in the quiescent state.
 	 * Prevent G/C thread from running and install a new database.
 	 */
-	mutex_enter(&npf->conn_lock);
+	npfk_mutex_enter(&npf->conn_lock);
 	if (ndb) {
 		KASSERT(atomic_load_relaxed(&npf->conn_tracking)
 		    == CONN_TRACKING_OFF);
@@ -229,7 +213,7 @@ npf_conn_load(npf_t *npf, npf_conndb_t *ndb, bool track)
 		membar_producer();
 		atomic_store_relaxed(&npf->conn_tracking, CONN_TRACKING_ON);
 	}
-	mutex_exit(&npf->conn_lock);
+	npfk_mutex_exit(&npf->conn_lock);
 
 	if (odb) {
 		/*
@@ -275,10 +259,10 @@ npf_conn_trackable_p(const npf_cache_t *npc)
 static inline void
 conn_update_atime(npf_conn_t *con)
 {
-	struct timespec tsnow;
+	TEE_Time tsnow;
 
 	getnanouptime(&tsnow);
-	atomic_store_relaxed(&con->c_atime, tsnow.tv_sec);
+	atomic_store_relaxed(&con->c_atime, tsnow.seconds);
 }
 
 /*
@@ -387,9 +371,9 @@ npf_conn_inspect(npf_cache_t *npc, const unsigned di, int *error)
 	}
 
 	/* Inspect the protocol data and handle state changes. */
-	mutex_enter(&con->c_lock);
+	npfk_mutex_enter(&con->c_lock);
 	ok = npf_state_inspect(npc, &con->c_state, flow);
-	mutex_exit(&con->c_lock);
+	npfk_mutex_exit(&con->c_lock);
 
 	/* If invalid state: let the rules deal with it. */
 	if (__predict_false(!ok)) {
@@ -397,21 +381,6 @@ npf_conn_inspect(npf_cache_t *npc, const unsigned di, int *error)
 		npf_stats_inc(npc->npc_ctx, NPF_STAT_INVALID_STATE);
 		return NULL;
 	}
-#if 0
-	/*
-	 * TODO -- determine when this might be wanted/used.
-	 *
-	 * Note: skipping the connection lookup and ruleset inspection
-	 * on other interfaces will also bypass dynamic NAT.
-	 */
-	if (atomic_load_relaxed(&con->c_flags) & CONN_GPASS) {
-		/*
-		 * Note: if tagging fails, then give this packet a chance
-		 * to go through a regular ruleset.
-		 */
-		(void)nbuf_add_tag(nbuf, NPF_NTAG_PASS);
-	}
-#endif
 	return con;
 }
 
@@ -448,7 +417,7 @@ npf_conn_establish(npf_cache_t *npc, const unsigned di, bool global)
 	NPF_PRINTF(("NPF: create conn %p\n", con));
 	npf_stats_inc(npf, NPF_STAT_CONN_CREATE);
 
-	mutex_init(&con->c_lock, MUTEX_DEFAULT, IPL_SOFTNET);
+	npfk_mutex_init(&con->c_lock);
 	atomic_store_relaxed(&con->c_flags, di & PFIL_ALL);
 	atomic_store_relaxed(&con->c_refcnt, 0);
 	con->c_rproc = NULL;
@@ -491,7 +460,7 @@ npf_conn_establish(npf_cache_t *npc, const unsigned di, bool global)
 	 * connection.  At this point it becomes visible, but we activate
 	 * the connection later.
 	 */
-	mutex_enter(&con->c_lock);
+	npfk_mutex_enter(&con->c_lock);
 	conn_db = atomic_load_relaxed(&npf->conn_db);
 	if (!npf_conndb_insert(conn_db, fw, con, NPF_FLOW_FORW)) {
 		error = EISCONN;
@@ -520,7 +489,7 @@ err:
 
 	/* Finally, insert into the connection list. */
 	npf_conndb_enqueue(conn_db, con);
-	mutex_exit(&con->c_lock);
+	npfk_mutex_exit(&con->c_lock);
 
 	return error ? NULL : con;
 }
@@ -543,7 +512,7 @@ npf_conn_destroy(npf_t *npf, npf_conn_t *con)
 
 	/* Destroy the state. */
 	npf_state_destroy(&con->c_state);
-	mutex_destroy(&con->c_lock);
+	npfk_mutex_destroy(&con->c_lock);
 
 	/* Free the structure, increase the counter. */
 	pool_cache_put(npf->conn_cache[idx], con);
@@ -580,18 +549,18 @@ npf_conn_setnat(const npf_cache_t *npc, npf_conn_t *con,
 	KASSERT(ntype == NPF_NATOUT || ntype == NPF_NATIN);
 
 	/* Acquire the lock and check for the races. */
-	mutex_enter(&con->c_lock);
+	npfk_mutex_enter(&con->c_lock);
 	flags = atomic_load_relaxed(&con->c_flags);
 	if (__predict_false(flags & CONN_EXPIRE)) {
 		/* The connection got expired. */
-		mutex_exit(&con->c_lock);
+		npfk_mutex_exit(&con->c_lock);
 		return EINVAL;
 	}
 	KASSERT((flags & CONN_REMOVED) == 0);
 
 	if (__predict_false(con->c_nat != NULL)) {
 		/* Race with a duplicate packet. */
-		mutex_exit(&con->c_lock);
+		npfk_mutex_exit(&con->c_lock);
 		npf_stats_inc(npc->npc_ctx, NPF_STAT_RACE_NAT);
 		return EISCONN;
 	}
@@ -616,7 +585,7 @@ npf_conn_setnat(const npf_cache_t *npc, npf_conn_t *con,
 		KASSERT(ret == con);
 
 		atomic_or_uint(&con->c_flags, CONN_REMOVED | CONN_EXPIRE);
-		mutex_exit(&con->c_lock);
+		npfk_mutex_exit(&con->c_lock);
 
 		npf_stats_inc(npc->npc_ctx, NPF_STAT_RACE_NAT);
 		return EISCONN;
@@ -624,7 +593,7 @@ npf_conn_setnat(const npf_cache_t *npc, npf_conn_t *con,
 
 	/* Associate the NAT entry and release the lock. */
 	con->c_nat = nt;
-	mutex_exit(&con->c_lock);
+	npfk_mutex_exit(&con->c_lock);
 	return 0;
 }
 
@@ -737,7 +706,7 @@ void
 npf_conn_remove(npf_conndb_t *cd, npf_conn_t *con)
 {
 	/* Remove both entries of the connection. */
-	mutex_enter(&con->c_lock);
+	npfk_mutex_enter(&con->c_lock);
 	if ((atomic_load_relaxed(&con->c_flags) & CONN_REMOVED) == 0) {
 		npf_connkey_t *fw, *bk;
 		npf_conn_t *ret __diagused;
@@ -753,7 +722,7 @@ npf_conn_remove(npf_conndb_t *cd, npf_conn_t *con)
 
 	/* Flag the removal and expiration. */
 	atomic_or_uint(&con->c_flags, CONN_REMOVED | CONN_EXPIRE);
-	mutex_exit(&con->c_lock);
+	npfk_mutex_exit(&con->c_lock);
 }
 
 /*
@@ -780,9 +749,9 @@ npf_conndb_export(npf_t *npf, nvlist_t *nvl)
 	 * Note: acquire conn_lock to prevent from the database
 	 * destruction and G/C thread.
 	 */
-	mutex_enter(&npf->conn_lock);
+	npfk_mutex_enter(&npf->conn_lock);
 	if (atomic_load_relaxed(&npf->conn_tracking) != CONN_TRACKING_ON) {
-		mutex_exit(&npf->conn_lock);
+		npfk_mutex_exit(&npf->conn_lock);
 		return 0;
 	}
 	conn_db = atomic_load_relaxed(&npf->conn_db);
@@ -801,7 +770,7 @@ npf_conndb_export(npf_t *npf, nvlist_t *nvl)
 			break;
 		}
 	}
-	mutex_exit(&npf->conn_lock);
+	npfk_mutex_exit(&npf->conn_lock);
 	return 0;
 }
 
@@ -874,7 +843,7 @@ npf_conn_import(npf_t *npf, npf_conndb_t *cd, const nvlist_t *cdict,
 	/* Allocate a connection and initialize it (clear first). */
 	con = pool_cache_get(npf->conn_cache[idx], PR_WAITOK);
 	memset(con, 0, sizeof(npf_conn_t));
-	mutex_init(&con->c_lock, MUTEX_DEFAULT, IPL_SOFTNET);
+	npfk_mutex_init(&con->c_lock);
 	npf_stats_inc(npf, NPF_STAT_CONN_CREATE);
 
 	con->c_proto = dnvlist_get_number(cdict, "proto", 0);
@@ -975,11 +944,11 @@ npf_conn_print(npf_conn_t *con)
 	const npf_connkey_t *bk = npf_conn_getbackkey(con, NPF_CONNKEY_ALEN(fw));
 	const unsigned flags = atomic_load_relaxed(&con->c_flags);
 	const unsigned proto = con->c_proto;
-	struct timespec tspnow;
+	TEE_Time tspnow;
 
 	getnanouptime(&tspnow);
-	printf("%p:\n\tproto %d flags 0x%x tsdiff %ld etime %d\n", con,
-	    proto, flags, (long)(tspnow.tv_sec - con->c_atime),
+	DMSG("%p:\n\tproto %d flags 0x%x tsdiff %ld etime %d\n", con,
+	    proto, flags, (long)(tspnow.seconds - con->c_atime),
 	    npf_state_etime(npf_getkernctx(), &con->c_state, proto));
 	npf_connkey_print(fw);
 	npf_connkey_print(bk);
diff --git a/src/kern/npf_conn.h b/src/kern/npf_conn.h
index 0e0bc5d..82a0caf 100644
--- a/src/kern/npf_conn.h
+++ b/src/kern/npf_conn.h
@@ -30,9 +30,6 @@
 #ifndef _NPF_CONN_H_
 #define _NPF_CONN_H_
 
-#if !defined(_KERNEL) && !defined(_NPF_STANDALONE)
-#error "kernel-level header only"
-#endif
 
 #include <sys/types.h>
 
@@ -79,7 +76,7 @@ struct npf_conn {
 	uint32_t		c_atime;
 
 	/* The protocol state and lock. */
-	kmutex_t		c_lock;
+	npfk_kmutex_t		c_lock;
 	npf_state_t		c_state;
 
 	/*
diff --git a/src/kern/npf_conndb.c b/src/kern/npf_conndb.c
index 324114e..c3f71ae 100644
--- a/src/kern/npf_conndb.c
+++ b/src/kern/npf_conndb.c
@@ -49,17 +49,6 @@
  *	network stack invokes NPF at IPL_SOFTNET or lower, but not higher.
  */
 
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD$");
-
-#include <sys/param.h>
-#include <sys/types.h>
-
-#include <sys/atomic.h>
-#include <sys/kmem.h>
-#include <sys/thmap.h>
-#endif
 
 #define __NPF_CONN_PRIVATE
 #include "npf_conn.h"
@@ -306,7 +295,7 @@ npf_conndb_gc_incr(npf_t *npf, npf_conndb_t *cd, const time_t now)
 	unsigned gc_conns = 0;
 	npf_conn_t *con;
 
-	KASSERT(mutex_owned(&npf->conn_lock));
+	KASSERT(npfk_mutex_owned(&npf->conn_lock));
 
 	/*
 	 * Second, start from the "last" (marker) connection.
@@ -388,7 +377,7 @@ gc_freq_tune(const npf_t *npf, const npf_conndb_t *cd, const unsigned n)
 void
 npf_conndb_gc(npf_t *npf, npf_conndb_t *cd, bool flush, bool sync)
 {
-	struct timespec tsnow;
+	TEE_Time tsnow;
 	unsigned gc_conns = 0;
 	npf_conn_t *con;
 	void *gcref;
@@ -396,7 +385,7 @@ npf_conndb_gc(npf_t *npf, npf_conndb_t *cd, bool flush, bool sync)
 	getnanouptime(&tsnow);
 
 	/* First, migrate all new connections. */
-	mutex_enter(&npf->conn_lock);
+	npfk_mutex_enter(&npf->conn_lock);
 	npf_conndb_update(cd);
 	if (flush) {
 		/* Just unlink and move all connections to the G/C list. */
@@ -408,9 +397,9 @@ npf_conndb_gc(npf_t *npf, npf_conndb_t *cd, bool flush, bool sync)
 		cd->cd_marker = NULL;
 	} else {
 		/* Incremental G/C of the expired connections. */
-		gc_conns = npf_conndb_gc_incr(npf, cd, tsnow.tv_sec);
+		gc_conns = npf_conndb_gc_incr(npf, cd, tsnow.seconds);
 	}
-	mutex_exit(&npf->conn_lock);
+	npfk_mutex_exit(&npf->conn_lock);
 
 	/*
 	 * Ensure it is safe to destroy the connections.
diff --git a/src/kern/npf_connkey.c b/src/kern/npf_connkey.c
index e2ba32b..6baaf5a 100644
--- a/src/kern/npf_connkey.c
+++ b/src/kern/npf_connkey.c
@@ -69,13 +69,8 @@
  * WARNING: the keys must be immutable while they are in conndb.
  */
 
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD$");
 
-#include <sys/param.h>
-#include <sys/types.h>
-#endif
+#include <trace.h>
 
 #define __NPF_CONN_PRIVATE
 #include "npf_conn.h"
@@ -386,9 +381,9 @@ npf_connkey_print(const npf_connkey_t *key)
 
 	npf_connkey_getkey(key, &alen, &proto, ips, ids);
 	npf_connkey_getckey(key, &ifid, &di);
-	printf("\tkey (ifid %u, di %x)\t", ifid, di);
-	printf("%s:%u", npf_addr_dump(&ips[0], alen), ids[0]);
-	printf("-> %s:%u\n", npf_addr_dump(&ips[1], alen), ids[1]);
+	DMSG("\tkey (ifid %u, di %x)\t", ifid, di);
+	DMSG("%s:%u", npf_addr_dump(&ips[0], alen), ids[0]);
+	DMSG("-> %s:%u\n", npf_addr_dump(&ips[1], alen), ids[1]);
 }
 
 #endif
diff --git a/src/kern/npf_ctl.c b/src/kern/npf_ctl.c
index 0d4b5e9..b4e5e11 100644
--- a/src/kern/npf_ctl.c
+++ b/src/kern/npf_ctl.c
@@ -34,15 +34,6 @@
  * NPF nvlist(3) consumer.
  */
 
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD$");
-
-#include <sys/param.h>
-#include <sys/conf.h>
-#include <sys/kmem.h>
-#include <net/bpf.h>
-#endif
 
 #include "npf_impl.h"
 #include "npf_conn.h"
diff --git a/src/kern/npf_ext_log.c b/src/kern/npf_ext_log.c
index 88f2064..1943447 100644
--- a/src/kern/npf_ext_log.c
+++ b/src/kern/npf_ext_log.c
@@ -31,23 +31,6 @@
  * NPF logging extension.
  */
 
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD$");
-
-#include <sys/types.h>
-#include <sys/module.h>
-
-#include <sys/conf.h>
-#include <sys/kmem.h>
-#include <sys/mbuf.h>
-#include <sys/mutex.h>
-#include <sys/queue.h>
-
-#include <net/if.h>
-#include <net/if_types.h>
-#include <net/bpf.h>
-#endif
 
 #include "npf_impl.h"
 #include "if_npflog.h"
@@ -171,23 +154,3 @@ npf_ext_log_fini(npf_t *npf)
 	return npf_ext_unregister(npf, npf_ext_log_id);
 }
 
-#ifdef _KERNEL
-static int
-npf_ext_log_modcmd(modcmd_t cmd, void *arg)
-{
-	npf_t *npf = npf_getkernctx();
-
-	switch (cmd) {
-	case MODULE_CMD_INIT:
-		return npf_ext_log_init(npf);
-	case MODULE_CMD_FINI:
-		return npf_ext_log_fini(npf);
-		break;
-	case MODULE_CMD_AUTOUNLOAD:
-		return npf_autounload_p() ? 0 : EBUSY;
-	default:
-		return ENOTTY;
-	}
-	return 0;
-}
-#endif
diff --git a/src/kern/npf_ext_normalize.c b/src/kern/npf_ext_normalize.c
index 2c73caf..4efc59c 100644
--- a/src/kern/npf_ext_normalize.c
+++ b/src/kern/npf_ext_normalize.c
@@ -24,19 +24,6 @@
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD$");
-
-#include <sys/types.h>
-#include <sys/module.h>
-#include <sys/kmem.h>
-
-#include <net/if.h>
-#include <netinet/in_systm.h>
-#include <netinet/in.h>
-#include <netinet/in_var.h>
-#endif
 
 #include "npf.h"
 #include "npf_impl.h"
@@ -225,22 +212,3 @@ npf_ext_normalize_fini(npf_t *npf)
 	return npf_ext_unregister(npf, npf_ext_normalize_id);
 }
 
-#ifdef _KERNEL
-static int
-npf_ext_normalize_modcmd(modcmd_t cmd, void *arg)
-{
-	npf_t *npf = npf_getkernctx();
-
-	switch (cmd) {
-	case MODULE_CMD_INIT:
-		return npf_ext_normalize_init(npf);
-	case MODULE_CMD_FINI:
-		return npf_ext_unregister(npf, npf_ext_normalize_id);
-	case MODULE_CMD_AUTOUNLOAD:
-		return npf_autounload_p() ? 0 : EBUSY;
-	default:
-		return ENOTTY;
-	}
-	return 0;
-}
-#endif
diff --git a/src/kern/npf_ext_rndblock.c b/src/kern/npf_ext_rndblock.c
index 1603ac1..6ff5a35 100644
--- a/src/kern/npf_ext_rndblock.c
+++ b/src/kern/npf_ext_rndblock.c
@@ -29,16 +29,6 @@
  * This is also a demo extension.
  */
 
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD$");
-
-#include <sys/types.h>
-#include <sys/cprng.h>
-#include <sys/atomic.h>
-#include <sys/module.h>
-#include <sys/kmem.h>
-#endif
 
 #include "npf_impl.h"
 
@@ -164,26 +154,3 @@ npf_ext_rndblock_fini(npf_t *npf)
 	return npf_ext_unregister(npf, npf_ext_rndblock_id);
 }
 
-#ifdef _KERNEL
-/*
- * Kernel module interface.
- */
-static int
-npf_ext_rndblock_modcmd(modcmd_t cmd, void *arg)
-{
-	npf_t *npf = npf_getkernctx();
-
-	switch (cmd) {
-	case MODULE_CMD_INIT:
-		return npf_ext_rndblock_init(npf);
-	case MODULE_CMD_FINI:
-		return npf_ext_rndblock_fini(npf);
-	case MODULE_CMD_AUTOUNLOAD:
-		/* Allow auto-unload only if NPF permits it. */
-		return npf_autounload_p() ? 0 : EBUSY;
-	default:
-		return ENOTTY;
-	}
-	return 0;
-}
-#endif
diff --git a/src/kern/npf_handler.c b/src/kern/npf_handler.c
index 793ba7c..46365db 100644
--- a/src/kern/npf_handler.c
+++ b/src/kern/npf_handler.c
@@ -44,39 +44,16 @@
  *	while in the critical path, on the relevant objects.
  */
 
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD$");
-
-#include <sys/types.h>
-#include <sys/param.h>
-
-#include <sys/mbuf.h>
-#include <sys/mutex.h>
-#include <net/if.h>
-#include <net/pfil.h>
-#include <sys/socketvar.h>
-
-#include <netinet/in_systm.h>
-#include <netinet/in.h>
-#include <netinet/ip_var.h>
-#include <netinet/ip6.h>
-#include <netinet6/ip6_var.h>
-#endif
 
 #include "npf_impl.h"
 #include "npf_conn.h"
 
-#if defined(_NPF_STANDALONE)
 #define	m_freem(m)		npf->mbufops->free(m)
 #define	m_clear_flag(m,f)
-#else
-#define	m_clear_flag(m,f)	(m)->m_flags &= ~(f)
-#endif
 
-#ifndef INET6
+//#define BSTGW_NPFKERN_DEBUG
+
 #define ip6_reass_packet(x, y)	ENOTSUP
-#endif
 
 static int
 npf_reassembly(npf_t *npf, npf_cache_t *npc, bool *mff)
@@ -225,9 +202,15 @@ npfk_packet_handler(npf_t *npf, struct mbuf **mp, ifnet_t *ifp, int di)
 		npf_config_read_exit(npf, slock);
 
 		if (pass) {
+#ifdef BSTGW_NPFKERN_DEBUG
+			DMSG("Default PASS");
+#endif
 			npf_stats_inc(npf, NPF_STAT_PASS_DEFAULT);
 			goto pass;
 		}
+#ifdef BSTGW_NPFKERN_DEBUG
+		DMSG("Default BLOCK");
+#endif
 		npf_stats_inc(npf, NPF_STAT_BLOCK_DEFAULT);
 		goto block;
 	}
diff --git a/src/kern/npf_if.c b/src/kern/npf_if.c
index ed533ac..e4c5734 100644
--- a/src/kern/npf_if.c
+++ b/src/kern/npf_if.c
@@ -54,15 +54,8 @@
  * A linear counter is used for IDs.
  */
 
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD$");
 
-#include <sys/param.h>
-#include <sys/types.h>
-#include <sys/kmem.h>
-#include <net/if.h>
-#endif
+#include <trace.h>
 
 #include "npf_impl.h"
 
@@ -83,7 +76,7 @@ npf_ifmap_init(npf_t *npf, const npf_ifops_t *ifops)
 	KASSERT(ifops != NULL);
 	ifops->flush(npf, (void *)(uintptr_t)0);
 
-	mutex_init(&npf->ifmap_lock, MUTEX_DEFAULT, IPL_SOFTNET);
+	npfk_mutex_init(&npf->ifmap_lock);
 	npf->ifmap = kmem_zalloc(nbytes, KM_SLEEP);
 	npf->ifmap_cnt = 0;
 	npf->ifmap_off = 0;
@@ -94,14 +87,14 @@ void
 npf_ifmap_fini(npf_t *npf)
 {
 	const size_t nbytes = sizeof(npf_ifmap_t) * NPF_MAX_IFMAP;
-	mutex_destroy(&npf->ifmap_lock);
+	npfk_mutex_destroy(&npf->ifmap_lock);
 	kmem_free(npf->ifmap, nbytes);
 }
 
 static unsigned
 npf_ifmap_lookup(npf_t *npf, const char *ifname)
 {
-	KASSERT(mutex_owned(&npf->ifmap_lock));
+	KASSERT(npfk_mutex_owned(&npf->ifmap_lock));
 
 	for (unsigned i = 0; i < npf->ifmap_cnt; i++) {
 		npf_ifmap_t *ifmap = &npf->ifmap[i];
@@ -127,12 +120,12 @@ npf_ifmap_register(npf_t *npf, const char *ifname)
 	unsigned id, i;
 	ifnet_t *ifp;
 
-	mutex_enter(&npf->ifmap_lock);
+	npfk_mutex_enter(&npf->ifmap_lock);
 	if ((id = npf_ifmap_lookup(npf, ifname)) != NPF_IFMAP_NOID) {
 		goto out;
 	}
 	if (npf->ifmap_cnt == NPF_MAX_IFMAP) {
-		printf("npf_ifmap_new: out of slots; bump NPF_MAX_IFMAP\n");
+		EMSG("npf_ifmap_new: out of slots; bump NPF_MAX_IFMAP\n");
 		id = NPF_IFMAP_NOID;
 		goto out;
 	}
@@ -148,14 +141,14 @@ npf_ifmap_register(npf_t *npf, const char *ifname)
 		npf->ifops->setmeta(npf, ifp, (void *)(uintptr_t)id);
 	}
 out:
-	mutex_exit(&npf->ifmap_lock);
+	npfk_mutex_exit(&npf->ifmap_lock);
 	return id;
 }
 
 void
 npf_ifmap_flush(npf_t *npf)
 {
-	mutex_enter(&npf->ifmap_lock);
+	npfk_mutex_enter(&npf->ifmap_lock);
 	npf->ifops->flush(npf, (void *)(uintptr_t)NPF_IFMAP_NOID);
 	for (unsigned i = 0; i < npf->ifmap_cnt; i++) {
 		npf->ifmap[i].ifname[0] = '\0';
@@ -171,7 +164,7 @@ npf_ifmap_flush(npf_t *npf)
 	} else {
 		npf->ifmap_off = 0;
 	}
-	mutex_exit(&npf->ifmap_lock);
+	npfk_mutex_exit(&npf->ifmap_lock);
 }
 
 /*
@@ -217,9 +210,9 @@ npf_ifmap_copylogname(npf_t *npf, unsigned id, char *buf, size_t len)
 void
 npf_ifmap_copyname(npf_t *npf, unsigned id, char *buf, size_t len)
 {
-	mutex_enter(&npf->ifmap_lock);
+	npfk_mutex_enter(&npf->ifmap_lock);
 	npf_ifmap_copylogname(npf, id, buf, len);
-	mutex_exit(&npf->ifmap_lock);
+	npfk_mutex_exit(&npf->ifmap_lock);
 }
 
 __dso_public void
@@ -228,17 +221,17 @@ npfk_ifmap_attach(npf_t *npf, ifnet_t *ifp)
 	const npf_ifops_t *ifops = npf->ifops;
 	unsigned id;
 
-	mutex_enter(&npf->ifmap_lock);
+	npfk_mutex_enter(&npf->ifmap_lock);
 	id = npf_ifmap_lookup(npf, ifops->getname(npf, ifp));
 	ifops->setmeta(npf, ifp, (void *)(uintptr_t)id);
-	mutex_exit(&npf->ifmap_lock);
+	npfk_mutex_exit(&npf->ifmap_lock);
 }
 
 __dso_public void
 npfk_ifmap_detach(npf_t *npf, ifnet_t *ifp)
 {
 	/* Diagnostic. */
-	mutex_enter(&npf->ifmap_lock);
+	npfk_mutex_enter(&npf->ifmap_lock);
 	npf->ifops->setmeta(npf, ifp, (void *)(uintptr_t)NPF_IFMAP_NOID);
-	mutex_exit(&npf->ifmap_lock);
+	npfk_mutex_exit(&npf->ifmap_lock);
 }
diff --git a/src/kern/npf_ifaddr.c b/src/kern/npf_ifaddr.c
index 7704e92..c7e7109 100644
--- a/src/kern/npf_ifaddr.c
+++ b/src/kern/npf_ifaddr.c
@@ -31,18 +31,6 @@
  * NPF network interface handling module.
  */
 
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD$");
-
-#include <sys/param.h>
-#include <sys/types.h>
-#include <sys/kmem.h>
-
-#include <net/if.h>
-#include <netinet/in.h>
-#include <netinet6/in6_var.h>
-#endif
 
 #include "npf_impl.h"
 
diff --git a/src/kern/npf_impl.h b/src/kern/npf_impl.h
index e57c015..a7bc5be 100644
--- a/src/kern/npf_impl.h
+++ b/src/kern/npf_impl.h
@@ -35,24 +35,8 @@
 #ifndef _NPF_IMPL_H_
 #define _NPF_IMPL_H_
 
-#if !defined(_KERNEL) && !defined(_NPF_STANDALONE)
-#error "Kernel-level header only"
-#endif
-
-#ifdef _KERNEL_OPT
-/* For INET/INET6 definitions. */
-#include "opt_inet.h"
-#include "opt_inet6.h"
-#endif
 
-#ifdef _KERNEL
-#include <sys/types.h>
-#include <sys/queue.h>
 
-#include <net/bpf.h>
-#include <net/bpfjit.h>
-#include <net/if.h>
-#endif
 #include <dnv.h>
 #include <nv.h>
 
@@ -60,7 +44,8 @@
 #include "npfkern.h"
 
 #ifdef _NPF_DEBUG
-#define	NPF_PRINTF(x)	printf x
+#include <trace.h>
+#define	NPF_PRINTF(x)	DMSG(x)
 #else
 #define	NPF_PRINTF(x)
 #endif
@@ -208,7 +193,7 @@ typedef enum {
 
 struct npf {
 	/* Active NPF configuration. */
-	kmutex_t		config_lock;
+	npfk_kmutex_t		config_lock;
 	ebr_t *			ebr;
 	npf_config_t *		config;
 
@@ -231,7 +216,7 @@ struct npf {
 	 * There are two caches (pools): for IPv4 and IPv6.
 	 */
 	volatile int		conn_tracking;
-	kmutex_t		conn_lock;
+	npfk_kmutex_t		conn_lock;
 	npf_conndb_t *		conn_db;
 	pool_cache_t		conn_cache[2];
 
@@ -244,11 +229,11 @@ struct npf {
 	struct npf_ifmap *	ifmap;
 	unsigned		ifmap_cnt;
 	unsigned		ifmap_off;
-	kmutex_t		ifmap_lock;
+	npfk_kmutex_t		ifmap_lock;
 
 	/* List of extensions and its lock. */
 	LIST_HEAD(, npf_ext)	ext_list;
-	kmutex_t		ext_lock;
+	npfk_kmutex_t		ext_lock;
 
 	/* Associated worker information. */
 	unsigned		worker_flags;
@@ -303,7 +288,7 @@ npf_tableset_t *npf_config_tableset(npf_t *npf);
 bool		npf_default_pass(npf_t *);
 bool		npf_active_p(void);
 
-int		npf_worker_sysinit(unsigned);
+int		npf_worker_sysinit(void);
 void		npf_worker_sysfini(void);
 int		npf_worker_addfunc(npf_t *, npf_workfunc_t);
 void		npf_worker_enlist(npf_t *);
diff --git a/src/kern/npf_inet.c b/src/kern/npf_inet.c
index 580a103..7d8c8c4 100644
--- a/src/kern/npf_inet.c
+++ b/src/kern/npf_inet.c
@@ -36,27 +36,6 @@
  * on rewrites (e.g. by translation routines).
  */
 
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD$");
-
-#include <sys/param.h>
-#include <sys/types.h>
-
-#include <net/pfil.h>
-#include <net/if.h>
-#include <net/ethertypes.h>
-#include <net/if_ether.h>
-
-#include <netinet/in_systm.h>
-#include <netinet/in.h>
-#include <netinet6/in6_var.h>
-#include <netinet/ip.h>
-#include <netinet/ip6.h>
-#include <netinet/tcp.h>
-#include <netinet/udp.h>
-#include <netinet/ip_icmp.h>
-#endif
 
 #include "npf_impl.h"
 
diff --git a/src/kern/npf_mbuf.c b/src/kern/npf_mbuf.c
index ec757e5..2539f9d 100644
--- a/src/kern/npf_mbuf.c
+++ b/src/kern/npf_mbuf.c
@@ -34,25 +34,10 @@
  * abstracted within this source.
  */
 
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD$");
-
-#include <sys/param.h>
-#include <sys/mbuf.h>
-#include <netinet/in_offload.h>
-#endif
 
 #include "npf_impl.h"
 
-#ifdef _KERNEL
-#ifdef INET6
-#include <netinet6/in6.h>
-#include <netinet6/in6_offload.h>
-#endif
-#endif
 
-#if defined(_NPF_STANDALONE)
 #define	m_length(m)		(nbuf)->nb_mops->getchainlen(m)
 #define	m_buflen(m)		(nbuf)->nb_mops->getlen(m)
 #define	m_next_ptr(m)		(nbuf)->nb_mops->getnext(m)
@@ -61,11 +46,6 @@ __KERNEL_RCSID(0, "$NetBSD$");
 #define	mtod(m,t)		((t)((nbuf)->nb_mops->getdata(m)))
 #define	m_flags_p(m,f)		true
 #define	M_UNWRITABLE(m, l)	false
-#else
-#define	m_next_ptr(m)		(m)->m_next
-#define	m_buflen(m)		((size_t)(m)->m_len)
-#define	m_flags_p(m,f)		(((m)->m_flags & (f)) != 0)
-#endif
 
 #define	NBUF_ENSURE_ALIGN	(MAX(COHERENCY_UNIT, 64))
 #define	NBUF_ENSURE_MASK	(NBUF_ENSURE_ALIGN - 1)
@@ -269,30 +249,7 @@ nbuf_ensure_writable(nbuf_t *nbuf, size_t len)
 bool
 nbuf_cksum_barrier(nbuf_t *nbuf, int di)
 {
-#ifdef _KERNEL
-	struct mbuf *m;
-
-	if (di != PFIL_OUT) {
-		return false;
-	}
-	m = nbuf->nb_mbuf0;
-	KASSERT(m_flags_p(m, M_PKTHDR));
-
-	if (m->m_pkthdr.csum_flags & (M_CSUM_TCPv4 | M_CSUM_UDPv4)) {
-		in_undefer_cksum_tcpudp(m);
-		m->m_pkthdr.csum_flags &= ~(M_CSUM_TCPv4 | M_CSUM_UDPv4);
-		return true;
-	}
-#ifdef INET6
-	if (m->m_pkthdr.csum_flags & (M_CSUM_TCPv6 | M_CSUM_UDPv6)) {
-		in6_undefer_cksum_tcpudp(m);
-		m->m_pkthdr.csum_flags &= ~(M_CSUM_TCPv6 | M_CSUM_UDPv6);
-		return true;
-	}
-#endif
-#else
 	(void)nbuf; (void)di;
-#endif
 	return false;
 }
 
@@ -305,26 +262,10 @@ int
 nbuf_add_tag(nbuf_t *nbuf, uint32_t val)
 {
 	struct mbuf *m = nbuf->nb_mbuf0;
-#ifdef _KERNEL
-	struct m_tag *mt;
-	uint32_t *dat;
-
-	KASSERT(m_flags_p(m, M_PKTHDR));
-
-	mt = m_tag_get(PACKET_TAG_NPF, sizeof(uint32_t), M_NOWAIT);
-	if (mt == NULL) {
-		return ENOMEM;
-	}
-	dat = (uint32_t *)(mt + 1);
-	*dat = val;
-	m_tag_prepend(m, mt);
-	return 0;
-#else
 	if (!nbuf->nb_mops->set_tag) {
 		return ENOTSUP;
 	}
 	return nbuf->nb_mops->set_tag(m, val);
-#endif
 }
 
 /*
@@ -336,21 +277,8 @@ int
 nbuf_find_tag(nbuf_t *nbuf, uint32_t *val)
 {
 	struct mbuf *m = nbuf->nb_mbuf0;
-#ifdef _KERNEL
-	struct m_tag *mt;
-
-	KASSERT(m_flags_p(m, M_PKTHDR));
-
-	mt = m_tag_find(m, PACKET_TAG_NPF);
-	if (mt == NULL) {
-		return EINVAL;
-	}
-	*val = *(uint32_t *)(mt + 1);
-	return 0;
-#else
 	if (!nbuf->nb_mops->get_tag) {
 		return ENOTSUP;
 	}
 	return nbuf->nb_mops->get_tag(m, val);
-#endif
 }
diff --git a/src/kern/npf_nat.c b/src/kern/npf_nat.c
index 7bc6d07..f5dc8ce 100644
--- a/src/kern/npf_nat.c
+++ b/src/kern/npf_nat.c
@@ -65,20 +65,8 @@
  *	to the port map and NAT entry is destroyed when connection expires.
  */
 
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD$");
-
-#include <sys/param.h>
-#include <sys/types.h>
-
-#include <sys/atomic.h>
-#include <sys/condvar.h>
-#include <sys/kmem.h>
-#include <sys/mutex.h>
-#include <sys/pool.h>
-#include <sys/proc.h>
-#endif
+
+#include <trace.h>
 
 #include "npf_impl.h"
 #include "npf_conn.h"
@@ -88,7 +76,7 @@ __KERNEL_RCSID(0, "$NetBSD$");
  */
 struct npf_natpolicy {
 	npf_t *			n_npfctx;
-	kmutex_t		n_lock;
+	npfk_kmutex_t		n_lock;
 	LIST_HEAD(, npf_nat)	n_nat_list;
 	unsigned		n_refcnt;
 	uint64_t		n_id;
@@ -196,7 +184,7 @@ npf_natpolicy_create(npf_t *npf, const nvlist_t *nat, npf_ruleset_t *rset)
 	if (((np->n_type == NPF_NATIN) ^ (np->n_type == NPF_NATOUT)) == 0) {
 		goto err;
 	}
-	mutex_init(&np->n_lock, MUTEX_DEFAULT, IPL_SOFTNET);
+	npfk_mutex_init(&np->n_lock);
 	LIST_INIT(&np->n_nat_list);
 
 	/*
@@ -245,7 +233,7 @@ npf_natpolicy_create(npf_t *npf, const nvlist_t *nat, npf_ruleset_t *rset)
 	}
 	return np;
 err:
-	mutex_destroy(&np->n_lock);
+	npfk_mutex_destroy(&np->n_lock);
 	kmem_free(np, sizeof(npf_natpolicy_t));
 	return NULL;
 }
@@ -283,7 +271,7 @@ npf_natpolicy_release(npf_natpolicy_t *np)
 		return;
 	}
 	KASSERT(LIST_EMPTY(&np->n_nat_list));
-	mutex_destroy(&np->n_lock);
+	npfk_mutex_destroy(&np->n_lock);
 	kmem_free(np, sizeof(npf_natpolicy_t));
 }
 
@@ -303,13 +291,13 @@ npf_natpolicy_destroy(npf_natpolicy_t *np)
 	if (atomic_load_relaxed(&np->n_refcnt) > 1) {
 		npf_nat_t *nt;
 
-		mutex_enter(&np->n_lock);
+		npfk_mutex_enter(&np->n_lock);
 		LIST_FOREACH(nt, &np->n_nat_list, nt_entry) {
 			npf_conn_t *con = nt->nt_conn;
 			KASSERT(con != NULL);
 			npf_conn_expire(con);
 		}
-		mutex_exit(&np->n_lock);
+		npfk_mutex_exit(&np->n_lock);
 		npf_worker_signal(np->n_npfctx);
 	}
 	KASSERT(atomic_load_relaxed(&np->n_refcnt) >= 1);
@@ -328,14 +316,14 @@ npf_nat_freealg(npf_natpolicy_t *np, npf_alg_t *alg)
 {
 	npf_nat_t *nt;
 
-	mutex_enter(&np->n_lock);
+	npfk_mutex_enter(&np->n_lock);
 	LIST_FOREACH(nt, &np->n_nat_list, nt_entry) {
 		if (nt->nt_alg == alg) {
 			npf_alg_destroy(np->n_npfctx, alg, nt, nt->nt_conn);
 			nt->nt_alg = NULL;
 		}
 	}
-	mutex_exit(&np->n_lock);
+	npfk_mutex_exit(&np->n_lock);
 }
 
 /*
@@ -568,10 +556,10 @@ npf_nat_create(npf_cache_t *npc, npf_natpolicy_t *np, npf_conn_t *con)
 		nt->nt_tport = np->n_tport;
 	}
 out:
-	mutex_enter(&np->n_lock);
+	npfk_mutex_enter(&np->n_lock);
 	LIST_INSERT_HEAD(&np->n_nat_list, nt, nt_entry);
 	/* Note: we also consume the reference on policy. */
-	mutex_exit(&np->n_lock);
+	npfk_mutex_exit(&np->n_lock);
 	return nt;
 }
 
@@ -884,9 +872,9 @@ npf_nat_destroy(npf_conn_t *con, npf_nat_t *nt)
 	 * Remove the connection from the list and drop the reference on
 	 * the NAT policy.  Note: this might trigger its destruction.
 	 */
-	mutex_enter(&np->n_lock);
+	npfk_mutex_enter(&np->n_lock);
 	LIST_REMOVE(nt, nt_entry);
-	mutex_exit(&np->n_lock);
+	npfk_mutex_exit(&np->n_lock);
 	npf_natpolicy_release(np);
 
 	pool_cache_put(nat_cache, nt);
@@ -1002,13 +990,13 @@ npf_nat_dump(const npf_nat_t *nt)
 
 	np = nt->nt_natpolicy;
 	memcpy(&ip, &nt->nt_taddr, sizeof(ip));
-	printf("\tNATP(%p): type %u flags 0x%x taddr %s tport %d\n", np,
+	IMSG("\tNATP(%p): type %u flags 0x%x taddr %s tport %d\n", np,
 	    np->n_type, np->n_flags, inet_ntoa(ip), ntohs(np->n_tport));
 	memcpy(&ip, &nt->nt_oaddr, sizeof(ip));
-	printf("\tNAT: original address %s oport %d tport %d\n",
+	IMSG("\tNAT: original address %s oport %d tport %d\n",
 	    inet_ntoa(ip), ntohs(nt->nt_oport), ntohs(nt->nt_tport));
 	if (nt->nt_alg) {
-		printf("\tNAT ALG = %p, ARG = %p\n",
+		IMSG("\tNAT ALG = %p, ARG = %p\n",
 		    nt->nt_alg, (void *)nt->nt_alg_arg);
 	}
 }
diff --git a/src/kern/npf_os.c b/src/kern/npf_os.c
index 80006dd..bea88cb 100644
--- a/src/kern/npf_os.c
+++ b/src/kern/npf_os.c
@@ -31,43 +31,10 @@
  * NPF main: dynamic load/initialisation and unload routines.
  */
 
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD$");
-
-#ifdef _KERNEL_OPT
-#include "pf.h"
-#if NPF > 0
-#error "NPF and PF are mutually exclusive; please select one"
-#endif
-#endif
-
-#include <sys/param.h>
-#include <sys/types.h>
-
-#include <sys/conf.h>
-#include <sys/kauth.h>
-#include <sys/kmem.h>
-#include <sys/lwp.h>
-#include <sys/module.h>
-#include <sys/pserialize.h>
-#include <sys/socketvar.h>
-#include <sys/uio.h>
-
-#include <netinet/in.h>
-#include <netinet6/in6_var.h>
-#endif
 
 #include "npf_impl.h"
 #include "npfkern.h"
 
-#ifdef _KERNEL
-#ifndef _MODULE
-#include "opt_modular.h"
-#include "opt_net_mpsafe.h"
-#endif
-#include "ioconf.h"
-#endif
 
 /*
  * Module and device structures.
@@ -353,167 +320,6 @@ npf_ifop_setmeta(npf_t *npf __unused, ifnet_t *ifp, void *arg)
 	ifp->if_npf_private = arg;
 }
 
-#ifdef _KERNEL
-
-/*
- * Wrapper of the main packet handler to pass the kernel NPF context.
- */
-static int
-npfos_packet_handler(void *arg, struct mbuf **mp, ifnet_t *ifp, int di)
-{
-	npf_t *npf = npf_getkernctx();
-	return npfk_packet_handler(npf, mp, ifp, di);
-}
-
-/*
- * npf_ifhook: hook handling interface changes.
- */
-static void
-npf_ifhook(void *arg, unsigned long cmd, void *arg2)
-{
-	npf_t *npf = npf_getkernctx();
-	ifnet_t *ifp = arg2;
-
-	switch (cmd) {
-	case PFIL_IFNET_ATTACH:
-		npfk_ifmap_attach(npf, ifp);
-		npf_ifaddr_sync(npf, ifp);
-		break;
-	case PFIL_IFNET_DETACH:
-		npfk_ifmap_detach(npf, ifp);
-		npf_ifaddr_flush(npf, ifp);
-		break;
-	}
-}
-
-static void
-npf_ifaddrhook(void *arg, u_long cmd, void *arg2)
-{
-	npf_t *npf = npf_getkernctx();
-	struct ifaddr *ifa = arg2;
-
-	switch (cmd) {
-	case SIOCSIFADDR:
-	case SIOCAIFADDR:
-	case SIOCDIFADDR:
-#ifdef INET6
-	case SIOCSIFADDR_IN6:
-	case SIOCAIFADDR_IN6:
-	case SIOCDIFADDR_IN6:
-#endif
-		KASSERT(ifa != NULL);
-		break;
-	default:
-		return;
-	}
-	npf_ifaddr_sync(npf, ifa->ifa_ifp);
-}
-
-/*
- * npf_pfil_register: register pfil(9) hooks.
- */
-static int
-npf_pfil_register(bool init)
-{
-	npf_t *npf = npf_getkernctx();
-	int error = 0;
-
-	SOFTNET_KERNEL_LOCK_UNLESS_NET_MPSAFE();
-
-	/* Init: interface re-config and attach/detach hook. */
-	if (!npf_ph_if) {
-		npf_ph_if = pfil_head_get(PFIL_TYPE_IFNET, 0);
-		if (!npf_ph_if) {
-			error = ENOENT;
-			goto out;
-		}
-
-		error = pfil_add_ihook(npf_ifhook, NULL,
-		    PFIL_IFNET, npf_ph_if);
-		KASSERT(error == 0);
-
-		error = pfil_add_ihook(npf_ifaddrhook, NULL,
-		    PFIL_IFADDR, npf_ph_if);
-		KASSERT(error == 0);
-	}
-	if (init) {
-		goto out;
-	}
-
-	/* Check if pfil hooks are not already registered. */
-	if (pfil_registered) {
-		error = EEXIST;
-		goto out;
-	}
-
-	/* Capture points of the activity in the IP layer. */
-	npf_ph_inet = pfil_head_get(PFIL_TYPE_AF, (void *)AF_INET);
-	npf_ph_inet6 = pfil_head_get(PFIL_TYPE_AF, (void *)AF_INET6);
-	if (!npf_ph_inet && !npf_ph_inet6) {
-		error = ENOENT;
-		goto out;
-	}
-
-	/* Packet IN/OUT handlers for IP layer. */
-	if (npf_ph_inet) {
-		error = pfil_add_hook(npfos_packet_handler, npf,
-		    PFIL_ALL, npf_ph_inet);
-		KASSERT(error == 0);
-	}
-	if (npf_ph_inet6) {
-		error = pfil_add_hook(npfos_packet_handler, npf,
-		    PFIL_ALL, npf_ph_inet6);
-		KASSERT(error == 0);
-	}
-
-	/*
-	 * It is necessary to re-sync all/any interface address tables,
-	 * since we did not listen for any changes.
-	 */
-	npf_ifaddr_syncall(npf);
-	pfil_registered = true;
-out:
-	SOFTNET_KERNEL_UNLOCK_UNLESS_NET_MPSAFE();
-
-	return error;
-}
-
-/*
- * npf_pfil_unregister: unregister pfil(9) hooks.
- */
-static void
-npf_pfil_unregister(bool fini)
-{
-	npf_t *npf = npf_getkernctx();
-
-	SOFTNET_KERNEL_LOCK_UNLESS_NET_MPSAFE();
-
-	if (fini && npf_ph_if) {
-		(void)pfil_remove_ihook(npf_ifhook, NULL,
-		    PFIL_IFNET, npf_ph_if);
-		(void)pfil_remove_ihook(npf_ifaddrhook, NULL,
-		    PFIL_IFADDR, npf_ph_if);
-	}
-	if (npf_ph_inet) {
-		(void)pfil_remove_hook(npfos_packet_handler, npf,
-		    PFIL_ALL, npf_ph_inet);
-	}
-	if (npf_ph_inet6) {
-		(void)pfil_remove_hook(npfos_packet_handler, npf,
-		    PFIL_ALL, npf_ph_inet6);
-	}
-	pfil_registered = false;
-
-	SOFTNET_KERNEL_UNLOCK_UNLESS_NET_MPSAFE();
-}
-
-bool
-npf_active_p(void)
-{
-	return pfil_registered;
-}
-
-#endif
 
 #ifdef __NetBSD__
 
diff --git a/src/kern/npf_params.c b/src/kern/npf_params.c
index 8d89972..09f3e2f 100644
--- a/src/kern/npf_params.c
+++ b/src/kern/npf_params.c
@@ -24,17 +24,6 @@
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD$");
-
-#include <sys/param.h>
-#include <sys/types.h>
-
-#include <sys/kmem.h>
-#include <sys/queue.h>
-#include <sys/thmap.h>
-#endif
 
 #include "npf_impl.h"
 
diff --git a/src/kern/npf_portmap.c b/src/kern/npf_portmap.c
index b95b1e4..a5294bc 100644
--- a/src/kern/npf_portmap.c
+++ b/src/kern/npf_portmap.c
@@ -33,20 +33,6 @@
  *	same port map.
  */
 
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD$");
-
-#include <sys/param.h>
-#include <sys/types.h>
-
-#include <sys/atomic.h>
-#include <sys/bitops.h>
-#include <sys/kmem.h>
-#include <sys/mutex.h>
-#include <sys/cprng.h>
-#include <sys/thmap.h>
-#endif
 
 #include "npf_impl.h"
 
@@ -101,7 +87,7 @@ typedef struct bitmap {
 struct npf_portmap {
 	thmap_t	*		addr_map;
 	LIST_HEAD(, bitmap)	bitmap_list;
-	kmutex_t		list_lock;
+	npfk_kmutex_t		list_lock;
 	int			min_port;
 	int			max_port;
 };
@@ -142,7 +128,7 @@ npf_portmap_create(int min_port, int max_port)
 	npf_portmap_t *pm;
 
 	pm = kmem_zalloc(sizeof(npf_portmap_t), KM_SLEEP);
-	mutex_init(&pm->list_lock, MUTEX_DEFAULT, IPL_SOFTNET);
+	npfk_mutex_init(&pm->list_lock);
 	pm->addr_map = thmap_create(0, NULL, THMAP_NOCOPY);
 	pm->min_port = min_port;
 	pm->max_port = max_port;
@@ -156,7 +142,7 @@ npf_portmap_destroy(npf_portmap_t *pm)
 	KASSERT(LIST_EMPTY(&pm->bitmap_list));
 
 	thmap_destroy(pm->addr_map);
-	mutex_destroy(&pm->list_lock);
+	npfk_mutex_destroy(&pm->list_lock);
 	kmem_free(pm, sizeof(npf_portmap_t));
 }
 
@@ -237,38 +223,6 @@ bitmap_word_unpack(uint64_t x, unsigned bitvals[static 5])
 	return n;
 }
 
-#if 0
-static bool
-bitmap_isset(const bitmap_t *bm, unsigned bit)
-{
-	unsigned i, chunk_bit;
-	uint64_t bval, b;
-	bitmap_l1_t *bm1;
-
-	KASSERT(bit < PORTMAP_MAX_BITS);
-	i = bit >> PORTMAP_L0_SHIFT;
-	bval = atomic_load_relaxed(&bm->bits0[i]);
-
-	/*
-	 * Empty check.  Note: we can test the whole word against zero,
-	 * since zero bit values in the packed array result in bits set.
-	 */
-	if (bval == 0)
-		return false;
-
-	/* Level 0 check. */
-	chunk_bit = bit & PORTMAP_L0_MASK;
-	if ((bval & PORTMAP_L1_TAG) == 0)
-		return bitmap_word_isset(bval, chunk_bit);
-
-	/* Level 1 check. */
-	bm1 = PORTMAP_L1_GET(bval);
-	KASSERT(bm1 != NULL);
-	i = chunk_bit >> PORTMAP_L1_SHIFT;
-	b = UINT64_C(1) << (chunk_bit & PORTMAP_L1_MASK);
-	return (bm1->bits1[i] & b) != 0;
-}
-#endif
 
 static bool
 bitmap_set(bitmap_t *bm, unsigned bit)
@@ -422,9 +376,9 @@ npf_portmap_autoget(npf_portmap_t *pm, unsigned alen, const npf_addr_t *addr)
 
 		if (ret == bm) {
 			/* Success: insert the bitmap into the list. */
-			mutex_enter(&pm->list_lock);
+			npfk_mutex_enter(&pm->list_lock);
 			LIST_INSERT_HEAD(&pm->bitmap_list, bm, entry);
-			mutex_exit(&pm->list_lock);
+			npfk_mutex_exit(&pm->list_lock);
 		} else {
 			/* Race: use an existing bitmap. */
 			kmem_free(bm, sizeof(bitmap_t));
diff --git a/src/kern/npf_rproc.c b/src/kern/npf_rproc.c
index e18a226..f055b48 100644
--- a/src/kern/npf_rproc.c
+++ b/src/kern/npf_rproc.c
@@ -31,18 +31,6 @@
  * NPF extension and rule procedure interface.
  */
 
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD$");
-
-#include <sys/param.h>
-#include <sys/types.h>
-
-#include <sys/atomic.h>
-#include <sys/kmem.h>
-#include <sys/mutex.h>
-#include <sys/module.h>
-#endif
 
 #include "npf_impl.h"
 
@@ -80,7 +68,7 @@ struct npf_rproc {
 void
 npf_ext_init(npf_t *npf)
 {
-	mutex_init(&npf->ext_lock, MUTEX_DEFAULT, IPL_NONE);
+	npfk_mutex_init(&npf->ext_lock);
 	LIST_INIT(&npf->ext_list);
 }
 
@@ -88,7 +76,7 @@ void
 npf_ext_fini(npf_t *npf)
 {
 	KASSERT(LIST_EMPTY(&npf->ext_list));
-	mutex_destroy(&npf->ext_lock);
+	npfk_mutex_destroy(&npf->ext_lock);
 }
 
 /*
@@ -105,7 +93,7 @@ npf_ext_lookup(npf_t *npf, const char *name, bool autoload)
 	char modname[RPROC_NAME_LEN + NPF_EXT_PREFLEN];
 	int error;
 
-	KASSERT(mutex_owned(&npf->ext_lock));
+	KASSERT(npfk_mutex_owned(&npf->ext_lock));
 
 again:
 	LIST_FOREACH(ext, &npf->ext_list, ext_entry)
@@ -115,11 +103,11 @@ again:
 	if (ext != NULL || !autoload)
 		return ext;
 
-	mutex_exit(&npf->ext_lock);
+	npfk_mutex_exit(&npf->ext_lock);
 	autoload = false;
 	snprintf(modname, sizeof(modname), "%s%s", npf_ext_prefix, name);
 	error = module_autoload(modname, MODULE_CLASS_MISC);
-	mutex_enter(&npf->ext_lock);
+	npfk_mutex_enter(&npf->ext_lock);
 
 	if (error)
 		return NULL;
@@ -135,14 +123,14 @@ npf_ext_register(npf_t *npf, const char *name, const npf_ext_ops_t *ops)
 	strlcpy(ext->ext_callname, name, EXT_NAME_LEN);
 	ext->ext_ops = ops;
 
-	mutex_enter(&npf->ext_lock);
+	npfk_mutex_enter(&npf->ext_lock);
 	if (npf_ext_lookup(npf, name, false)) {
-		mutex_exit(&npf->ext_lock);
+		npfk_mutex_exit(&npf->ext_lock);
 		kmem_free(ext, sizeof(npf_ext_t));
 		return NULL;
 	}
 	LIST_INSERT_HEAD(&npf->ext_list, ext, ext_entry);
-	mutex_exit(&npf->ext_lock);
+	npfk_mutex_exit(&npf->ext_lock);
 
 	return (void *)ext;
 }
@@ -159,14 +147,14 @@ npf_ext_unregister(npf_t *npf, void *extid)
 		return EBUSY;
 	}
 
-	mutex_enter(&npf->ext_lock);
+	npfk_mutex_enter(&npf->ext_lock);
 	if (atomic_load_relaxed(&ext->ext_refcnt)) {
-		mutex_exit(&npf->ext_lock);
+		npfk_mutex_exit(&npf->ext_lock);
 		return EBUSY;
 	}
 	KASSERT(npf_ext_lookup(npf, ext->ext_callname, false));
 	LIST_REMOVE(ext, ext_entry);
-	mutex_exit(&npf->ext_lock);
+	npfk_mutex_exit(&npf->ext_lock);
 
 	kmem_free(ext, sizeof(npf_ext_t));
 	return 0;
@@ -185,12 +173,12 @@ npf_ext_construct(npf_t *npf, const char *name,
 		return ENOSPC;
 	}
 
-	mutex_enter(&npf->ext_lock);
+	npfk_mutex_enter(&npf->ext_lock);
 	ext = npf_ext_lookup(npf, name, true);
 	if (ext) {
 		atomic_inc_uint(&ext->ext_refcnt);
 	}
-	mutex_exit(&npf->ext_lock);
+	npfk_mutex_exit(&npf->ext_lock);
 
 	if (!ext) {
 		return ENOENT;
@@ -266,13 +254,6 @@ npf_rprocset_export(const npf_rprocset_t *rpset, nvlist_t *nvl)
 
 	LIST_FOREACH(rp, &rpset->rps_list, rp_entry) {
 		nvlist_t *rproc = nvlist_create(0);
-#if 0 // FIXME/TODO
-		for (unsigned i = 0; i < rp->rp_ext_count; i++) {
-			nvlist_t *meta = rp->rp_ext_meta[i];
-			...
-			nvlist_append_nvlist_array(rproc, "extcalls", meta);
-		}
-#endif
 		nvlist_add_string(rproc, "name", rp->rp_name);
 		nvlist_add_number(rproc, "flags", rp->rp_flags);
 		nvlist_append_nvlist_array(nvl, "rprocs", rproc);
diff --git a/src/kern/npf_ruleset.c b/src/kern/npf_ruleset.c
index 131db97..e79fadf 100644
--- a/src/kern/npf_ruleset.c
+++ b/src/kern/npf_ruleset.c
@@ -32,24 +32,8 @@
  * NPF ruleset module.
  */
 
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD$");
-
-#include <sys/param.h>
-#include <sys/types.h>
-
-#include <sys/atomic.h>
-#include <sys/kmem.h>
-#include <sys/queue.h>
-#include <sys/mbuf.h>
-#include <sys/types.h>
-
-#include <net/bpf.h>
-#include <net/bpfjit.h>
-#include <net/pfil.h>
-#include <net/if.h>
-#endif
+
+#include <trace.h>
 
 #include "npf_impl.h"
 
@@ -953,12 +937,12 @@ npf_ruleset_dump(npf_t *npf, const char *name)
 	npf_rule_t *rg, *rl;
 
 	LIST_FOREACH(rg, &rlset->rs_dynamic, r_dentry) {
-		printf("ruleset '%s':\n", rg->r_name);
+		DMSG("ruleset '%s':\n", rg->r_name);
 		for (rl = rg->r_subset; rl; rl = rl->r_next) {
-			printf("\tid %"PRIu64", key: ", rl->r_id);
+			DMSG("\tid %"PRIu64", key: ", rl->r_id);
 			for (unsigned i = 0; i < NPF_RULE_MAXKEYLEN; i++)
-				printf("%x", rl->r_key[i]);
-			printf("\n");
+				DMSG("%x", rl->r_key[i]);
+			DMSG("\n");
 		}
 	}
 }
diff --git a/src/kern/npf_sendpkt.c b/src/kern/npf_sendpkt.c
index 3e6688d..2ac8d1f 100644
--- a/src/kern/npf_sendpkt.c
+++ b/src/kern/npf_sendpkt.c
@@ -31,59 +31,20 @@
  * NPF module for packet construction routines.
  */
 
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD$");
-
-#include <sys/param.h>
-#include <sys/types.h>
-
-#include <netinet/in_systm.h>
-#include <netinet/in.h>
-#include <netinet/ip.h>
-#include <netinet/ip_icmp.h>
-#include <netinet/ip_var.h>
-#include <netinet/tcp.h>
-#include <netinet/ip6.h>
-#include <netinet/icmp6.h>
-#include <netinet6/ip6_var.h>
-#include <netinet6/scope6_var.h>
-#include <sys/mbuf.h>
-#endif
 
 #include "npf_impl.h"
 
 #define	DEFAULT_IP_TTL		(ip_defttl)
 
-#if defined(_NPF_STANDALONE)
 #define	m_gethdr(t, f)		(npf)->mbufops->alloc((npf), 0, 0)
 #define	m_freem(m)		(npc)->npc_ctx->mbufops->free(m)
 #define	mtod(m,t)		((t)((npc)->npc_ctx->mbufops->getdata(m)))
-#endif
 
-#if !defined(INET6) || defined(_NPF_STANDALONE)
 #define	in6_cksum(...)		0
 #define	ip6_output(...)		0
 #define	icmp6_error(m, ...)	m_freem(m)
 #define	npf_ip6_setscope(n, i)	((void)(i), 0)
-#endif
-
-#if defined(INET6)
-static int
-npf_ip6_setscope(const npf_cache_t *npc, struct ip6_hdr *ip6)
-{
-	const struct ifnet *rcvif = npc->npc_nbuf->nb_ifp;
 
-	if (in6_clearscope(&ip6->ip6_src) || in6_clearscope(&ip6->ip6_dst)) {
-		return EINVAL;
-	}
-	if (in6_setscope(&ip6->ip6_src, rcvif, NULL) ||
-	    in6_setscope(&ip6->ip6_dst, rcvif, NULL)) {
-		return EINVAL;
-	}
-	return 0;
-}
-#endif
 
 /*
  * npf_return_tcp: return a TCP reset (RST) packet.
@@ -123,12 +84,6 @@ npf_return_tcp(npf_cache_t *npc)
 	if (m == NULL) {
 		return ENOMEM;
 	}
-#if !defined(_NPF_STANDALONE)
-	m->m_data += max_linkhdr;
-	m->m_len = len;
-	m->m_pkthdr.len = len;
-	(void)npf;
-#endif
 	if (npf_iscached(npc, NPC_IP4)) {
 		struct ip *oip = npc->npc_ip.v4;
 
diff --git a/src/kern/npf_state.c b/src/kern/npf_state.c
index 891c25d..a0307e4 100644
--- a/src/kern/npf_state.c
+++ b/src/kern/npf_state.c
@@ -31,14 +31,8 @@
  * NPF state engine to track connection.
  */
 
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD$");
 
-#include <sys/param.h>
-#include <sys/systm.h>
-#include <sys/mutex.h>
-#endif
+#include <trace.h>
 
 #include "npf_impl.h"
 
@@ -247,7 +241,7 @@ npf_state_dump(const npf_state_t *nst)
 	const npf_tcpstate_t *fst = &nst->nst_tcpst[0];
 	const npf_tcpstate_t *tst = &nst->nst_tcpst[1];
 
-	printf("\tstate (%p) %d:\n\t\t"
+	DMSG("\tstate (%p) %d:\n\t\t"
 	    "F { end %u maxend %u mwin %u wscale %u }\n\t\t"
 	    "T { end %u maxend %u mwin %u wscale %u }\n",
 	    nst, nst->nst_state,
diff --git a/src/kern/npf_state_tcp.c b/src/kern/npf_state_tcp.c
index 55bed01..0663045 100644
--- a/src/kern/npf_state_tcp.c
+++ b/src/kern/npf_state_tcp.c
@@ -31,16 +31,6 @@
  * NPF TCP state engine for connection tracking.
  */
 
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD$");
-
-#include <sys/param.h>
-#include <sys/types.h>
-
-#include <netinet/in.h>
-#include <netinet/tcp.h>
-#endif
 
 #include "npf_impl.h"
 
diff --git a/src/kern/npf_tableset.c b/src/kern/npf_tableset.c
index 67d845c..d66b2cb 100644
--- a/src/kern/npf_tableset.c
+++ b/src/kern/npf_tableset.c
@@ -44,23 +44,6 @@
  *	npf_conndb.c source file.
  */
 
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD$");
-
-#include <sys/param.h>
-#include <sys/types.h>
-
-#include <sys/atomic.h>
-#include <sys/cdbr.h>
-#include <sys/kmem.h>
-#include <sys/pool.h>
-#include <sys/queue.h>
-#include <sys/mutex.h>
-#include <sys/thmap.h>
-
-#include "lpm.h"
-#endif
 
 #include "npf_impl.h"
 
@@ -105,7 +88,7 @@ struct npf_table {
 	 */
 	int			t_type;
 	unsigned		t_id;
-	kmutex_t		t_lock;
+	npfk_kmutex_t		t_lock;
 
 	/* Reference count and table name. */
 	unsigned		t_refcnt;
@@ -406,7 +389,7 @@ npf_table_create(const char *name, u_int tid, int type,
 	default:
 		KASSERT(false);
 	}
-	mutex_init(&t->t_lock, MUTEX_DEFAULT, IPL_NET);
+	npfk_mutex_init(&t->t_lock);
 	t->t_type = type;
 	t->t_id = tid;
 	return t;
@@ -443,7 +426,7 @@ npf_table_destroy(npf_table_t *t)
 	default:
 		KASSERT(false);
 	}
-	mutex_destroy(&t->t_lock);
+	npfk_mutex_destroy(&t->t_lock);
 	kmem_free(t, sizeof(npf_table_t));
 }
 
@@ -548,7 +531,7 @@ npf_table_insert(npf_table_t *t, const int alen,
 	/*
 	 * Insert the entry.  Return an error on duplicate.
 	 */
-	mutex_enter(&t->t_lock);
+	npfk_mutex_enter(&t->t_lock);
 	switch (t->t_type) {
 	case NPF_TABLE_IPSET:
 		/*
@@ -596,7 +579,7 @@ npf_table_insert(npf_table_t *t, const int alen,
 	default:
 		KASSERT(false);
 	}
-	mutex_exit(&t->t_lock);
+	npfk_mutex_exit(&t->t_lock);
 
 	if (error) {
 		pool_cache_put(tblent_cache, ent);
@@ -619,7 +602,7 @@ npf_table_remove(npf_table_t *t, const int alen,
 		return error;
 	}
 
-	mutex_enter(&t->t_lock);
+	npfk_mutex_enter(&t->t_lock);
 	switch (t->t_type) {
 	case NPF_TABLE_IPSET:
 		ent = thmap_del(t->t_map, addr, alen);
@@ -651,7 +634,7 @@ npf_table_remove(npf_table_t *t, const int alen,
 		KASSERT(false);
 		ent = NULL;
 	}
-	mutex_exit(&t->t_lock);
+	npfk_mutex_exit(&t->t_lock);
 
 	if (ent) {
 		pool_cache_put(tblent_cache, ent);
@@ -682,9 +665,9 @@ npf_table_lookup(npf_table_t *t, const int alen, const npf_addr_t *addr)
 		found = thmap_get(t->t_map, addr, alen) != NULL;
 		break;
 	case NPF_TABLE_LPM:
-		mutex_enter(&t->t_lock);
+		npfk_mutex_enter(&t->t_lock);
 		found = lpm_lookup(t->t_lpm, addr, alen) != NULL;
-		mutex_exit(&t->t_lock);
+		npfk_mutex_exit(&t->t_lock);
 		break;
 	case NPF_TABLE_CONST:
 		if (cdbr_find(t->t_cdb, addr, alen, &data, &dlen) == 0) {
@@ -799,7 +782,7 @@ npf_table_list(npf_table_t *t, void *ubuf, size_t len)
 {
 	int error = 0;
 
-	mutex_enter(&t->t_lock);
+	npfk_mutex_enter(&t->t_lock);
 	switch (t->t_type) {
 	case NPF_TABLE_IPSET:
 		error = table_generic_list(t, ubuf, len);
@@ -816,7 +799,7 @@ npf_table_list(npf_table_t *t, void *ubuf, size_t len)
 	default:
 		KASSERT(false);
 	}
-	mutex_exit(&t->t_lock);
+	npfk_mutex_exit(&t->t_lock);
 
 	return error;
 }
@@ -829,7 +812,7 @@ npf_table_flush(npf_table_t *t)
 {
 	int error = 0;
 
-	mutex_enter(&t->t_lock);
+	npfk_mutex_enter(&t->t_lock);
 	switch (t->t_type) {
 	case NPF_TABLE_IPSET:
 		table_ipset_flush(t);
@@ -844,7 +827,7 @@ npf_table_flush(npf_table_t *t)
 	default:
 		KASSERT(false);
 	}
-	mutex_exit(&t->t_lock);
+	npfk_mutex_exit(&t->t_lock);
 	return error;
 }
 
diff --git a/src/kern/npf_worker.c b/src/kern/npf_worker.c
index 472db4e..cb62f04 100644
--- a/src/kern/npf_worker.c
+++ b/src/kern/npf_worker.c
@@ -27,30 +27,40 @@
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
+/*
 #ifdef _KERNEL
 #include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD$");
 
 #include <sys/param.h>
 #include <sys/types.h>
 
 #include <sys/mutex.h>
-#include <sys/kmem.h>
 #include <sys/kernel.h>
-#include <sys/kthread.h>
-#include <sys/cprng.h>
 #endif
+*/
+
+#include <stdlib.h>
+
+#include <bstgw/worker_storage.h>
+#include <bstgw/worker_binding.h>
+
+#include <kernel/tee_ta_manager.h>
+#include <kernel/tee_time.h>
+#include <kernel/spinlock.h>
 
 #include "npf_impl.h"
 
+typedef int lwp_t; // TODO: was pthread_t
+
 typedef struct npf_worker {
-	kmutex_t		lock;
+	wrk_ls_t worker_npf_data;
+	worker_bind_t 	bind;
+
+	npfk_kmutex_t		lock;
 	kcondvar_t		cv;
 	kcondvar_t		exit_cv;
 	bool			exit;
 	LIST_HEAD(, npf)	instances;
-	unsigned		worker_count;
-	lwp_t *			worker[];
 } npf_workerinfo_t;
 
 #define	NPF_GC_MINWAIT		(10)		// 10 ms
@@ -63,36 +73,34 @@ typedef struct npf_worker {
 #define	WFLAG_INITED		0x02	// worker setup the instance
 #define	WFLAG_REMOVE		0x04	// remove the instance
 
-static void			npf_worker(void *)	__dead;
 static npf_workerinfo_t *	worker_info		__read_mostly;
 
 int
-npf_worker_sysinit(unsigned nworkers)
+npf_worker_sysinit(void)
 {
-	const size_t len = offsetof(npf_workerinfo_t, worker[nworkers]);
 	npf_workerinfo_t *winfo;
-
 	KASSERT(worker_info == NULL);
 
-	if (!nworkers) {
-		return 0;
-	}
+	winfo = calloc(1, sizeof(npf_workerinfo_t));
 
-	winfo = kmem_zalloc(len, KM_SLEEP);
-	winfo->worker_count = nworkers;
-	mutex_init(&winfo->lock, MUTEX_DEFAULT, IPL_SOFTNET);
+	winfo->bind.slock = SPINLOCK_UNLOCK;
+	winfo->bind.status = WORKER_UNBOUND;
+	winfo->bind.sess_id = 0;
+
+	npfk_mutex_init(&winfo->lock);
 	cv_init(&winfo->exit_cv, "npfgcx");
-	cv_init(&winfo->cv, "npfgcw");
+	//cv_init(&winfo->cv, "npfgcw");
 	LIST_INIT(&winfo->instances);
 	worker_info = winfo;
 
-	for (unsigned i = 0; i < nworkers; i++) {
+/*
 		if (kthread_create(PRI_NONE, KTHREAD_MPSAFE | KTHREAD_MUSTJOIN,
 		    NULL, npf_worker, winfo, &winfo->worker[i], "npfgc%u", i)) {
 			npf_worker_sysfini();
 			return ENOMEM;
 		}
-	}
+ */
+
 	return 0;
 }
 
@@ -100,31 +108,32 @@ void
 npf_worker_sysfini(void)
 {
 	npf_workerinfo_t *winfo = worker_info;
-	unsigned nworkers;
 
 	if (!winfo) {
 		return;
 	}
 
 	/* Notify the workers to exit. */
-	mutex_enter(&winfo->lock);
+	npfk_mutex_enter(&winfo->lock);
 	winfo->exit = true;
-	cv_broadcast(&winfo->cv);
-	mutex_exit(&winfo->lock);
+	//cv_broadcast(&winfo->cv);
+	npfk_mutex_exit(&winfo->lock);
 
 	/* Wait for them to finish and then destroy. */
-	nworkers = winfo->worker_count;
-	for (unsigned i = 0; i < nworkers; i++) {
-		lwp_t *worker;
-
+/*
 		if ((worker = winfo->worker[i]) != NULL) {
 			kthread_join(worker);
 		}
-	}
-	cv_destroy(&winfo->cv);
+ */
+
+	// TODO: somehow differently wait for worker to finish
+
+	// TODO: unbind NW thread
+
+	//cv_destroy(&winfo->cv);
 	cv_destroy(&winfo->exit_cv);
-	mutex_destroy(&winfo->lock);
-	kmem_free(winfo, offsetof(npf_workerinfo_t, worker[nworkers]));
+	npfk_mutex_destroy(&winfo->lock);
+	free(winfo);
 	worker_info = NULL;
 }
 
@@ -146,6 +155,7 @@ npf_worker_addfunc(npf_t *npf, npf_workfunc_t work)
 void
 npf_worker_signal(npf_t *npf)
 {
+	/*
 	npf_workerinfo_t *winfo = worker_info;
 
 	if ((npf->worker_flags & WFLAG_ACTIVE) == 0) {
@@ -153,13 +163,14 @@ npf_worker_signal(npf_t *npf)
 	}
 	KASSERT(winfo != NULL);
 
-	mutex_enter(&winfo->lock);
+	npfk_mutex_enter(&winfo->lock);
 	cv_signal(&winfo->cv);
-	mutex_exit(&winfo->lock);
+	npfk_mutex_exit(&winfo->lock);
+	*/
 }
 
 /*
- * npf_worker_enlist: add the NPF instance for worker(s) to process.
+ * npf_worker_enlist: add the NPF instance for worker to process.
  */
 void
 npf_worker_enlist(npf_t *npf)
@@ -171,14 +182,19 @@ npf_worker_enlist(npf_t *npf)
 		return;
 	}
 
-	mutex_enter(&winfo->lock);
+	npfk_mutex_enter(&winfo->lock);
+
+	// TODO: our current wrk_ls_t approach does NOT YET support multiple NPF instances,
+	// but we anyway don't plan using that support; might get kicked out completely
+	if (!LIST_EMPTY(&winfo->instances)) panic("Support for multiple NPF instances not implemented");
+
 	LIST_INSERT_HEAD(&winfo->instances, npf, worker_entry);
 	npf->worker_flags |= WFLAG_ACTIVE;
-	mutex_exit(&winfo->lock);
+	npfk_mutex_exit(&winfo->lock);
 }
 
 /*
- * npf_worker_discharge: remove the NPF instance the list for workers.
+ * npf_worker_discharge: remove the NPF instance the list for worker.
  *
  * => May block waiting for a worker to finish processing the instance.
  */
@@ -195,23 +211,23 @@ npf_worker_discharge(npf_t *npf)
 	/*
 	 * Notify the worker(s) that we are removing this instance.
 	 */
-	mutex_enter(&winfo->lock);
+	npfk_mutex_enter(&winfo->lock);
 	KASSERT(npf->worker_flags & WFLAG_ACTIVE);
 	npf->worker_flags |= WFLAG_REMOVE;
-	cv_broadcast(&winfo->cv);
+	//cv_broadcast(&winfo->cv);
 
 	/* Wait for a worker to process this request. */
 	while (npf->worker_flags & WFLAG_ACTIVE) {
 		cv_wait(&winfo->exit_cv, &winfo->lock);
 	}
-	mutex_exit(&winfo->lock);
+	npfk_mutex_exit(&winfo->lock);
 	KASSERT(npf->worker_flags == 0);
 }
 
 static void
 remove_npf_instance(npf_workerinfo_t *winfo, npf_t *npf)
 {
-	KASSERT(mutex_owned(&winfo->lock));
+	KASSERT(npfk_mutex_owned(&winfo->lock));
 	KASSERT(npf->worker_flags & WFLAG_ACTIVE);
 	KASSERT(npf->worker_flags & WFLAG_REMOVE);
 
@@ -225,6 +241,7 @@ remove_npf_instance(npf_workerinfo_t *winfo, npf_t *npf)
 		npfk_thread_unregister(npf);
 	}
 	LIST_REMOVE(npf, worker_entry);
+	KASSERT(LIST_EMPTY(&winfo->instances)); // We currently only support 1 NPF instance
 	npf->worker_flags = 0;
 	cv_broadcast(&winfo->exit_cv);
 }
@@ -234,7 +251,7 @@ process_npf_instance(npf_workerinfo_t *winfo, npf_t *npf)
 {
 	npf_workfunc_t work;
 
-	KASSERT(mutex_owned(&winfo->lock));
+	KASSERT(npfk_mutex_owned(&winfo->lock));
 
 	if (npf->worker_flags & WFLAG_REMOVE) {
 		remove_npf_instance(winfo, npf);
@@ -257,47 +274,138 @@ process_npf_instance(npf_workerinfo_t *winfo, npf_t *npf)
 	return MAX(MIN(npf->worker_wait_time, NPF_GC_MAXWAIT), NPF_GC_MINWAIT);
 }
 
+wrk_ls_t *npfk_bind_npfworker(void) {
+	npf_workerinfo_t *winfo = worker_info;
+	if (winfo == NULL) return NULL;
+
+	struct tee_ta_session *s;
+	tee_ta_get_current_session(&s);
+	if (s == NULL) {
+		EMSG("Cannot bind sesson-less thread to NPF worker");
+		return NULL;
+	}
+
+	wrk_ls_t * ret = NULL;
+
+	// TODO: double locking ...
+	npfk_mutex_enter(&winfo->lock);
+	cpu_spin_lock(&winfo->bind.slock);
+
+	if(winfo->bind.status == WORKER_UNBOUND) {
+		winfo->bind.status = WORKER_IS_BOUND;
+		winfo->bind.sess_id = s->id;
+		ret = &winfo->worker_npf_data;
+	}
+
+	cpu_spin_unlock(&winfo->bind.slock);
+	npfk_mutex_exit(&winfo->lock);
+	return ret;
+}
+
+void npfk_unbind_npfworker(void) {
+	npf_workerinfo_t *winfo = worker_info;
+	if (winfo == NULL) return;
+
+	cpu_spin_lock(&winfo->bind.slock);
+	// TODO: check caller session id against bind.sess_id?
+	winfo->bind.status = WORKER_UNBOUND;
+	winfo->bind.sess_id = 0;
+	cpu_spin_unlock(&winfo->bind.slock);
+}
+
+bool npfk_is_bound_worker(void) {
+	npf_workerinfo_t *winfo = worker_info;
+	if (winfo == NULL) return false;
+
+	/* Check for session */
+	struct tee_ta_session *s;
+	tee_ta_get_current_session(&s);
+	if (s == NULL) {
+		EMSG("Can only run NPF worker from bound session");
+		return false;
+	}
+
+	/* Check for correct binding */
+	cpu_spin_lock(&winfo->bind.slock);
+	if (winfo->bind. status == WORKER_UNBOUND
+		|| winfo->bind.sess_id != s->id) {
+		EMSG("Session ID not matching ID bound to NPF worker");
+		cpu_spin_unlock(&winfo->bind.slock);
+		return false;
+	}
+	cpu_spin_unlock(&winfo->bind.slock);
+
+	return true;
+}
+
+unsigned int npfk_worker_iteration(void) {
+	npf_workerinfo_t *winfo = worker_info;
+	if (winfo == NULL) return -1;
+
+	unsigned wait_time = NPF_GC_MAXWAIT;
+	npfk_mutex_enter(&winfo->lock);
+
+	//  TODO: we only have 1, so could drop the list
+	// Iterate all instances.  We do not use LIST_FOREACH here,
+	// since the instance can be removed.
+	//
+	npf_t *npf = LIST_FIRST(&winfo->instances);
+	while (npf) {
+		npf_t *next = LIST_NEXT(npf, worker_entry);
+		unsigned i_wait_time = process_npf_instance(winfo, npf);
+		wait_time = MIN(wait_time, i_wait_time);
+		npf = next;
+	}
+
+	npfk_mutex_exit(&winfo->lock);
+	return wait_time;
+}
+
+
 /*
- * npf_worker: the main worker loop, processing enlisted NPF instances.
- *
- * XXX: Currently, npf_workerinfo_t::lock would serialize all workers,
- * so there is no point to have more than one worker; but there might
- * not be much point anyway.
+ * npf_run_npfworker: the main worker loop, processing enlisted NPF instances.
  */
-static void
-npf_worker(void *arg)
-{
-	npf_workerinfo_t *winfo = arg;
-	npf_t *npf;
-
-	mutex_enter(&winfo->lock);
-	while (!winfo->exit) {
-		unsigned wait_time = NPF_GC_MAXWAIT;
-
-		/*
-		 * Iterate all instances.  We do not use LIST_FOREACH here,
-		 * since the instance can be removed.
-		 */
-		npf = LIST_FIRST(&winfo->instances);
-		while (npf) {
-			npf_t *next = LIST_NEXT(npf, worker_entry);
-			unsigned i_wait_time = process_npf_instance(winfo, npf);
-			wait_time = MIN(wait_time, i_wait_time);
-			npf = next;
-		}
+void npfk_run_npfworker(void) {
+	DMSG("Called");
+	npf_workerinfo_t *winfo = worker_info;
+	if (winfo == NULL) {
+		EMSG("NPF worker not initialised");
+		return;
+	}
+
+	if (!npfk_is_bound_worker()) return;
+
+/* CAUTION: why has the mutex already taken before the binding check?
+//	mutex_enter(&winfo->lock);
+	cpu_spin_lock(&winfo->bind.slock);
+	if (winfo->bind. status == WORKER_UNBOUND
+		|| winfo->bind.sess_id != s->id) {
+		EMSG("Session ID not matching ID bound to NPF worker");
+		cpu_spin_unlock(&winfo->bind.slock);
+		goto worker_exit;
+	}
+	cpu_spin_unlock(&winfo->bind.slock);*/
+
+	// NPF Worker loop
+	for(int i=0; i<10; i++) {
+// TODO:	while (!winfo->exit) {
+
+		DMSG("i: %d", i);
+		unsigned wait_time = npfk_worker_iteration();
 
-		/*
-		 * Sleep and periodically wake up, unless we get notified.
-		 */
 		if (winfo->exit) {
+			DMSG("exit set");
 			break;
 		}
-		cv_timedwait(&winfo->cv, &winfo->lock, mstohz(wait_time));
+
+		// TODO: we currently have no cond_timedwait() in OPTEE
+		//cv_timedwait(&winfo->cv, &winfo->lock, mstohz(wait_time));
+
+		tee_time_wait(wait_time);
 	}
-	mutex_exit(&winfo->lock);
 
-	KASSERTMSG(LIST_EMPTY(&winfo->instances),
-	    "NPF instances must be discharged before the npfk_sysfini() call");
+//worker_exit:
+//	mutex_exit(&winfo->lock);
 
-	kthread_exit(0);
+	DMSG("Exit");
 }
diff --git a/src/kern/npfkern.h b/src/kern/npfkern.h
index f9b518e..bbe6ee6 100644
--- a/src/kern/npfkern.h
+++ b/src/kern/npfkern.h
@@ -27,18 +27,14 @@
 #ifndef _NPFKERN_H_
 #define _NPFKERN_H_
 
-#ifndef _KERNEL
 #include <stdbool.h>
 #include <inttypes.h>
-#endif
 
 struct mbuf;
 struct ifnet;
 
-#if defined(_NPF_STANDALONE) || !defined(__NetBSD__)
 #define PFIL_IN		0x00000001	// incoming packet
 #define PFIL_OUT	0x00000002	// outgoing packet
-#endif
 
 #define	NPF_NO_GC	0x01
 
@@ -63,9 +59,20 @@ typedef struct {
 	int		(*set_tag)(struct mbuf *, uint32_t);
 } npf_mbufops_t;
 
-int	npfk_sysinit(unsigned);
+int	npfk_sysinit(void);
 void	npfk_sysfini(void);
 
+// NPF cleanup worker
+struct worker_local_storage;
+typedef struct worker_local_storage wrk_ls_t;
+
+wrk_ls_t *npfk_bind_npfworker(void);
+void	npfk_run_npfworker(void); // if(npfk_is_bound_worker()) loop{ d = npfk_worker_iteration(); sleep(d); }
+bool    npfk_is_bound_worker(void);
+unsigned int npfk_worker_iteration(void);
+void	npfk_unbind_npfworker(void);
+//
+
 npf_t *	npfk_create(int, const npf_mbufops_t *, const npf_ifops_t *, void *);
 int	npfk_load(npf_t *, const void *, npf_error_t *);
 int	npfk_socket_load(npf_t *, int);
@@ -73,6 +80,7 @@ void	npfk_gc(npf_t *);
 void	npfk_destroy(npf_t *);
 void *	npfk_getarg(npf_t *);
 
+// Firewall worker processes
 void	npfk_thread_register(npf_t *);
 void	npfk_thread_unregister(npf_t *);
 
@@ -107,7 +115,5 @@ int	npf_ext_rndblock_fini(npf_t *);
 int	npf_alg_icmp_init(npf_t *);
 int	npf_alg_icmp_fini(npf_t *);
 
-int	npf_alg_pptp_init(npf_t *);
-int	npf_alg_pptp_fini(npf_t *);
 
 #endif
diff --git a/src/kern/stand/bpf_filter.c b/src/kern/stand/bpf_filter.c
index d2487a2..42c84dc 100644
--- a/src/kern/stand/bpf_filter.c
+++ b/src/kern/stand/bpf_filter.c
@@ -37,19 +37,8 @@
  */
 
 #include <sys/cdefs.h>
-#if 0
-__KERNEL_RCSID(0, "$NetBSD: bpf_filter.c,v 1.70 2015/02/11 12:53:15 alnsn Exp $");
 
-#if !(defined(lint) || defined(KERNEL))
-static const char rcsid[] =
-    "@(#) Header: bpf_filter.c,v 1.33 97/04/26 13:37:18 leres Exp  (LBL)";
-#endif
-
-#include <sys/param.h>
-#include <sys/time.h>
-#include <sys/kmem.h>
-#include <sys/endian.h>
-#endif
+#include <kernel/panic.h>
 
 #define	__BPF_PRIVATE
 #include <net/bpf.h>
@@ -57,12 +46,11 @@ static const char rcsid[] =
 /*
  * Provide the kernel API.
  */
-#include "npf_stand.h"
+#include "npf_optee.h"
 
 #define	BPF_COP_EXTMEM_RELEASE
 #include <bpfjit.h>
 
-#if defined(_KERNEL) || defined(_NPF_STANDALONE)
 
 bpf_ctx_t *
 bpf_create(void)
@@ -107,7 +95,6 @@ bpf_jit_freecode(bpfjit_func_t func)
 	bpfjit_free_code(func);
 }
 
-#endif
 
 #ifndef __NetBSD__
 static inline uint16_t
@@ -130,94 +117,7 @@ be32dec(const void *buf)
 #define EXTRACT_SHORT(p)	be16dec(p)
 #define EXTRACT_LONG(p)		be32dec(p)
 
-#ifdef _KERNEL
-#if 0
-#include <sys/mbuf.h>
-#endif
-#define MINDEX(len, m, k) 		\
-{					\
-	len = m->m_len; 		\
-	while (k >= (uint32_t)len) {	\
-		k -= len; 		\
-		m = m->m_next; 		\
-		if (m == 0) 		\
-			return 0; 	\
-		len = m->m_len; 	\
-	}				\
-}
-
-uint32_t m_xword(const struct mbuf *, uint32_t, int *);
-uint32_t m_xhalf(const struct mbuf *, uint32_t, int *);
-uint32_t m_xbyte(const struct mbuf *, uint32_t, int *);
-
-#define xword(p, k, err) m_xword((const struct mbuf *)(p), (k), (err))
-#define xhalf(p, k, err) m_xhalf((const struct mbuf *)(p), (k), (err))
-#define xbyte(p, k, err) m_xbyte((const struct mbuf *)(p), (k), (err))
-
-uint32_t
-m_xword(const struct mbuf *m, uint32_t k, int *err)
-{
-	int len;
-	u_char *cp, *np;
-	struct mbuf *m0;
-
-	*err = 1;
-	MINDEX(len, m, k);
-	cp = mtod(m, u_char *) + k;
-	if (len - k >= 4) {
-		*err = 0;
-		return EXTRACT_LONG(cp);
-	}
-	m0 = m->m_next;
-	if (m0 == 0 || (len - k) + m0->m_len < 4)
-		return 0;
-	*err = 0;
-	np = mtod(m0, u_char *);
-
-	switch (len - k) {
-	case 1:
-		return (cp[0] << 24) | (np[0] << 16) | (np[1] << 8) | np[2];
-	case 2:
-		return (cp[0] << 24) | (cp[1] << 16) | (np[0] << 8) | np[1];
-	default:
-		return (cp[0] << 24) | (cp[1] << 16) | (cp[2] << 8) | np[0];
-	}
-}
-
-uint32_t
-m_xhalf(const struct mbuf *m, uint32_t k, int *err)
-{
-	int len;
-	u_char *cp;
-	struct mbuf *m0;
-
-	*err = 1;
-	MINDEX(len, m, k);
-	cp = mtod(m, u_char *) + k;
-	if (len - k >= 2) {
-		*err = 0;
-		return EXTRACT_SHORT(cp);
-	}
-	m0 = m->m_next;
-	if (m0 == 0)
-		return 0;
-	*err = 0;
-	return (cp[0] << 8) | mtod(m0, u_char *)[0];
-}
-
-uint32_t
-m_xbyte(const struct mbuf *m, uint32_t k, int *err)
-{
-	int len;
-
-	*err = 1;
-	MINDEX(len, m, k);
-	*err = 0;
-	return mtod(m, u_char *)[k];
-}
-#else /* _KERNEL */
 #include <stdlib.h>
-#endif /* !_KERNEL */
 
 #include <net/bpf.h>
 
@@ -226,7 +126,6 @@ m_xbyte(const struct mbuf *m, uint32_t k, int *err)
  * wirelen is the length of the original packet
  * buflen is the amount of data present
  */
-#if defined(_KERNEL) || defined(_NPF_STANDALONE)
 
 u_int
 bpf_filter(const struct bpf_insn *pc, const u_char *p, u_int wirelen,
@@ -246,26 +145,9 @@ bpf_filter(const struct bpf_insn *pc, const u_char *p, u_int wirelen,
 
 u_int
 bpf_filter_ext(const bpf_ctx_t *bc, const struct bpf_insn *pc, bpf_args_t *args)
-#else
-u_int
-bpf_filter(const struct bpf_insn *pc, const u_char *p, u_int wirelen,
-    u_int buflen)
-#endif
 {
 	uint32_t A, X, k;
-#if !defined(_KERNEL) && !defined(_NPF_STANDALONE)
-	uint32_t mem[BPF_MEMWORDS];
-	bpf_args_t args_store = {
-		.pkt = p,
-		.wirelen = wirelen,
-		.buflen = buflen,
-		.mem = mem,
-		.arg = NULL
-	};
-	bpf_args_t * const args = &args_store;
-#else
 	const uint8_t * const p = args->pkt;
-#endif
 	if (pc == 0) {
 		/*
 		 * No filter means accept all.
@@ -286,12 +168,8 @@ bpf_filter(const struct bpf_insn *pc, const u_char *p, u_int wirelen,
 		switch (pc->code) {
 
 		default:
-#ifdef _KERNEL
-			return 0;
-#else
-			abort();
+			panic("BPF filter bug?");
 			/*NOTREACHED*/
-#endif
 		case BPF_RET|BPF_K:
 			return (u_int)pc->k;
 
@@ -302,18 +180,7 @@ bpf_filter(const struct bpf_insn *pc, const u_char *p, u_int wirelen,
 			k = pc->k;
 			if (k > args->buflen ||
 			    sizeof(int32_t) > args->buflen - k) {
-#ifdef _KERNEL
-				int merr;
-
-				if (args->buflen != 0)
-					return 0;
-				A = xword(args->pkt, k, &merr);
-				if (merr != 0)
-					return 0;
-				continue;
-#else
 				return 0;
-#endif
 			}
 			A = EXTRACT_LONG(&p[k]);
 			continue;
@@ -322,18 +189,7 @@ bpf_filter(const struct bpf_insn *pc, const u_char *p, u_int wirelen,
 			k = pc->k;
 			if (k > args->buflen ||
 			    sizeof(int16_t) > args->buflen - k) {
-#ifdef _KERNEL
-				int merr;
-
-				if (args->buflen != 0)
-					return 0;
-				A = xhalf(args->pkt, k, &merr);
-				if (merr != 0)
-					return 0;
-				continue;
-#else
 				return 0;
-#endif
 			}
 			A = EXTRACT_SHORT(&p[k]);
 			continue;
@@ -341,18 +197,7 @@ bpf_filter(const struct bpf_insn *pc, const u_char *p, u_int wirelen,
 		case BPF_LD|BPF_B|BPF_ABS:
 			k = pc->k;
 			if (k >= args->buflen) {
-#ifdef _KERNEL
-				int merr;
-
-				if (args->buflen != 0)
-					return 0;
-				A = xbyte(args->pkt, k, &merr);
-				if (merr != 0)
-					return 0;
-				continue;
-#else
 				return 0;
-#endif
 			}
 			A = p[k];
 			continue;
@@ -369,18 +214,7 @@ bpf_filter(const struct bpf_insn *pc, const u_char *p, u_int wirelen,
 			k = X + pc->k;
 			if (k < X || k >= args->buflen ||
 			    sizeof(int32_t) > args->buflen - k) {
-#ifdef _KERNEL
-				int merr;
-
-				if (k < X || args->buflen != 0)
-					return 0;
-				A = xword(args->pkt, k, &merr);
-				if (merr != 0)
-					return 0;
-				continue;
-#else
 				return 0;
-#endif
 			}
 			A = EXTRACT_LONG(&p[k]);
 			continue;
@@ -389,18 +223,7 @@ bpf_filter(const struct bpf_insn *pc, const u_char *p, u_int wirelen,
 			k = X + pc->k;
 			if (k < X || k >= args->buflen ||
 			    sizeof(int16_t) > args->buflen - k) {
-#ifdef _KERNEL
-				int merr;
-
-				if (k < X || args->buflen != 0)
-					return 0;
-				A = xhalf(args->pkt, k, &merr);
-				if (merr != 0)
-					return 0;
-				continue;
-#else
 				return 0;
-#endif
 			}
 			A = EXTRACT_SHORT(&p[k]);
 			continue;
@@ -408,18 +231,7 @@ bpf_filter(const struct bpf_insn *pc, const u_char *p, u_int wirelen,
 		case BPF_LD|BPF_B|BPF_IND:
 			k = X + pc->k;
 			if (k < X || k >= args->buflen) {
-#ifdef _KERNEL
-				int merr;
-
-				if (k < X || args->buflen != 0)
-					return 0;
-				A = xbyte(args->pkt, k, &merr);
-				if (merr != 0)
-					return 0;
-				continue;
-#else
 				return 0;
-#endif
 			}
 			A = p[k];
 			continue;
@@ -427,18 +239,7 @@ bpf_filter(const struct bpf_insn *pc, const u_char *p, u_int wirelen,
 		case BPF_LDX|BPF_MSH|BPF_B:
 			k = pc->k;
 			if (k >= args->buflen) {
-#ifdef _KERNEL
-				int merr;
-
-				if (args->buflen != 0)
-					return 0;
-				X = (xbyte(args->pkt, k, &merr) & 0xf) << 2;
-				if (merr != 0)
-					return 0;
-				continue;
-#else
 				return 0;
-#endif
 			}
 			X = (p[pc->k] & 0xf) << 2;
 			continue;
@@ -600,23 +401,19 @@ bpf_filter(const struct bpf_insn *pc, const u_char *p, u_int wirelen,
 			continue;
 
 		case BPF_MISC|BPF_COP:
-#if defined(_KERNEL) || defined(_NPF_STANDALONE)
 			if (pc->k < bc->nfuncs) {
 				const bpf_copfunc_t fn = bc->copfuncs[pc->k];
 				A = fn(bc, args, A);
 				continue;
 			}
-#endif
 			return 0;
 
 		case BPF_MISC|BPF_COPX:
-#if defined(_KERNEL) || defined(_NPF_STANDALONE)
 			if (X < bc->nfuncs) {
 				const bpf_copfunc_t fn = bc->copfuncs[X];
 				A = fn(bc, args, A);
 				continue;
 			}
-#endif
 			return 0;
 		}
 	}
@@ -634,7 +431,6 @@ bpf_filter(const struct bpf_insn *pc, const u_char *p, u_int wirelen,
  * Otherwise, a bogus program could easily crash the system.
  */
 
-#if defined(KERNEL) || defined(_KERNEL) || defined(_NPF_STANDALONE)
 
 int
 bpf_validate(const struct bpf_insn *f, int signed_len)
@@ -644,46 +440,32 @@ bpf_validate(const struct bpf_insn *f, int signed_len)
 
 int
 bpf_validate_ext(const bpf_ctx_t *bc, const struct bpf_insn *f, int signed_len)
-#else
-int
-bpf_validate(const struct bpf_insn *f, int signed_len)
-#endif
 {
 	u_int i, from, len, ok = 0;
 	const struct bpf_insn *p;
-#if defined(KERNEL) || defined(_KERNEL) || defined(_NPF_STANDALONE)
 	bpf_memword_init_t *mem, invalid;
 	size_t size;
 	const size_t extwords = bc ? bc->extwords : 0;
 	const size_t memwords = extwords ? extwords : BPF_MEMWORDS;
 	const bpf_memword_init_t preinited = extwords ? bc->preinited : 0;
-#else
-	const size_t memwords = BPF_MEMWORDS;
-#endif
 
 	len = (u_int)signed_len;
 	if (len < 1)
 		return 0;
-#if defined(KERNEL) || defined(_KERNEL) || defined(_NPF_STANDALONE)
 	if (len > BPF_MAXINSNS)
 		return 0;
-#endif
 	if (f[len - 1].code != (BPF_RET|BPF_K) &&
 	    f[len - 1].code != (BPF_RET|BPF_A)) {
 		return 0;
 	}
 
-#if defined(KERNEL) || defined(_KERNEL) || defined(_NPF_STANDALONE)
 	/* Note: only the pre-initialised is valid on startup */
 	mem = kmem_zalloc(size = sizeof(*mem) * len, KM_SLEEP);
 	invalid = ~preinited;
-#endif
 
 	for (i = 0; i < len; ++i) {
-#if defined(KERNEL) || defined(_KERNEL) || defined(_NPF_STANDALONE)
 		/* blend in any invalid bits for current pc */
 		invalid |= mem[i];
-#endif
 		p = &f[i];
 		switch (BPF_CLASS(p->code)) {
 		/*
@@ -698,7 +480,6 @@ bpf_validate(const struct bpf_insn *f, int signed_len)
 				 * in userland.  The runtime packet length
 				 * check suffices.
 				 */
-#if defined(KERNEL) || defined(_KERNEL) || defined(_NPF_STANDALONE)
 				/*
 				 * More strict check with actual packet length
 				 * is done runtime.
@@ -708,7 +489,6 @@ bpf_validate(const struct bpf_insn *f, int signed_len)
 				/* check for current memory invalid */
 				if (invalid & BPF_MEMWORD_INIT(p->k))
 					goto out;
-#endif
 				break;
 			case BPF_ABS:
 			case BPF_IND:
@@ -724,10 +504,8 @@ bpf_validate(const struct bpf_insn *f, int signed_len)
 		case BPF_STX:
 			if (p->k >= memwords)
 				goto out;
-#if defined(KERNEL) || defined(_KERNEL) || defined(_NPF_STANDALONE)
 			/* validate the memory word */
 			invalid &= ~BPF_MEMWORD_INIT(p->k);
-#endif
 			break;
 		case BPF_ALU:
 			switch (BPF_OP(p->code)) {
@@ -785,7 +563,6 @@ bpf_validate(const struct bpf_insn *f, int signed_len)
 			case BPF_JA:
 				if (from + p->k >= len)
 					goto out;
-#if defined(KERNEL) || defined(_KERNEL) || defined(_NPF_STANDALONE)
 				if (from + p->k < from)
 					goto out;
 				/*
@@ -794,7 +571,6 @@ bpf_validate(const struct bpf_insn *f, int signed_len)
 				 */
 				mem[from + p->k] |= invalid;
 				invalid = 0;
-#endif
 				break;
 			case BPF_JEQ:
 			case BPF_JGT:
@@ -802,7 +578,6 @@ bpf_validate(const struct bpf_insn *f, int signed_len)
 			case BPF_JSET:
 				if (from + p->jt >= len || from + p->jf >= len)
 					goto out;
-#if defined(KERNEL) || defined(_KERNEL) || defined(_NPF_STANDALONE)
 				/*
 				 * mark the currently invalid bits for both
 				 * possible jump destinations
@@ -810,7 +585,6 @@ bpf_validate(const struct bpf_insn *f, int signed_len)
 				mem[from + p->jt] |= invalid;
 				mem[from + p->jf] |= invalid;
 				invalid = 0;
-#endif
 				break;
 			default:
 				goto out;
@@ -823,7 +597,6 @@ bpf_validate(const struct bpf_insn *f, int signed_len)
 			case BPF_COP:
 			case BPF_COPX:
 				/* In-kernel COP use only. */
-#if defined(KERNEL) || defined(_KERNEL) || defined(_NPF_STANDALONE)
 				if (bc == NULL || bc->copfuncs == NULL)
 					goto out;
 				if (BPF_MISCOP(p->code) == BPF_COP &&
@@ -831,9 +604,6 @@ bpf_validate(const struct bpf_insn *f, int signed_len)
 					goto out;
 				}
 				break;
-#else
-				goto out;
-#endif
 			default:
 				break;
 			}
@@ -844,8 +614,6 @@ bpf_validate(const struct bpf_insn *f, int signed_len)
 	}
 	ok = 1;
 out:
-#if defined(KERNEL) || defined(_KERNEL) || defined(_NPF_STANDALONE)
 	kmem_free(mem, size);
-#endif
 	return ok;
 }
diff --git a/src/kern/stand/cext.h b/src/kern/stand/cext.h
index 37f25ff..b4962f1 100644
--- a/src/kern/stand/cext.h
+++ b/src/kern/stand/cext.h
@@ -46,10 +46,10 @@
 #include <assert.h>
 
 #ifndef __predict_true
-#define	__predict_true(x)	__builtin_expect((x) != 0, 1)
+#define	__predict_true(x)	__builtin_expect(!!(x), 1)
 #endif
 #ifndef __predict_false
-#define	__predict_false(x)	__builtin_expect((x) != 0, 0)
+#define	__predict_false(x)	__builtin_expect(!!(x), 0)
 #endif
 
 #ifndef __constructor
@@ -168,6 +168,9 @@
 /*
  * C11-style memory fences and atomic loads/stores.
  */
+#include <stdatomic.h>
+
+/*
 #ifndef atomic_thread_fence
 #define	memory_order_relaxed	__ATOMIC_RELAXED
 #define	memory_order_acquire	__ATOMIC_ACQUIRE
@@ -175,12 +178,14 @@
 #define	memory_order_seq_cst	__ATOMIC_SEQ_CST
 #define	atomic_thread_fence(m)	__atomic_thread_fence(m)
 #endif
+
 #ifndef atomic_store_explicit
 #define	atomic_store_explicit	__atomic_store_n
 #endif
 #ifndef atomic_load_explicit
 #define	atomic_load_explicit	__atomic_load_n
 #endif
+*/
 
 /*
  * Exponential back-off for the spinning paths.
diff --git a/src/kern/stand/ebr_wrappers.c b/src/kern/stand/ebr_wrappers.c
index 65a0bb6..ca84919 100644
--- a/src/kern/stand/ebr_wrappers.c
+++ b/src/kern/stand/ebr_wrappers.c
@@ -28,7 +28,7 @@
 #include <stdbool.h>
 #include <assert.h>
 
-#include <qsbr/ebr.h>
+#include <ebr.h>
 
 #include "../npf_impl.h"
 
diff --git a/src/kern/stand/murmurhash.c b/src/kern/stand/murmurhash.c
index a5b2312..fd41148 100644
--- a/src/kern/stand/murmurhash.c
+++ b/src/kern/stand/murmurhash.c
@@ -13,9 +13,9 @@
 
 #include <sys/cdefs.h>
 #include <sys/types.h>
-#include <endian.h>
+#include <newlib/endian.h>
 
-#include "npf_stand.h"
+#include "npf_optee.h"
 
 #ifndef ALIGNED_POINTER
 #define	ALIGNED_POINTER(p,t)	((((uintptr_t)(p)) & (sizeof(t) - 1)) == 0)
diff --git a/src/kern/stand/npf_optee.h b/src/kern/stand/npf_optee.h
new file mode 100644
index 0000000..1ecd3fc
--- /dev/null
+++ b/src/kern/stand/npf_optee.h
@@ -0,0 +1,507 @@
+/*-
+ * Copyright (c) 2015-2019 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _NPF_STAND_H_
+#define _NPF_STAND_H_
+
+/*
+ * This file contains wrappers of the kernel interfaces for the
+ * OP-TEE version of NPF.
+ */
+
+#include <newlib/sys/cdefs.h>
+#include <sys/queue.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stddef.h>
+#include <stdbool.h>
+#include <inttypes.h>
+#include <limits.h>
+#include <string.h>
+#include <time.h>
+#include <kernel/tee_time.h>
+#include <tee_api_types.h>
+#include <kernel/mutex.h>
+#include <assert.h>
+
+#include <kernel/panic.h>
+
+#include <newlib/string.h> // stpncpy
+
+#define	__FAVOR_BSD  // TODO: remove everywhere?!
+
+// BSD compatiblity
+typedef uint8_t	u_int8_t;
+typedef uint16_t	u_int16_t;
+typedef uint32_t	u_int32_t;
+typedef uint64_t	u_int64_t;
+typedef unsigned char u_char;
+typedef unsigned short u_short;
+typedef unsigned int u_int;
+
+#include <newlib/netinet/in.h>
+#include <newlib/netinet/ip.h>
+#include <newlib/netinet/udp.h>
+#include <newlib/netinet/tcp.h>
+#include <newlib/arpa/inet.h>
+#include <newlib/net/ethernet.h> // TODO: still empty
+
+#include <dnv.h>
+#include <nv.h>
+
+#include <crypto/crypto.h>
+static inline long int random(void) {
+	int32_t rndBuf;
+	crypto_rng_read(&rndBuf, sizeof(rndBuf));
+	return (uint32_t)abs(rndBuf);
+}
+
+#include <ebr.h>
+#include <thmap.h>
+#include <lpm.h>
+#include <cdbr.h>
+
+#include "cext.h"
+#include <bstgw/worker_storage.h>
+
+typedef unsigned char u_char;
+typedef unsigned short u_short;
+typedef unsigned int u_int;
+#include "bpf.h" // note: this is the one from stand/, not from stand/net/
+
+/*
+ * Magic values for diagnostic assertions.
+ */
+
+#define	NPF_DIAG_MAGIC_VAL	(0x5a5a5a5a)
+
+/*
+ * Name/value pair library wrappers.
+ */
+
+static inline int
+npfkern_nvlist_xfer_ioctl(int fd, unsigned long cmd,
+    const nvlist_t *nvl, nvlist_t **nvlp)
+{
+	(void)fd; (void)cmd; (void)nvl; (void)nvlp;
+//	errno = ENOTSUP;
+	return -1;
+}
+
+static inline int
+npfkern_nvlist_copy(const void *a, const void *b, size_t c)
+{
+	(void)a; (void)b; (void)c;
+	return ENOTSUP; // TODO: shouldn't that return a negative number?!
+}
+
+#define	nvlist_xfer_ioctl(a,b,c,d)	npfkern_nvlist_xfer_ioctl(a,b,c,d)
+#define	nvlist_send_ioctl(a,b,c)	npfkern_nvlist_xfer_ioctl(a,b,c,NULL)
+#define	nvlist_recv_ioctl(a,b,d)	npfkern_nvlist_xfer_ioctl(a,b,NULL,d)
+#define	nvlist_copyin(a,b,c)		npfkern_nvlist_copy(a,b,c)
+#define	nvlist_copyout(a,b)		npfkern_nvlist_copy(a,b,0)
+
+/*
+ * Synchronisation primitives (mutex, condvar, etc).
+ */
+
+// Note: other mutex functions had name collisions with OPTEE variants, so we had to rewrite
+
+// our wrapper ! (to keep it unified with npf libs)
+#include <pthwrap.h>
+
+#define	npfk_kmutex_t			pthread_mutex_t
+#define npfk_mutex_init(l)		pthread_mutex_init(l, NULL)
+#define	npfk_mutex_enter(l)		pthread_mutex_lock(l)
+#define	npfk_mutex_exit(l)		pthread_mutex_unlock(l)
+#define	npfk_mutex_owned(l)		((uintptr_t)(l) != (uintptr_t)0)
+#define npfk_mutex_destroy(l)	pthread_mutex_destroy(l)
+
+#define	kcondvar_t		    struct condvar
+#define	cv_init(c, w)		condvar_init(c)
+#define	cv_broadcast(c)		condvar_broadcast(c)
+#define	cv_wait(c, m)		condvar_wait(c, m)
+#define	cv_signal(c)		condvar_signal(c)
+#define	cv_destroy(c)		condvar_destroy(c)
+
+/*
+ * Atomic operations and memory barriers.
+ */
+
+static inline void *
+npfkern_atomic_swap_ptr(volatile void *ptr, void *newval)
+{
+	/* Solaris/NetBSD API uses *ptr, but it represents **ptr. */
+	void * volatile *ptrp = (void * volatile *)ptr;
+	void *oldval;
+again:
+	oldval = *ptrp;
+	if (!__sync_bool_compare_and_swap(ptrp, oldval, newval)) {
+		goto again;
+	}
+	return oldval;
+}
+
+#define	membar_sync()		__sync_synchronize()
+#define	membar_consumer()	__sync_synchronize()
+#define	membar_producer()	__sync_synchronize()
+#define	atomic_inc_uint(x)	__sync_fetch_and_add((x), 1)
+#define	atomic_inc_uint_nv(x)	__sync_add_and_fetch((x), 1)
+#define	atomic_inc_ulong_nv(x)	__sync_add_and_fetch((x), 1)
+#define	atomic_dec_uint(x)	__sync_sub_and_fetch((x), 1)
+#define	atomic_dec_uint_nv(x)	__sync_sub_and_fetch((x), 1)
+#define	atomic_or_uint(x, v)	__sync_fetch_and_or((x), (v))
+#define	atomic_cas_32(p, o, n)	__sync_val_compare_and_swap((p), (o), (n))
+#define	atomic_cas_64(p, o, n)	__sync_val_compare_and_swap((p), (o), (n))
+#define	atomic_cas_ptr(p, o, n)	__sync_val_compare_and_swap((p), (o), (n))
+#define	atomic_swap_ptr(x, y)	npfkern_atomic_swap_ptr((x), (y))
+
+#define	atomic_load_relaxed(x)		\
+    atomic_load_explicit((x), memory_order_relaxed)
+#define	atomic_store_relaxed(x, y)	\
+    atomic_store_explicit((x), (y), memory_order_relaxed)
+
+#define	atomic_load_acquire(x)		\
+    atomic_load_explicit((x), memory_order_acquire)
+#define	atomic_store_release(x, y)	\
+    atomic_store_explicit((x), (y), memory_order_release)
+
+/*
+ * SPL wrappers.
+ */
+
+#define	splsoftnet()		0
+#define	splx(l)			(void)s;
+
+/*
+ * Memory allocators and management.
+ */
+
+#define	KM_SLEEP	0x00000001
+#define	KM_NOSLEEP	0x00000002
+#define	PR_WAITOK	KM_SLEEP
+#define PR_NOWAIT	KM_NOSLEEP
+
+#ifndef pool_cache_t
+typedef void *		pool_cache_t;
+#endif
+
+#define	pool_cache_init(size, align, a, b, c, d, p, e, f, g) (void *)(size)
+#define	pool_cache_destroy(p)		assert((size_t)(uintptr_t)(p) > 0)
+#define	pool_cache_get(p, flags)	malloc((size_t)(uintptr_t)(p))
+#define	pool_cache_put(p, obj)		free(obj)
+#define	pool_cache_invalidate(p)	(void)(p)
+
+static inline void
+npfkern_kmem_free(void *ptr, size_t len)
+{
+	(void)len;
+	free(ptr);
+}
+
+#define	kmem_zalloc(len, flags)		calloc(1, (len))
+#define	kmem_alloc(len, flags)		malloc(len)
+#define	kmem_free(ptr, len)		npfkern_kmem_free((ptr), (len))
+#define	kmem_intr_zalloc(len, flags)	kmem_zalloc((len), (flags))
+#define	kmem_intr_free(ptr, len)	kmem_free((ptr), (len))
+
+#define	kmalloc(size, type, flags)	calloc(1, (size))
+#define	kfree(ptr, type)		free(ptr)
+
+static inline int
+npfkern_copy(void *dst, const void *src, size_t len)
+{
+	memcpy(dst, src, len);
+	return 0;
+}
+
+#ifdef __linux__
+static inline size_t
+strlcpy(char *dst, const char *src, size_t len)
+{
+	(void)stpncpy(dst, src, len);
+	dst[len - 1] = '\0';
+	return strlen(src);
+}
+#endif
+
+#define	copyout(k, u, l)		npfkern_copy((u), (k), (l))
+#define	copyin(u, k, l)			npfkern_copy((k), (u), (l))
+#define	copyinstr(u, k, l, d)		\
+    ((strlcpy((k), (u), (l)) < (l)) ? 0 : ENAMETOOLONG)
+
+/*
+ * Per-CPU wrappers implemented using worker storage. (TODO)
+ */
+
+typedef struct npf_statistics_tls {
+	LIST_ENTRY(npf_statistics_tls)	entry;
+	bool			setup;
+    // important: works because malloc returns at least 8B-aligned pointers
+	__attribute__ ((aligned(8))) unsigned char		buf[];
+} npf_stats_tls;
+
+typedef struct {
+	size_t stats_size; // TODO: NPF_STATS_SIZE
+	npfk_kmutex_t		lock;
+	LIST_HEAD(, npf_statistics_tls)	list;
+} per_worker_stats_t;
+
+struct cpu_info;
+typedef void (*percpu_callback_t)(void *, void *, struct cpu_info *);
+
+static inline per_worker_stats_t *
+npfkern_per_worker_stats_alloc(size_t size)
+{
+	// TODO
+	assert(size == NPF_STATS_SIZE);
+	per_worker_stats_t *pc = zalloc(sizeof(per_worker_stats_t));
+	npfk_mutex_init(&pc->lock);
+	pc->stats_size = size;
+	return pc;
+}
+
+static inline void
+npfkern_per_worker_stats_free(per_worker_stats_t *pc, size_t size)
+{
+	npf_stats_tls *t, *next;
+
+	t = LIST_FIRST(&pc->list);
+	while (t) {
+		next = LIST_NEXT(t, entry);
+		ASSERT(t->setup);
+		set_worker_stats(NULL);
+		free(t);
+		t = next;
+	}
+
+	npfk_mutex_destroy(&pc->lock);
+	free(pc); (void)size;
+}
+
+static inline void *
+npfkern_per_worker_stats_getref(per_worker_stats_t *pc)
+{
+	npf_stats_tls *t;
+
+	t = get_worker_stats();
+	if (__predict_false(t == NULL)) {
+		t = calloc(1, pc->stats_size);
+		if (t == NULL) return NULL;
+		set_worker_stats(t); // new
+	}
+
+	if (__predict_false(!t->setup)) {
+		npfk_mutex_enter(&pc->lock);
+		LIST_INSERT_HEAD(&pc->list, t, entry);
+		npfk_mutex_exit(&pc->lock);
+		t->setup = true;
+	}
+	return t->buf;
+}
+
+static inline void
+npfkern_per_worker_stats_foreach(per_worker_stats_t *pc, percpu_callback_t cb, void *arg)
+{
+	npf_stats_tls *t;
+
+	npfk_mutex_enter(&pc->lock);
+	LIST_FOREACH(t, &pc->list, entry) {
+		cb(t->buf, arg, NULL);
+	}
+	npfk_mutex_exit(&pc->lock);
+}
+
+#define	percpu_t			per_worker_stats_t
+#define	percpu_alloc(s)			npfkern_per_worker_stats_alloc(NPF_STATS_SIZE)
+#define	percpu_free(p, s)		npfkern_per_worker_stats_free((p), (s))
+#define	percpu_getref(p)		npfkern_per_worker_stats_getref(p)
+#define	percpu_putref(p)		assert(p)
+#define	percpu_foreach_xcall(p,i,f,a)	npfkern_per_worker_stats_foreach((p), (f), (a))
+#define	XC_HIGHPRI_IPL(x)		0
+
+/*
+ * Random number generator.
+ */
+
+#define	cprng_fast32()			((uint32_t)random())
+#define	ip_randomid(o,s)		((uint16_t)random())
+
+/*
+ * Hashing.
+ */
+
+uint32_t	murmurhash2(const void *, size_t, uint32_t);
+
+/*
+ * Time operations.
+ */
+
+/* TODO:  this is super slow if no secure clock is available!
+ *   if no secure clock is available, another way would be to add a simple
+ *   monotonic clock driven by BstGw's notifier;
+ *
+ * Dummy to check overhead:
+ *	static uint32_t counter = 0; // TODO: can overflow
+ *	static inline int getnanouptime(TEE_Time *ts) {
+ *		if (ts == NULL) return -1;
+ *		ts->millis = 0;
+ *		ts->seconds = ++counter;
+ *		return 0;
+ *  }
+ */
+
+static inline int getnanouptime(TEE_Time *ts) {
+	if (ts == NULL) return -1;
+	// TODO: check protection level / use trusted time source if available
+	if (tee_time_get_sys_time(ts) != TEE_SUCCESS) return -1;
+	return 0;
+}
+
+#undef	mstohz
+#define	mstohz(ms)		(ms)
+
+static inline int
+npfkern_kpause(const char *wmesg, bool intr, int timo, npfk_kmutex_t *mtx)
+{
+	(void)wmesg; (void)intr; (void)mtx;
+	// TODO: sample trusted monotonic clock
+	tee_time_wait(timo);
+	// TODO: sample; check (t_end - t_begin) >= timo
+	return 0;
+}
+
+#define	kpause(w, s, t, l)	npfkern_kpause(w, s, t, l)
+
+/*
+ * Networking.
+ */
+
+#ifndef IPV6_VERSION
+#define IPV6_VERSION	0x60
+#endif
+#ifndef IPV6_DEFHLIM
+#define IPV6_DEFHLIM	64
+#endif
+
+#define PFIL_ALL	(PFIL_IN|PFIL_OUT)
+#define PFIL_IFADDR	0x00000008
+#define PFIL_IFNET	0x00000010
+
+#ifndef PACKET_TAG_NPF
+#define	PACKET_TAG_NPF	10
+#endif
+
+#define	MAX_TCPOPTLEN	40
+
+#ifndef satosin
+#define	satosin(sa)	((struct sockaddr_in *)(sa))
+#endif
+
+#ifndef satosin6
+#define	satosin6(sa)	((struct sockaddr_in6 *)(sa))
+#endif
+
+/*
+ * FIXME/TODO: To be implemented ..
+ */
+struct ifnet;
+typedef struct ifnet ifnet_t;
+
+#define	IFNET_GLOBAL_LOCK()
+#define	IFNET_GLOBAL_UNLOCK()
+#define	IFNET_WRITER_FOREACH(ifp) for ((ifp) = NULL; (ifp);)
+#define	IFADDR_FOREACH(ifa, ifp) \
+    for ((ifa) = NULL, (ifp) = NULL; (ifa) || (ifp);)
+
+#ifndef	IFNAMSIZ
+#define	IFNAMSIZ	16
+#endif
+
+static inline int
+npfkern_ip_reass_packet(void *x)
+{
+	(void)x;
+	return ENOTSUP;
+}
+
+#define	ip_reass_packet(p)		npfkern_ip_reass_packet(p)
+#define	ip_output(m, a, b, c, d, e)	ENOTSUP
+#define	icmp_error(m, t, c, a, b)
+#define	in_cksum(m, len)	0
+
+#define	ip6_sprintf(a)		"[IPv6]"
+#define	ip_defttl		64
+#define	max_linkhdr		0
+
+/*
+ * Misc.
+ */
+
+#ifndef COHERENCY_UNIT
+#define	COHERENCY_UNIT		CACHE_LINE_SIZE
+#endif
+
+#define	__read_mostly
+#define	__cacheline_aligned
+#ifndef	__dead
+#define	__dead
+#endif
+
+#ifdef DEBUG
+#define	__diagused
+#else
+#define	__diagused		__unused
+#endif
+
+#define	KASSERT			assert
+#define	KASSERTMSG(e, m, ...)	assert(e)
+
+#define	KERNEL_LOCK(a, b)
+#define	KERNEL_UNLOCK_ONE(a)
+
+#define	MODULE(c, m, d)
+#define	module_autoload(n, c)	ENOTSUP
+
+#define	MODULE_CMD_INIT		1
+#define	MODULE_CMD_FINI		2
+#define	MODULE_CMD_AUTOLOAD	3
+#define	MODULE_CMD_AUTOUNLOAD	4
+
+typedef int modcmd_t;
+
+#ifndef EPROGMISMATCH
+#define	EPROGMISMATCH		ENOTSUP
+#endif
+
+struct cpu_info { unsigned id; };
+
+#define	_IOR(g,n,t)		((n) - 100)
+#define	_IOW(g,n,t)		((n) - 100)
+#define	_IOWR(g,n,t)		((n) - 100)
+
+#endif
diff --git a/src/kern/stand/npf_stand.h b/src/kern/stand/npf_stand.h
index 84331cb..704c0e8 100644
--- a/src/kern/stand/npf_stand.h
+++ b/src/kern/stand/npf_stand.h
@@ -106,12 +106,13 @@ npfkern_nvlist_copy(const void *a, const void *b, size_t c)
  * Synchronisation primitives (mutex, condvar, etc).
  */
 
-#define	kmutex_t		pthread_mutex_t
-#define	mutex_init(l, t, i)	pthread_mutex_init(l, NULL)
-#define	mutex_enter(l)		pthread_mutex_lock(l)
-#define	mutex_exit(l)		pthread_mutex_unlock(l)
-#define	mutex_owned(l)		((uintptr_t)(l) != (uintptr_t)0)
-#define	mutex_destroy(l)	pthread_mutex_destroy(l)
+#define	npfk_kmutex_t		pthread_mutex_t
+//#define	npfk_mutex_init(l, t, i)	pthread_mutex_init(l, NULL)
+#define	npfk_mutex_init(l)	pthread_mutex_init(l, NULL)
+#define	npfk_mutex_enter(l)		pthread_mutex_lock(l)
+#define	npfk_mutex_exit(l)		pthread_mutex_unlock(l)
+#define	npfk_mutex_owned(l)		((uintptr_t)(l) != (uintptr_t)0)
+#define	npfk_mutex_destroy(l)	pthread_mutex_destroy(l)
 
 static inline int
 npfkern_pthread_cond_timedwait(pthread_cond_t *t, pthread_mutex_t *l,
@@ -366,7 +367,7 @@ uint32_t	murmurhash2(const void *, size_t, uint32_t);
 #define	mstohz(ms)		(ms)
 
 static inline int
-npfkern_kpause(const char *wmesg, bool intr, int timo, kmutex_t *mtx)
+npfkern_kpause(const char *wmesg, bool intr, int timo, npfk_kmutex_t *mtx)
 {
 	const struct timespec req = {
 		.tv_sec = timo / 1000,
diff --git a/src/kern/stand/npf_tzr_stand.h b/src/kern/stand/npf_tzr_stand.h
new file mode 100644
index 0000000..704c0e8
--- /dev/null
+++ b/src/kern/stand/npf_tzr_stand.h
@@ -0,0 +1,490 @@
+/*-
+ * Copyright (c) 2015-2019 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _NPF_STAND_H_
+#define _NPF_STAND_H_
+
+/*
+ * This file contains wrappers of the kernel interfaces for the
+ * standalone version of NPF.  These wrappers use intended to be
+ * portable, using the standard C99 or POSIX interfaces.
+ */
+
+#include <sys/cdefs.h>
+#include <sys/queue.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stddef.h>
+#include <stdbool.h>
+#include <inttypes.h>
+#include <limits.h>
+#include <string.h>
+#include <time.h>
+#include <pthread.h>
+#include <errno.h>
+#include <assert.h>
+
+#define	__FAVOR_BSD
+#include <netinet/in.h>
+#include <netinet/ip.h>
+#include <netinet/udp.h>
+#include <netinet/tcp.h>
+#include <arpa/inet.h>
+#if defined(__linux__)
+#include <net/ethernet.h>
+#endif
+
+#include <dnv.h>
+#include <nv.h>
+
+#include <qsbr/ebr.h>
+#include <thmap.h>
+#include <lpm.h>
+#include <cdbr.h>
+
+#include "cext.h"
+#include "tls.h"
+#include "bpf.h"
+
+/*
+ * Magic values for diagnostic assertions.
+ */
+
+#define	NPF_DIAG_MAGIC_VAL	(0x5a5a5a5a)
+
+/*
+ * Name/value pair library wrappers.
+ */
+
+static inline int
+npfkern_nvlist_xfer_ioctl(int fd, unsigned long cmd,
+    const nvlist_t *nvl, nvlist_t **nvlp)
+{
+	(void)fd; (void)cmd; (void)nvl; (void)nvlp;
+	errno = ENOTSUP;
+	return -1;
+}
+
+static inline int
+npfkern_nvlist_copy(const void *a, const void *b, size_t c)
+{
+	(void)a; (void)b; (void)c;
+	return ENOTSUP;
+}
+
+#define	nvlist_xfer_ioctl(a,b,c,d)	npfkern_nvlist_xfer_ioctl(a,b,c,d)
+#define	nvlist_send_ioctl(a,b,c)	npfkern_nvlist_xfer_ioctl(a,b,c,NULL)
+#define	nvlist_recv_ioctl(a,b,d)	npfkern_nvlist_xfer_ioctl(a,b,NULL,d)
+#define	nvlist_copyin(a,b,c)		npfkern_nvlist_copy(a,b,c)
+#define	nvlist_copyout(a,b)		npfkern_nvlist_copy(a,b,0)
+
+/*
+ * Synchronisation primitives (mutex, condvar, etc).
+ */
+
+#define	npfk_kmutex_t		pthread_mutex_t
+//#define	npfk_mutex_init(l, t, i)	pthread_mutex_init(l, NULL)
+#define	npfk_mutex_init(l)	pthread_mutex_init(l, NULL)
+#define	npfk_mutex_enter(l)		pthread_mutex_lock(l)
+#define	npfk_mutex_exit(l)		pthread_mutex_unlock(l)
+#define	npfk_mutex_owned(l)		((uintptr_t)(l) != (uintptr_t)0)
+#define	npfk_mutex_destroy(l)	pthread_mutex_destroy(l)
+
+static inline int
+npfkern_pthread_cond_timedwait(pthread_cond_t *t, pthread_mutex_t *l,
+    const unsigned msec)
+{
+	const unsigned sec = msec / 1000;
+	struct timespec ts;
+
+	clock_gettime(CLOCK_MONOTONIC, &ts);
+	ts.tv_sec += sec;
+	ts.tv_nsec = (msec - (sec * 1000)) * 1000000;
+	return pthread_cond_timedwait(t, l, &ts);
+}
+
+#define	kcondvar_t		pthread_cond_t
+#define	cv_init(c, w)		pthread_cond_init(c, NULL)
+#define	cv_broadcast(c)		pthread_cond_broadcast(c)
+#define	cv_wait(c, l)		pthread_cond_wait(c, l)
+#define	cv_timedwait(c, l, t)	npfkern_pthread_cond_timedwait(c, l, t)
+#define	cv_signal(c)		pthread_cond_signal(c)
+#define	cv_destroy(c)		pthread_cond_destroy(c)
+
+/*
+ * Atomic operations and memory barriers.
+ */
+
+static inline void *
+npfkern_atomic_swap_ptr(volatile void *ptr, void *newval)
+{
+	/* Solaris/NetBSD API uses *ptr, but it represents **ptr. */
+	void * volatile *ptrp = (void * volatile *)ptr;
+	void *oldval;
+again:
+	oldval = *ptrp;
+	if (!__sync_bool_compare_and_swap(ptrp, oldval, newval)) {
+		goto again;
+	}
+	return oldval;
+}
+
+#define	membar_sync()		__sync_synchronize()
+#define	membar_consumer()	__sync_synchronize()
+#define	membar_producer()	__sync_synchronize()
+#define	atomic_inc_uint(x)	__sync_fetch_and_add((x), 1)
+#define	atomic_inc_uint_nv(x)	__sync_add_and_fetch((x), 1)
+#define	atomic_inc_ulong_nv(x)	__sync_add_and_fetch((x), 1)
+#define	atomic_dec_uint(x)	__sync_sub_and_fetch((x), 1)
+#define	atomic_dec_uint_nv(x)	__sync_sub_and_fetch((x), 1)
+#define	atomic_or_uint(x, v)	__sync_fetch_and_or((x), (v))
+#define	atomic_cas_32(p, o, n)	__sync_val_compare_and_swap((p), (o), (n))
+#define	atomic_cas_64(p, o, n)	__sync_val_compare_and_swap((p), (o), (n))
+#define	atomic_cas_ptr(p, o, n)	__sync_val_compare_and_swap((p), (o), (n))
+#define	atomic_swap_ptr(x, y)	npfkern_atomic_swap_ptr((x), (y))
+
+#define	atomic_load_relaxed(x)		\
+    atomic_load_explicit((x), memory_order_relaxed)
+#define	atomic_store_relaxed(x, y)	\
+    atomic_store_explicit((x), (y), memory_order_relaxed)
+
+#define	atomic_load_acquire(x)		\
+    atomic_load_explicit((x), memory_order_acquire)
+#define	atomic_store_release(x, y)	\
+    atomic_store_explicit((x), (y), memory_order_release)
+
+/*
+ * Threads.
+ */
+
+typedef struct { pthread_t thr; } lwp_t;
+
+static inline int
+npfkern_pthread_create(lwp_t **lret, void (*func)(void *), void *arg)
+{
+	lwp_t *l;
+
+	if ((l = calloc(1, sizeof(lwp_t))) == NULL)
+		return ENOMEM;
+	*lret = l;
+	return pthread_create(&l->thr, NULL,
+	    (void *(*)(void *))(void *)func /* XXX */, arg);
+}
+
+#define	kthread_create(pri, flags, ci, func, arg, thr, fmt, ...) \
+    npfkern_pthread_create(thr, func, arg)
+#define	kthread_join(t)	{ void *__r; pthread_join((t)->thr, &__r); free(t); }
+#define	kthread_exit(x)	pthread_exit(NULL);
+
+/*
+ * SPL wrappers.
+ */
+
+#define	splsoftnet()		0
+#define	splx(l)			(void)s;
+
+/*
+ * Memory allocators and management.
+ */
+
+#define	KM_SLEEP	0x00000001
+#define	KM_NOSLEEP	0x00000002
+#define	PR_WAITOK	KM_SLEEP
+#define PR_NOWAIT	KM_NOSLEEP
+
+#ifndef pool_cache_t
+typedef void *		pool_cache_t;
+#endif
+
+#define	pool_cache_init(size, align, a, b, c, d, p, e, f, g) (void *)(size)
+#define	pool_cache_destroy(p)		assert((size_t)(uintptr_t)(p) > 0)
+#define	pool_cache_get(p, flags)	malloc((size_t)(uintptr_t)(p))
+#define	pool_cache_put(p, obj)		free(obj)
+#define	pool_cache_invalidate(p)	(void)(p)
+
+static inline void
+npfkern_kmem_free(void *ptr, size_t len)
+{
+	(void)len;
+	free(ptr);
+}
+
+#define	kmem_zalloc(len, flags)		calloc(1, (len))
+#define	kmem_alloc(len, flags)		malloc(len)
+#define	kmem_free(ptr, len)		npfkern_kmem_free((ptr), (len))
+#define	kmem_intr_zalloc(len, flags)	kmem_zalloc((len), (flags))
+#define	kmem_intr_free(ptr, len)	kmem_free((ptr), (len))
+
+#define	kmalloc(size, type, flags)	calloc(1, (size))
+#define	kfree(ptr, type)		free(ptr)
+
+static inline int
+npfkern_copy(void *dst, const void *src, size_t len)
+{
+	memcpy(dst, src, len);
+	return 0;
+}
+
+#ifdef __linux__
+static inline size_t
+strlcpy(char *dst, const char *src, size_t len)
+{
+	(void)stpncpy(dst, src, len);
+	dst[len - 1] = '\0';
+	return strlen(src);
+}
+#endif
+
+#define	copyout(k, u, l)		npfkern_copy((u), (k), (l))
+#define	copyin(u, k, l)			npfkern_copy((k), (u), (l))
+#define	copyinstr(u, k, l, d)		\
+    ((strlcpy((k), (u), (l)) < (l)) ? 0 : ENAMETOOLONG)
+
+/*
+ * Per-CPU wrappers implemented using TLS.
+ */
+
+typedef struct percpu_tls {
+	LIST_ENTRY(percpu_tls)	entry;
+	bool			setup;
+	unsigned char		buf[];
+} percpu_tls_t;
+
+typedef struct {
+	tls_key_t *		key;
+	pthread_mutex_t		lock;
+	LIST_HEAD(, percpu_tls)	list;
+} percpu_t;
+
+struct cpu_info;
+typedef void (*percpu_callback_t)(void *, void *, struct cpu_info *);
+
+static inline percpu_t *
+npfkern_percpu_alloc(size_t size)
+{
+	percpu_t *pc = zalloc(sizeof(percpu_t));
+	pthread_mutex_init(&pc->lock, NULL);
+	pc->key = tls_create(size);
+	return pc;
+}
+
+static inline void
+npfkern_percpu_free(percpu_t *pc, size_t size)
+{
+	percpu_tls_t *t, *next;
+
+	t = LIST_FIRST(&pc->list);
+	while (t) {
+		next = LIST_NEXT(t, entry);
+		ASSERT(t->setup);
+		free(t);
+		t = next;
+	}
+
+	tls_destroy(pc->key);
+	pthread_mutex_destroy(&pc->lock);
+	free(pc); (void)size;
+}
+
+static inline void *
+npfkern_percpu_getref(percpu_t *pc)
+{
+	percpu_tls_t *t;
+
+	t = tls_get(pc->key);
+	if (__predict_false(!t->setup)) {
+		pthread_mutex_lock(&pc->lock);
+		LIST_INSERT_HEAD(&pc->list, t, entry);
+		pthread_mutex_unlock(&pc->lock);
+		t->setup = true;
+	}
+	return t->buf;
+}
+
+static inline void
+npfkern_percpu_foreach(percpu_t *pc, percpu_callback_t cb, void *arg)
+{
+	percpu_tls_t *t;
+
+	pthread_mutex_lock(&pc->lock);
+	LIST_FOREACH(t, &pc->list, entry) {
+		cb(t->buf, arg, NULL);
+	}
+	pthread_mutex_unlock(&pc->lock);
+}
+
+#define	percpu_t			percpu_t
+#define	percpu_alloc(s)			npfkern_percpu_alloc(s)
+#define	percpu_free(p, s)		npfkern_percpu_free((p), (s))
+#define	percpu_getref(p)		npfkern_percpu_getref(p)
+#define	percpu_putref(p)		assert(p)
+#define	percpu_foreach_xcall(p,i,f,a)	npfkern_percpu_foreach((p), (f), (a))
+#define	XC_HIGHPRI_IPL(x)		0
+
+/*
+ * Random number generator.
+ */
+
+#define	cprng_fast32()			((uint32_t)random())
+#define	ip_randomid(o,s)		((uint16_t)random())
+
+/*
+ * Hashing.
+ */
+
+uint32_t	murmurhash2(const void *, size_t, uint32_t);
+
+/*
+ * Time operations.
+ */
+
+#define	getnanouptime(ts)	clock_gettime(CLOCK_MONOTONIC, (ts))
+#undef	mstohz
+#define	mstohz(ms)		(ms)
+
+static inline int
+npfkern_kpause(const char *wmesg, bool intr, int timo, npfk_kmutex_t *mtx)
+{
+	const struct timespec req = {
+		.tv_sec = timo / 1000,
+		.tv_nsec = (timo % 1000) * 1000000
+	};
+	(void)wmesg; (void)intr; (void)mtx;
+	return nanosleep(&req, NULL);
+}
+
+#define	kpause(w, s, t, l)	npfkern_kpause(w, s, t, l)
+
+/*
+ * Networking.
+ */
+
+#ifndef IPV6_VERSION
+#define IPV6_VERSION	0x60
+#endif
+#ifndef IPV6_DEFHLIM
+#define IPV6_DEFHLIM	64
+#endif
+
+#define PFIL_ALL	(PFIL_IN|PFIL_OUT)
+#define PFIL_IFADDR	0x00000008
+#define PFIL_IFNET	0x00000010
+
+#ifndef PACKET_TAG_NPF
+#define	PACKET_TAG_NPF	10
+#endif
+
+#define	MAX_TCPOPTLEN	40
+
+#ifndef satosin
+#define	satosin(sa)	((struct sockaddr_in *)(sa))
+#endif
+
+#ifndef satosin6
+#define	satosin6(sa)	((struct sockaddr_in6 *)(sa))
+#endif
+
+/*
+ * FIXME/TODO: To be implemented ..
+ */
+struct ifnet;
+typedef struct ifnet ifnet_t;
+
+#define	IFNET_GLOBAL_LOCK()
+#define	IFNET_GLOBAL_UNLOCK()
+#define	IFNET_WRITER_FOREACH(ifp) for ((ifp) = NULL; (ifp);)
+#define	IFADDR_FOREACH(ifa, ifp) \
+    for ((ifa) = NULL, (ifp) = NULL; (ifa) || (ifp);)
+
+#ifndef	IFNAMSIZ
+#define	IFNAMSIZ	16
+#endif
+
+static inline int
+npfkern_ip_reass_packet(void *x)
+{
+	(void)x;
+	return ENOTSUP;
+}
+
+#define	ip_reass_packet(p)		npfkern_ip_reass_packet(p)
+#define	ip_output(m, a, b, c, d, e)	ENOTSUP
+#define	icmp_error(m, t, c, a, b)
+#define	in_cksum(m, len)	0
+
+#define	ip6_sprintf(a)		"[IPv6]"
+#define	ip_defttl		64
+#define	max_linkhdr		0
+
+/*
+ * Misc.
+ */
+
+#ifndef COHERENCY_UNIT
+#define	COHERENCY_UNIT		CACHE_LINE_SIZE
+#endif
+
+#define	__read_mostly
+#define	__cacheline_aligned
+#ifndef	__dead
+#define	__dead
+#endif
+
+#ifdef DEBUG
+#define	__diagused
+#else
+#define	__diagused		__unused
+#endif
+
+#define	KASSERT			assert
+#define	KASSERTMSG(e, m, ...)	assert(e)
+#define	panic(x)		abort()
+
+#define	KERNEL_LOCK(a, b)
+#define	KERNEL_UNLOCK_ONE(a)
+
+#define	MODULE(c, m, d)
+#define	module_autoload(n, c)	ENOTSUP
+
+#define	MODULE_CMD_INIT		1
+#define	MODULE_CMD_FINI		2
+#define	MODULE_CMD_AUTOLOAD	3
+#define	MODULE_CMD_AUTOUNLOAD	4
+
+typedef int modcmd_t;
+
+#ifndef EPROGMISMATCH
+#define	EPROGMISMATCH		ENOTSUP
+#endif
+
+struct cpu_info { unsigned id; };
+
+#define	_IOR(g,n,t)		((n) - 100)
+#define	_IOW(g,n,t)		((n) - 100)
+#define	_IOWR(g,n,t)		((n) - 100)
+
+#endif
diff --git a/src/kern/stand/npf_tzr_trimmed_stand.h b/src/kern/stand/npf_tzr_trimmed_stand.h
new file mode 100644
index 0000000..1173d06
--- /dev/null
+++ b/src/kern/stand/npf_tzr_trimmed_stand.h
@@ -0,0 +1,352 @@
+/*-
+ * Copyright (c) 2015-2019 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _NPF_STAND_H_
+#define _NPF_STAND_H_
+
+/*
+ * This file contains wrappers of the kernel interfaces for the
+ * standalone version of NPF.  These wrappers use intended to be
+ * portable, using the standard C99 or POSIX interfaces.
+ */
+
+#include <sys/cdefs.h>
+#include <sys/queue.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stddef.h>
+#include <stdbool.h>
+#include <inttypes.h>
+#include <limits.h>
+#include <string.h>
+#include <time.h>
+#include <assert.h>
+
+#include <newlib/string.h> // stpncpy
+
+#define	__FAVOR_BSD
+#include <newlib/netinet/in.h>
+#include <newlib/netinet/ip.h>
+#include <newlib/netinet/udp.h>
+#include <newlib/netinet/tcp.h>
+#include <newlib/arpa/inet.h>
+#if defined(__linux__)
+#include <newlib/net/ethernet.h>
+#endif
+
+#include <dnv.h>
+#include <nv.h>
+
+#ifdef TZR_TA_OPTEE
+#include <tee_api.h>
+
+#define malloc(x) 		TEE_Malloc(x, TEE_MALLOC_FILL_ZERO)
+#define calloc(a, b) 	TEE_Malloc(a * b, TEE_MALLOC_FILL_ZERO)
+#define free(p) 		TEE_Free(p)
+
+long int random(void);
+long int random(void) {
+	int32_t rndBuf;
+	TEE_GenerateRandom(&rndBuf, sizeof(rndBuf));
+	return (uint32_t)abs(rndBuf);
+}
+#elif defined(TZR_PTA_OPTEE)
+#include <crypto/crypto.h>
+//void crypto_rng_read(void *, size_t);
+
+#define malloc(x) 		malloc(x)
+#define calloc(a, b) 	calloc(a, b)
+#define free(p) 		free(p)
+
+long int random(void);
+long int random(void) {
+	int32_t rndBuf;
+	crypto_rng_read(&rndBuf, sizeof(rndBuf));
+	return (uint32_t)abs(rndBuf);
+}
+#endif
+
+/*
+ * Magic values for diagnostic assertions.
+ */
+
+#define	NPF_DIAG_MAGIC_VAL	(0x5a5a5a5a)
+
+/*
+ * Name/value pair library wrappers.
+ */
+
+static inline int
+npfkern_nvlist_xfer_ioctl(int fd, unsigned long cmd,
+    const nvlist_t *nvl, nvlist_t **nvlp)
+{
+	(void)fd; (void)cmd; (void)nvl; (void)nvlp;
+	return -1;
+}
+
+static inline int
+npfkern_nvlist_copy(const void *a, const void *b, size_t c)
+{
+	(void)a; (void)b; (void)c;
+	return ENOTSUP;
+}
+
+#define	nvlist_xfer_ioctl(a,b,c,d)	npfkern_nvlist_xfer_ioctl(a,b,c,d)
+#define	nvlist_send_ioctl(a,b,c)	npfkern_nvlist_xfer_ioctl(a,b,c,NULL)
+#define	nvlist_recv_ioctl(a,b,d)	npfkern_nvlist_xfer_ioctl(a,b,NULL,d)
+#define	nvlist_copyin(a,b,c)		npfkern_nvlist_copy(a,b,c)
+#define	nvlist_copyout(a,b)		npfkern_nvlist_copy(a,b,0)
+
+/*
+ * Atomic operations and memory barriers.
+ */
+
+static inline void *
+npfkern_atomic_swap_ptr(volatile void *ptr, void *newval)
+{
+	/* Solaris/NetBSD API uses *ptr, but it represents **ptr. */
+	void * volatile *ptrp = (void * volatile *)ptr;
+	void *oldval;
+again:
+	oldval = *ptrp;
+	if (!__sync_bool_compare_and_swap(ptrp, oldval, newval)) {
+		goto again;
+	}
+	return oldval;
+}
+
+#define	membar_sync()		__sync_synchronize()
+#define	membar_consumer()	__sync_synchronize()
+#define	membar_producer()	__sync_synchronize()
+#define	atomic_inc_uint(x)	__sync_fetch_and_add((x), 1)
+#define	atomic_inc_uint_nv(x)	__sync_add_and_fetch((x), 1)
+#define	atomic_inc_ulong_nv(x)	__sync_add_and_fetch((x), 1)
+#define	atomic_dec_uint(x)	__sync_sub_and_fetch((x), 1)
+#define	atomic_dec_uint_nv(x)	__sync_sub_and_fetch((x), 1)
+#define	atomic_or_uint(x, v)	__sync_fetch_and_or((x), (v))
+#define	atomic_cas_32(p, o, n)	__sync_val_compare_and_swap((p), (o), (n))
+#define	atomic_cas_64(p, o, n)	__sync_val_compare_and_swap((p), (o), (n))
+#define	atomic_cas_ptr(p, o, n)	__sync_val_compare_and_swap((p), (o), (n))
+#define	atomic_swap_ptr(x, y)	npfkern_atomic_swap_ptr((x), (y))
+
+#define	atomic_load_relaxed(x)		\
+    atomic_load_explicit((x), memory_order_relaxed)
+#define	atomic_store_relaxed(x, y)	\
+    atomic_store_explicit((x), (y), memory_order_relaxed)
+
+#define	atomic_load_acquire(x)		\
+    atomic_load_explicit((x), memory_order_acquire)
+#define	atomic_store_release(x, y)	\
+    atomic_store_explicit((x), (y), memory_order_release)
+
+/*
+ * SPL wrappers.
+ */
+
+#define	splsoftnet()		0
+#define	splx(l)			(void)s;
+
+/*
+ * Memory allocators and management.
+ */
+
+#define	KM_SLEEP	0x00000001
+#define	KM_NOSLEEP	0x00000002
+#define	PR_WAITOK	KM_SLEEP
+#define PR_NOWAIT	KM_NOSLEEP
+
+#ifndef pool_cache_t
+typedef void *		pool_cache_t;
+#endif
+
+#define	pool_cache_init(size, align, a, b, c, d, p, e, f, g) (void *)(size)
+#define	pool_cache_destroy(p)		assert((size_t)(uintptr_t)(p) > 0)
+#define	pool_cache_get(p, flags)	malloc((size_t)(uintptr_t)(p))
+#define	pool_cache_put(p, obj)		free(obj)
+#define	pool_cache_invalidate(p)	(void)(p)
+
+static inline void
+npfkern_kmem_free(void *ptr, size_t len)
+{
+	(void)len;
+	free(ptr);
+}
+
+#define	kmem_zalloc(len, flags)		calloc(1, (len))
+#define	kmem_alloc(len, flags)		malloc(len)
+#define	kmem_free(ptr, len)		npfkern_kmem_free((ptr), (len))
+#define	kmem_intr_zalloc(len, flags)	kmem_zalloc((len), (flags))
+#define	kmem_intr_free(ptr, len)	kmem_free((ptr), (len))
+
+#define	kmalloc(size, type, flags)	calloc(1, (size))
+#define	kfree(ptr, type)		free(ptr)
+
+static inline int
+npfkern_copy(void *dst, const void *src, size_t len)
+{
+	memcpy(dst, src, len);
+	return 0;
+}
+
+#ifdef __linux__
+static inline size_t
+strlcpy(char *dst, const char *src, size_t len)
+{
+	(void)stpncpy(dst, src, len);
+	dst[len - 1] = '\0';
+	return strlen(src);
+}
+#endif
+
+#define	copyout(k, u, l)		npfkern_copy((u), (k), (l))
+#define	copyin(u, k, l)			npfkern_copy((k), (u), (l))
+#define	copyinstr(u, k, l, d)		\
+    ((strlcpy((k), (u), (l)) < (l)) ? 0 : ENAMETOOLONG)
+
+/*
+ * Random number generator.
+ */
+
+#define	cprng_fast32()			((uint32_t)random())
+#define	ip_randomid(o,s)		((uint16_t)random())
+
+/*
+ * Hashing.
+ */
+
+uint32_t	murmurhash2(const void *, size_t, uint32_t);
+
+
+/*
+ * Networking.
+ */
+
+#ifndef IPV6_VERSION
+#define IPV6_VERSION	0x60
+#endif
+#ifndef IPV6_DEFHLIM
+#define IPV6_DEFHLIM	64
+#endif
+
+#define PFIL_ALL	(PFIL_IN|PFIL_OUT)
+#define PFIL_IFADDR	0x00000008
+#define PFIL_IFNET	0x00000010
+
+#ifndef PACKET_TAG_NPF
+#define	PACKET_TAG_NPF	10
+#endif
+
+#define	MAX_TCPOPTLEN	40
+
+#ifndef satosin
+#define	satosin(sa)	((struct sockaddr_in *)(sa))
+#endif
+
+#ifndef satosin6
+#define	satosin6(sa)	((struct sockaddr_in6 *)(sa))
+#endif
+
+/*
+ * FIXME/TODO: To be implemented ..
+ */
+struct ifnet;
+typedef struct ifnet ifnet_t;
+
+#define	IFNET_GLOBAL_LOCK()
+#define	IFNET_GLOBAL_UNLOCK()
+#define	IFNET_WRITER_FOREACH(ifp) for ((ifp) = NULL; (ifp);)
+#define	IFADDR_FOREACH(ifa, ifp) \
+    for ((ifa) = NULL, (ifp) = NULL; (ifa) || (ifp);)
+
+#ifndef	IFNAMSIZ
+#define	IFNAMSIZ	16
+#endif
+
+static inline int
+npfkern_ip_reass_packet(void *x)
+{
+	(void)x;
+	return ENOTSUP;
+}
+
+#define	ip_reass_packet(p)		npfkern_ip_reass_packet(p)
+#define	ip_output(m, a, b, c, d, e)	ENOTSUP
+#define	icmp_error(m, t, c, a, b)
+#define	in_cksum(m, len)	0
+
+#define	ip6_sprintf(a)		"[IPv6]"
+#define	ip_defttl		64
+#define	max_linkhdr		0
+
+/*
+ * Misc.
+ */
+
+#ifndef COHERENCY_UNIT
+#define	COHERENCY_UNIT		CACHE_LINE_SIZE
+#endif
+
+#define	__read_mostly
+#define	__cacheline_aligned
+#ifndef	__dead
+#define	__dead
+#endif
+
+#ifdef DEBUG
+#define	__diagused
+#else
+#define	__diagused		__unused
+#endif
+
+#define	KASSERT			assert
+#define	KASSERTMSG(e, m, ...)	assert(e)
+#define	panic(x)		abort()
+
+#define	KERNEL_LOCK(a, b)
+#define	KERNEL_UNLOCK_ONE(a)
+
+#define	MODULE(c, m, d)
+#define	module_autoload(n, c)	ENOTSUP
+
+#define	MODULE_CMD_INIT		1
+#define	MODULE_CMD_FINI		2
+#define	MODULE_CMD_AUTOLOAD	3
+#define	MODULE_CMD_AUTOUNLOAD	4
+
+typedef int modcmd_t;
+
+#ifndef EPROGMISMATCH
+#define	EPROGMISMATCH		ENOTSUP
+#endif
+
+struct cpu_info { unsigned id; };
+
+#define	_IOR(g,n,t)		((n) - 100)
+#define	_IOW(g,n,t)		((n) - 100)
+#define	_IOWR(g,n,t)		((n) - 100)
+
+#endif
diff --git a/src/kern/stand/npfkern.c b/src/kern/stand/npfkern.c
index 614578c..efd54bf 100644
--- a/src/kern/stand/npfkern.c
+++ b/src/kern/stand/npfkern.c
@@ -44,6 +44,10 @@ struct npf;
 __dso_public int
 npfk_socket_load(npf_t *npf, int sock)
 {
+	// TODO: implement via PTA interface callable by the ConfigHub (P)TA
+	return -1;
+
+/*
 	nvlist_t *req, *resp;
 	uint64_t op;
 	int error;
@@ -60,6 +64,7 @@ npfk_socket_load(npf_t *npf, int sock)
 	error = nvlist_send(sock, resp);
 	nvlist_destroy(resp);
 	return error;
+ */
 }
 
 bool
diff --git a/src/libnpf/.gitignore b/src/libnpf/.gitignore
new file mode 100644
index 0000000..bd450ce
--- /dev/null
+++ b/src/libnpf/.gitignore
@@ -0,0 +1,4 @@
+.*.cmd
+.*.d
+*.a
+*.o
diff --git a/src/libnpf/Makefile b/src/libnpf/Makefile
index ef26ab6..516ab7e 100644
--- a/src/libnpf/Makefile
+++ b/src/libnpf/Makefile
@@ -13,7 +13,7 @@ CFLAGS+=	-D_NPF_STANDALONE
 #
 # Extended warning flags.
 #
-CFLAGS+=	-Wno-unknown-warning-option # gcc vs clang
+#CFLAGS+=	-Wno-unknown-warning-option # gcc vs clang
 
 CFLAGS+=	-Wstrict-prototypes -Wmissing-prototypes -Wpointer-arith
 CFLAGS+=	-Wmissing-declarations -Wredundant-decls -Wnested-externs
@@ -33,7 +33,7 @@ else
 CFLAGS+=	-DNDEBUG
 endif
 
-LDFLAGS=	-lnv -lcdb
+LDFLAGS+=	-lnv -lcdb
 
 #
 # Objects to compile
diff --git a/src/libnpf/TZRMakefile b/src/libnpf/TZRMakefile
new file mode 100644
index 0000000..6f383ce
--- /dev/null
+++ b/src/libnpf/TZRMakefile
@@ -0,0 +1,55 @@
+CFG_TEE_TA_LOG_LEVEL ?= 4
+CPPFLAGS += -DCFG_TEE_TA_LOG_LEVEL=$(CFG_TEE_TA_LOG_LEVEL)
+
+# separate tzr object files into separate directory
+O=tzr-build
+
+# libnpf specific stuff -----
+CFLAGS+=	-DTZR_OPTEE
+CPPFLAGS+=	-DTZR_OPTEE
+
+CFLAGS+=	-DTZR_TA_OPTEE
+CPPFLAGS+=	-DTZR_TA_OPTEE
+
+CFLAGS+=	-DTZR_NO_FD_APIS
+CPPFLAGS+=	-DTZR_NO_FD_APIS
+
+CFLAGS+=	-D__KERNEL_RCSID\(x,y\)=
+CPPFLAGS+=	-D__KERNEL_RCSID\(x,y\)=
+CFLAGS+=	-D_NPF_STANDALONE
+CPPFLAGS+=	-D_NPF_STANDALONE
+
+CFLAGS+=	-DNDEBUG
+CPPFLAGS+=	-DNDEBUG
+
+# TODO? (currently added to sub.mk)
+#LDFLAGS=	-lnv -lcdb
+
+##
+CFLAGS+=	-DENOENT=\(2\)
+CFLAGS+=	-DENOMEM=\(12\)
+CFLAGS+=	-DEEXIST=\(17\)
+CFLAGS+=	-DEINVAL=\(22\)
+CFLAGS +=	-DENOTSUP=\(122\)
+
+#INCS=		npf.h
+#OBJS=		npf.o
+
+## fixes -----
+### those are usually extern "C" { and }, but compiler complained about it
+CFLAGS+=	-D__BEGIN_DECLS=
+CFLAGS+=	-D__END_DECLS=
+
+## / -----
+# / -----
+
+# The name of the static library
+LIBNAME=$(O)/libnpf-tzr
+
+-include $(TA_DEV_KIT_DIR)/mk/ta_dev_kit.mk
+
+ifeq ($(wildcard $(TA_DEV_KIT_DIR)/mk/ta_dev_kit.mk), )
+clean:
+	@echo 'Note: $$(TA_DEV_KIT_DIR)/mk/ta_dev_kit.mk not found, cannot clean TA'
+	@echo 'Note: TA_DEV_KIT_DIR=$(TA_DEV_KIT_DIR)'
+endif
diff --git a/src/libnpf/external/INFO.md b/src/libnpf/external/INFO.md
new file mode 100644
index 0000000..27ec599
--- /dev/null
+++ b/src/libnpf/external/INFO.md
@@ -0,0 +1,7 @@
+## external includes
+
+taken from newlib (adapted):
+* endian.h
+* _endian.h
+* strings.h
+* strcasecmp.c
diff --git a/src/libnpf/external/include/newlib/_endian.h b/src/libnpf/external/include/newlib/_endian.h
new file mode 100644
index 0000000..3b3c0ed
--- /dev/null
+++ b/src/libnpf/external/include/newlib/_endian.h
@@ -0,0 +1,24 @@
+#ifndef __NEWLIB_MACHINE_ENDIAN_H__
+#error "must be included via <newlib/endian.h>"
+#endif /* !__NEWLIB_MACHINE_ENDIAN_H__ */
+
+#ifndef _LITTLE_ENDIAN
+#define	_LITTLE_ENDIAN	1234
+#endif
+
+#ifndef _BIG_ENDIAN
+#define	_BIG_ENDIAN	4321
+#endif
+
+#ifndef _PDP_ENDIAN
+#define	_PDP_ENDIAN	3412
+#endif
+
+#ifndef _BYTE_ORDER
+#if defined(__IEEE_BIG_ENDIAN) || defined(__IEEE_BYTES_BIG_ENDIAN)
+#define	_BYTE_ORDER	_BIG_ENDIAN
+#else
+#define	_BYTE_ORDER	_LITTLE_ENDIAN
+#endif
+
+#endif
diff --git a/src/libnpf/external/include/newlib/arpa/inet.h b/src/libnpf/external/include/newlib/arpa/inet.h
new file mode 100644
index 0000000..e69de29
diff --git a/src/libnpf/external/include/newlib/endian.h b/src/libnpf/external/include/newlib/endian.h
new file mode 100644
index 0000000..3d3407b
--- /dev/null
+++ b/src/libnpf/external/include/newlib/endian.h
@@ -0,0 +1,96 @@
+#ifndef __NEWLIB_MACHINE_ENDIAN_H__
+#define	__NEWLIB_MACHINE_ENDIAN_H__
+
+#include <newlib/_endian.h>
+
+#if _BYTE_ORDER == _LITTLE_ENDIAN
+#define	_QUAD_HIGHWORD	1
+#define	_QUAD_LOWWORD	0
+#else
+#define	_QUAD_HIGHWORD	0
+#define	_QUAD_LOWWORD	1
+#endif
+
+#define	LITTLE_ENDIAN	_LITTLE_ENDIAN
+#define	BIG_ENDIAN	_BIG_ENDIAN
+#define	PDP_ENDIAN	_PDP_ENDIAN
+#define	BYTE_ORDER	_BYTE_ORDER
+
+#ifdef __GNUC__
+#define	__bswap16(_x)	__builtin_bswap16(_x)
+#define	__bswap32(_x)	__builtin_bswap32(_x)
+#define	__bswap64(_x)	__builtin_bswap64(_x)
+#else /* __GNUC__ */
+static __inline __uint16_t
+__bswap16(__uint16_t _x)
+{
+
+	return ((__uint16_t)((_x >> 8) | ((_x << 8) & 0xff00)));
+}
+
+static __inline __uint32_t
+__bswap32(__uint32_t _x)
+{
+
+	return ((__uint32_t)((_x >> 24) | ((_x >> 8) & 0xff00) |
+	    ((_x << 8) & 0xff0000) | ((_x << 24) & 0xff000000)));
+}
+
+static __inline __uint64_t
+__bswap64(__uint64_t _x)
+{
+
+	return ((__uint64_t)((_x >> 56) | ((_x >> 40) & 0xff00) |
+	    ((_x >> 24) & 0xff0000) | ((_x >> 8) & 0xff000000) |
+	    ((_x << 8) & ((__uint64_t)0xff << 32)) |
+	    ((_x << 24) & ((__uint64_t)0xff << 40)) |
+	    ((_x << 40) & ((__uint64_t)0xff << 48)) | ((_x << 56))));
+}
+#endif /* !__GNUC__ */
+
+#if _BYTE_ORDER == _LITTLE_ENDIAN
+#define	htonl(_x)	__bswap32(_x)
+#define	htons(_x)	__bswap16(_x)
+#define	ntohl(_x)	__bswap32(_x)
+#define ntohs(_x)	__bswap16(_x)
+#else
+#define	htonl(_x)	((__uint32_t)(_x))
+#define	htons(_x)	((__uint16_t)(_x))
+#define	ntohl(_x)	((__uint32_t)(_x))
+#define ntohs(_x)	((__uint16_t)(_x))
+#endif
+
+#if _BYTE_ORDER == _LITTLE_ENDIAN
+#define htobe16(x) __bswap16 (x)
+#define htole16(x) (x)
+#define be16toh(x) __bswap16 (x)
+#define le16toh(x) (x)
+
+#define htobe32(x) __bswap32 (x)
+#define htole32(x) (x)
+#define be32toh(x) __bswap32 (x)
+#define le32toh(x) (x)
+
+#define htobe64(x) __bswap64 (x)
+#define htole64(x) (x)
+#define be64toh(x) __bswap64 (x)
+#define le64toh(x) (x)
+
+#else
+#define htobe16(x) (x)
+#define htole16(x) __bswap16 (x)
+#define be16toh(x) (x)
+#define le16toh(x) __bswap16 (x)
+
+#define htobe32(x) (x)
+#define htole32(x) __bswap32 (x)
+#define be32toh(x) (x)
+#define le32toh(x) __bswap32 (x)
+
+#define htobe64(x) (x)
+#define htole64(x) __bswap64 (x)
+#define be64toh(x) (x)
+#define le64toh(x) __bswap64 (x)
+#endif
+
+#endif /* __NEWLIB_MACHINE_ENDIAN_H__ */
diff --git a/src/libnpf/external/include/newlib/ifaddrs.h b/src/libnpf/external/include/newlib/ifaddrs.h
new file mode 100644
index 0000000..e69de29
diff --git a/src/libnpf/external/include/newlib/linux/sys/socket.h b/src/libnpf/external/include/newlib/linux/sys/socket.h
new file mode 100644
index 0000000..bcfe2a0
--- /dev/null
+++ b/src/libnpf/external/include/newlib/linux/sys/socket.h
@@ -0,0 +1,136 @@
+/*
+ * Copyright (c) 1982, 1985, 1986, 1988, 1993, 1994
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)socket.h	8.4 (Berkeley) 2/21/94
+ * $FreeBSD: src/sys/sys/socket.h,v 1.60 2002/04/20 02:24:35 mike Exp $
+ */
+
+#ifndef _NEWLIB_SYS_SOCKET_H_
+#define	_NEWLIB_SYS_SOCKET_H_
+
+#include <sys/types.h>
+#include <newlib/netinet/in.h>
+//#include <netdb.h>
+
+/* Needed by linuxthreads. */
+
+# define __SOCKADDR_ARG		struct sockaddr *__restrict
+# define __CONST_SOCKADDR_ARG	__const struct sockaddr *
+
+/* Protocol families.  */
+#define	PF_UNSPEC	0	/* Unspecified.  */
+#define	PF_LOCAL	1	/* Local to host (pipes and file-domain).  */
+#define	PF_UNIX		PF_LOCAL /* Old BSD name for PF_LOCAL.  */
+#define	PF_FILE		PF_LOCAL /* Another non-standard name for PF_LOCAL.  */
+#define	PF_INET		2	/* IP protocol family.  */
+#define	PF_AX25		3	/* Amateur Radio AX.25.  */
+#define	PF_IPX		4	/* Novell Internet Protocol.  */
+#define	PF_APPLETALK	5	/* Appletalk DDP.  */
+#define	PF_NETROM	6	/* Amateur radio NetROM.  */
+#define	PF_BRIDGE	7	/* Multiprotocol bridge.  */
+#define	PF_ATMPVC	8	/* ATM PVCs.  */
+#define	PF_X25		9	/* Reserved for X.25 project.  */
+#define	PF_INET6	10	/* IP version 6.  */
+#define	PF_ROSE		11	/* Amateur Radio X.25 PLP.  */
+#define	PF_DECnet	12	/* Reserved for DECnet project.  */
+#define	PF_NETBEUI	13	/* Reserved for 802.2LLC project.  */
+#define	PF_SECURITY	14	/* Security callback pseudo AF.  */
+#define	PF_KEY		15	/* PF_KEY key management API.  */
+#define	PF_NETLINK	16
+#define	PF_ROUTE	PF_NETLINK /* Alias to emulate 4.4BSD.  */
+#define	PF_PACKET	17	/* Packet family.  */
+#define	PF_ASH		18	/* Ash.  */
+#define	PF_ECONET	19	/* Acorn Econet.  */
+#define	PF_ATMSVC	20	/* ATM SVCs.  */
+#define	PF_SNA		22	/* Linux SNA Project */
+#define	PF_IRDA		23	/* IRDA sockets.  */
+#define	PF_PPPOX	24	/* PPPoX sockets.  */
+#define	PF_WANPIPE	25	/* Wanpipe API sockets.  */
+#define	PF_BLUETOOTH	31	/* Bluetooth sockets.  */
+#define	PF_MAX		32	/* For now..  */
+
+/* Address families.  */
+#define	AF_UNSPEC	PF_UNSPEC
+#define	AF_LOCAL	PF_LOCAL
+#define	AF_UNIX		PF_UNIX
+#define	AF_FILE		PF_FILE
+#define	AF_INET		PF_INET
+#define	AF_AX25		PF_AX25
+#define	AF_IPX		PF_IPX
+#define	AF_APPLETALK	PF_APPLETALK
+#define	AF_NETROM	PF_NETROM
+#define	AF_BRIDGE	PF_BRIDGE
+#define	AF_ATMPVC	PF_ATMPVC
+#define	AF_X25		PF_X25
+#define	AF_INET6	PF_INET6
+#define	AF_ROSE		PF_ROSE
+#define	AF_DECnet	PF_DECnet
+#define	AF_NETBEUI	PF_NETBEUI
+#define	AF_SECURITY	PF_SECURITY
+#define	AF_KEY		PF_KEY
+#define	AF_NETLINK	PF_NETLINK
+#define	AF_ROUTE	PF_ROUTE
+#define	AF_PACKET	PF_PACKET
+#define	AF_ASH		PF_ASH
+#define	AF_ECONET	PF_ECONET
+#define	AF_ATMSVC	PF_ATMSVC
+#define	AF_SNA		PF_SNA
+#define	AF_IRDA		PF_IRDA
+#define	AF_PPPOX	PF_PPPOX
+#define	AF_WANPIPE	PF_WANPIPE
+#define	AF_BLUETOOTH	PF_BLUETOOTH
+#define	AF_MAX		PF_MAX
+
+/*
+ * Structure used by kernel to store most
+ * addresses.
+ */
+struct sockaddr {
+	sa_family_t	sa_family;	/* address family */
+	char		sa_data[14];	/* actually longer; address value */
+};
+#define	SOCK_MAXADDRLEN	255		/* longest possible addresses */
+
+/*
+ * RFC 2553: protocol-independent placeholder for socket addresses
+ */
+#define	_SS_MAXSIZE	128U
+#define	_SS_ALIGNSIZE	(sizeof(int64_t))
+#define	_SS_PAD1SIZE	(_SS_ALIGNSIZE - sizeof(unsigned char) - sizeof(sa_family_t))
+#define	_SS_PAD2SIZE	(_SS_MAXSIZE - sizeof(unsigned char) - sizeof(sa_family_t) - \
+				_SS_PAD1SIZE - _SS_ALIGNSIZE)
+
+struct sockaddr_storage {
+	unsigned char		ss_len;		/* address length */
+	sa_family_t	ss_family;	/* address family */
+	char		__ss_pad1[_SS_PAD1SIZE];
+	int64_t		__ss_align;	/* force desired structure storage alignment */
+	char		__ss_pad2[_SS_PAD2SIZE];
+};
+
+#endif /* !_NEWLIB_SYS_SOCKET_H_ */
diff --git a/src/libnpf/external/include/newlib/net/ethernet.h b/src/libnpf/external/include/newlib/net/ethernet.h
new file mode 100644
index 0000000..e69de29
diff --git a/src/libnpf/external/include/newlib/net/if.h b/src/libnpf/external/include/newlib/net/if.h
new file mode 100644
index 0000000..e69de29
diff --git a/src/libnpf/external/include/newlib/netinet/icmp6.h b/src/libnpf/external/include/newlib/netinet/icmp6.h
new file mode 100644
index 0000000..e69de29
diff --git a/src/libnpf/external/include/newlib/netinet/in.h b/src/libnpf/external/include/newlib/netinet/in.h
new file mode 100644
index 0000000..e87c164
--- /dev/null
+++ b/src/libnpf/external/include/newlib/netinet/in.h
@@ -0,0 +1,88 @@
+/*
+ * Copyright (c) 1982, 1986, 1990, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)in.h	8.3 (Berkeley) 1/3/94
+ * $FreeBSD: src/sys/netinet/in.h,v 1.68 2002/04/24 01:26:11 mike Exp $
+ */
+
+#ifndef _NEWLIB_NETINET_IN_H_
+#define _NEWLIB_NETINET_IN_H_
+
+#include <sys/cdefs.h>
+//#include <sys/config.h>
+//#include <sys/_types.h>
+//#include <machine/endian.h>
+#include <newlib/endian.h>
+
+/* Protocols common to RFC 1700, POSIX, and X/Open. */
+#define	IPPROTO_IP		0		/* dummy for IP */
+#define	IPPROTO_ICMP		1		/* control message protocol */
+#define	IPPROTO_TCP		6		/* tcp */
+#define	IPPROTO_UDP		17		/* user datagram protocol */
+
+#define	INADDR_ANY		(u_int32_t)0x00000000
+#define	INADDR_BROADCAST	(u_int32_t)0xffffffff	/* must be masked */
+
+#ifndef _IN_ADDR_T_DECLARED
+typedef	uint32_t		in_addr_t;
+#define	_IN_ADDR_T_DECLARED
+#endif
+
+#ifndef _IN_PORT_T_DECLARED
+typedef	uint16_t		in_port_t;
+#define	_IN_PORT_T_DECLARED
+#endif
+
+typedef unsigned short sa_family_t;
+
+/* Internet address (a structure for historical reasons). */
+#ifndef	_STRUCT_IN_ADDR_DECLARED
+struct in_addr {
+	in_addr_t s_addr;
+};
+#define	_STRUCT_IN_ADDR_DECLARED
+#endif
+
+/* Socket address, internet style. */
+struct sockaddr_in {
+	sa_family_t	sin_family;
+	in_port_t	sin_port;
+	struct	in_addr sin_addr;
+	char	sin_zero[8];
+};
+
+//#if __POSIX_VISIBLE >= 200112
+#define	IPPROTO_RAW		255		/* raw IP packet */
+#define	INET_ADDRSTRLEN		16
+
+/* INET6 stuff */
+#define	__NEWLIB_KAME_NETINET_IN_H_INCLUDED_
+#include <newlib/netinet6/in6.h>
+#undef __NEWLIB_KAME_NETINET_IN_H_INCLUDED_
+
+#endif /* !_NEWLIB_NETINET_IN_H_*/
diff --git a/src/libnpf/external/include/newlib/netinet/ip.h b/src/libnpf/external/include/newlib/netinet/ip.h
new file mode 100644
index 0000000..e69de29
diff --git a/src/libnpf/external/include/newlib/netinet/ip6.h b/src/libnpf/external/include/newlib/netinet/ip6.h
new file mode 100644
index 0000000..e69de29
diff --git a/src/libnpf/external/include/newlib/netinet/ip_icmp.h b/src/libnpf/external/include/newlib/netinet/ip_icmp.h
new file mode 100644
index 0000000..e69de29
diff --git a/src/libnpf/external/include/newlib/netinet/tcp.h b/src/libnpf/external/include/newlib/netinet/tcp.h
new file mode 100644
index 0000000..e69de29
diff --git a/src/libnpf/external/include/newlib/netinet/udp.h b/src/libnpf/external/include/newlib/netinet/udp.h
new file mode 100644
index 0000000..e69de29
diff --git a/src/libnpf/external/include/newlib/netinet6/in6.h b/src/libnpf/external/include/newlib/netinet6/in6.h
new file mode 100644
index 0000000..082a7e2
--- /dev/null
+++ b/src/libnpf/external/include/newlib/netinet6/in6.h
@@ -0,0 +1,273 @@
+/*	$FreeBSD: src/sys/netinet6/in6.h,v 1.19 2002/04/19 04:46:22 suz Exp $	*/
+/*	$KAME: in6.h,v 1.89 2001/05/27 13:28:35 itojun Exp $	*/
+
+/*
+ * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/*
+ * Copyright (c) 1982, 1986, 1990, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)in.h	8.3 (Berkeley) 1/3/94
+ */
+
+#ifndef __NEWLIB_KAME_NETINET_IN_H_INCLUDED_
+#error "do not include netinet6/in6.h directly, include netinet/in.h.  see RFC2553"
+#endif
+
+#ifndef _NEWLIB_NETINET6_IN6_H_
+#define _NEWLIB_NETINET6_IN6_H_
+
+#include <sys/types.h>
+
+/*
+ * Identification of the network protocol stack
+ * for *BSD-current/release: http://www.kame.net/dev/cvsweb.cgi/kame/COVERAGE
+ * has the table of implementation/integration differences.
+ */
+#define __KAME__
+#define __KAME_VERSION		"20010528/FreeBSD"
+
+/*
+ * Local port number conventions:
+ *
+ * Ports < IPPORT_RESERVED are reserved for privileged processes (e.g. root),
+ * unless a kernel is compiled with IPNOPRIVPORTS defined.
+ *
+ * When a user does a bind(2) or connect(2) with a port number of zero,
+ * a non-conflicting local port address is chosen.
+ *
+ * The default range is IPPORT_ANONMIN to IPPORT_ANONMAX, although
+ * that is settable by sysctl(3); net.inet.ip.anonportmin and
+ * net.inet.ip.anonportmax respectively.
+ *
+ * A user may set the IPPROTO_IP option IP_PORTRANGE to change this
+ * default assignment range.
+ *
+ * The value IP_PORTRANGE_DEFAULT causes the default behavior.
+ *
+ * The value IP_PORTRANGE_HIGH is the same as IP_PORTRANGE_DEFAULT,
+ * and exists only for FreeBSD compatibility purposes.
+ *
+ * The value IP_PORTRANGE_LOW changes the range to the "low" are
+ * that is (by convention) restricted to privileged processes.
+ * This convention is based on "vouchsafe" principles only.
+ * It is only secure if you trust the remote host to restrict these ports.
+ * The range is IPPORT_RESERVEDMIN to IPPORT_RESERVEDMAX.
+ */
+
+#define	IPV6PORT_RESERVED	1024
+#define	IPV6PORT_ANONMIN	49152
+#define	IPV6PORT_ANONMAX	65535
+#define	IPV6PORT_RESERVEDMIN	600
+#define	IPV6PORT_RESERVEDMAX	(IPV6PORT_RESERVED-1)
+
+/*
+ * IPv6 address
+ */
+struct in6_addr {
+	union {
+		uint8_t   __u6_addr8[16];
+		uint16_t  __u6_addr16[8];
+		uint32_t  __u6_addr32[4];
+	} __u6_addr;			/* 128-bit IP6 address */
+};
+
+#define s6_addr   __u6_addr.__u6_addr8
+
+#define INET6_ADDRSTRLEN	46
+
+/*
+ * Socket address for IPv6
+ */
+#ifndef _XOPEN_SOURCE
+#define SIN6_LEN
+#endif
+struct sockaddr_in6 {
+	uint8_t	sin6_family;	/* AF_INET6 (sa_family_t) */
+	uint16_t	sin6_port;	/* Transport layer port # (in_port_t)*/
+	uint32_t	sin6_flowinfo;	/* IP6 flow information */
+	struct in6_addr	sin6_addr;	/* IP6 address */
+	uint32_t	sin6_scope_id;	/* scope zone index */
+};
+
+/*
+ * Macros started with IPV6_ADDR is KAME local
+ */
+#if BYTE_ORDER == LITTLE_ENDIAN
+#define IPV6_ADDR_INT32_ONE	0x01000000
+#define IPV6_ADDR_INT32_TWO	0x02000000
+#define IPV6_ADDR_INT32_MNL	0x000001ff
+#define IPV6_ADDR_INT32_MLL	0x000002ff
+#define IPV6_ADDR_INT32_SMP	0xffff0000
+#define IPV6_ADDR_INT16_ULL	0x80fe
+#define IPV6_ADDR_INT16_USL	0xc0fe
+#define IPV6_ADDR_INT16_MLL	0x02ff
+#endif
+
+/*
+ * Definition of some useful macros to handle IP6 addresses
+ */
+#define IN6ADDR_ANY_INIT \
+	{{{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
+	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }}}
+#define IN6ADDR_LOOPBACK_INIT \
+	{{{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
+	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 }}}
+#define IN6ADDR_NODELOCAL_ALLNODES_INIT \
+	{{{ 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
+	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 }}}
+#define IN6ADDR_LINKLOCAL_ALLNODES_INIT \
+	{{{ 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
+	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 }}}
+#define IN6ADDR_LINKLOCAL_ALLROUTERS_INIT \
+	{{{ 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
+	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02 }}}
+
+extern const struct in6_addr in6addr_any;
+extern const struct in6_addr in6addr_loopback;
+extern const struct in6_addr in6addr_nodelocal_allnodes;
+extern const struct in6_addr in6addr_linklocal_allnodes;
+extern const struct in6_addr in6addr_linklocal_allrouters;
+
+/*
+ * Equality
+ * NOTE: Some of kernel programming environment (for example, openbsd/sparc)
+ * does not supply memcmp().  For userland memcmp() is preferred as it is
+ * in ANSI standard.
+ */
+#define IN6_ARE_ADDR_EQUAL(a, b)			\
+    (memcmp(&(a)->s6_addr[0], &(b)->s6_addr[0], sizeof(struct in6_addr)) == 0)
+
+/*
+ * Unspecified
+ */
+#define IN6_IS_ADDR_UNSPECIFIED(a)	\
+	((*(const uint32_t *)(const void *)(&(a)->s6_addr[0]) == 0) &&	\
+	 (*(const uint32_t *)(const void *)(&(a)->s6_addr[4]) == 0) &&	\
+	 (*(const uint32_t *)(const void *)(&(a)->s6_addr[8]) == 0) &&	\
+	 (*(const uint32_t *)(const void *)(&(a)->s6_addr[12]) == 0))
+
+/*
+ * Loopback
+ */
+#define IN6_IS_ADDR_LOOPBACK(a)		\
+	((*(const uint32_t *)(const void *)(&(a)->s6_addr[0]) == 0) &&	\
+	 (*(const uint32_t *)(const void *)(&(a)->s6_addr[4]) == 0) &&	\
+	 (*(const uint32_t *)(const void *)(&(a)->s6_addr[8]) == 0) &&	\
+	 (*(const uint32_t *)(const void *)(&(a)->s6_addr[12]) == ntohl(1)))
+
+/*
+ * IPv4 compatible
+ */
+#define IN6_IS_ADDR_V4COMPAT(a)		\
+	((*(const uint32_t *)(const void *)(&(a)->s6_addr[0]) == 0) &&	\
+	 (*(const uint32_t *)(const void *)(&(a)->s6_addr[4]) == 0) &&	\
+	 (*(const uint32_t *)(const void *)(&(a)->s6_addr[8]) == 0) &&	\
+	 (*(const uint32_t *)(const void *)(&(a)->s6_addr[12]) != 0) &&	\
+	 (*(const uint32_t *)(const void *)(&(a)->s6_addr[12]) != ntohl(1)))
+
+/*
+ * Mapped
+ */
+#define IN6_IS_ADDR_V4MAPPED(a)		      \
+	((*(const uint32_t *)(const void *)(&(a)->s6_addr[0]) == 0) &&	\
+	 (*(const uint32_t *)(const void *)(&(a)->s6_addr[4]) == 0) &&	\
+	 (*(const uint32_t *)(const void *)(&(a)->s6_addr[8]) == ntohl(0x0000ffff)))
+
+/*
+ * KAME Scope Values
+ */
+
+#define __IPV6_ADDR_SCOPE_NODELOCAL	0x01
+#define __IPV6_ADDR_SCOPE_LINKLOCAL	0x02
+#define __IPV6_ADDR_SCOPE_SITELOCAL	0x05
+#define __IPV6_ADDR_SCOPE_ORGLOCAL	0x08	/* just used in this file */
+#define __IPV6_ADDR_SCOPE_GLOBAL	0x0e
+
+/*
+ * Unicast Scope
+ * Note that we must check topmost 10 bits only, not 16 bits (see RFC2373).
+ */
+#define IN6_IS_ADDR_LINKLOCAL(a)	\
+	(((a)->s6_addr[0] == 0xfe) && (((a)->s6_addr[1] & 0xc0) == 0x80))
+#define IN6_IS_ADDR_SITELOCAL(a)	\
+	(((a)->s6_addr[0] == 0xfe) && (((a)->s6_addr[1] & 0xc0) == 0xc0))
+
+/*
+ * Multicast
+ */
+#define IN6_IS_ADDR_MULTICAST(a)	((a)->s6_addr[0] == 0xff)
+
+#define __IPV6_ADDR_MC_SCOPE(a)		((a)->s6_addr[1] & 0x0f)
+
+/*
+ * Multicast Scope
+ */
+#define IN6_IS_ADDR_MC_NODELOCAL(a)	\
+	(IN6_IS_ADDR_MULTICAST(a) &&	\
+	 (__IPV6_ADDR_MC_SCOPE(a) == __IPV6_ADDR_SCOPE_NODELOCAL))
+#define IN6_IS_ADDR_MC_LINKLOCAL(a)	\
+	(IN6_IS_ADDR_MULTICAST(a) &&	\
+	 (__IPV6_ADDR_MC_SCOPE(a) == __IPV6_ADDR_SCOPE_LINKLOCAL))
+#define IN6_IS_ADDR_MC_SITELOCAL(a)	\
+	(IN6_IS_ADDR_MULTICAST(a) && 	\
+	 (__IPV6_ADDR_MC_SCOPE(a) == __IPV6_ADDR_SCOPE_SITELOCAL))
+#define IN6_IS_ADDR_MC_ORGLOCAL(a)	\
+	(IN6_IS_ADDR_MULTICAST(a) &&	\
+	 (__IPV6_ADDR_MC_SCOPE(a) == __IPV6_ADDR_SCOPE_ORGLOCAL))
+#define IN6_IS_ADDR_MC_GLOBAL(a)	\
+	(IN6_IS_ADDR_MULTICAST(a) &&	\
+	 (__IPV6_ADDR_MC_SCOPE(a) == __IPV6_ADDR_SCOPE_GLOBAL))
+
+#endif /* !_NEWLIB_NETINET6_IN6_H_ */
diff --git a/src/libnpf/external/include/newlib/string.h b/src/libnpf/external/include/newlib/string.h
new file mode 100644
index 0000000..e96f2de
--- /dev/null
+++ b/src/libnpf/external/include/newlib/string.h
@@ -0,0 +1,38 @@
+/*-
+ * Copyright (c) 2002 Mike Barcroft <mike@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD: head/include/strings.h 272673 2014-10-07 04:54:11Z delphij $
+ */
+
+#ifndef _NEWLIB_STRING_H_
+#define	_NEWLIB_STRING_H_
+
+#include <stddef.h>
+
+__BEGIN_DECLS
+char *stpncpy(char *dest, const char *src, size_t n);
+__END_DECLS
+
+#endif /* _NEWLIB_STRING_H_ */
diff --git a/src/libnpf/external/include/newlib/strings.h b/src/libnpf/external/include/newlib/strings.h
new file mode 100644
index 0000000..4f898bf
--- /dev/null
+++ b/src/libnpf/external/include/newlib/strings.h
@@ -0,0 +1,36 @@
+/*-
+ * Copyright (c) 2002 Mike Barcroft <mike@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD: head/include/strings.h 272673 2014-10-07 04:54:11Z delphij $
+ */
+
+#ifndef _NEWLIB_STRINGS_H_
+#define	_NEWLIB_STRINGS_H_
+
+__BEGIN_DECLS
+int	 strcasecmp(const char *s1, const char *s2);
+__END_DECLS
+
+#endif /* _NEWLIB_STRINGS_H_ */
diff --git a/src/libnpf/external/include/newlib/sys/cdefs.h b/src/libnpf/external/include/newlib/sys/cdefs.h
new file mode 100644
index 0000000..b8a8b64
--- /dev/null
+++ b/src/libnpf/external/include/newlib/sys/cdefs.h
@@ -0,0 +1,76 @@
+/* libc/sys/linux/sys/cdefs.h - Helper macros for K&R vs. ANSI C compat. */
+
+/* Written 2000 by Werner Almesberger */
+
+/*-
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ * Copyright (c) 1991, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * This code is derived from software contributed to Berkeley by
+ * Berkeley Software Design, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
+ * $FreeBSD$
+ */
+
+#ifndef	_NEWLIB_SYS_CDEFS_H_
+#define	_NEWLIB_SYS_CDEFS_H_
+
+/*
+ * GNU C version 2.96 adds explicit branch prediction so that
+ * the CPU back-end can hint the processor and also so that
+ * code blocks can be reordered such that the predicted path
+ * sees a more linear flow, thus improving cache behavior, etc.
+ *
+ * The following two macros provide us with a way to utilize this
+ * compiler feature.  Use __predict_true() if you expect the expression
+ * to evaluate to true, and __predict_false() if you expect the
+ * expression to evaluate to false.
+ *
+ * A few notes about usage:
+ *
+ *	* Generally, __predict_false() error condition checks (unless
+ *	  you have some _strong_ reason to do otherwise, in which case
+ *	  document it), and/or __predict_true() `no-error' condition
+ *	  checks, assuming you want to optimize for the no-error case.
+ *
+ *	* Other than that, if you don't know the likelihood of a test
+ *	  succeeding from empirical or other `hard' evidence, don't
+ *	  make predictions.
+ *
+ *	* These are meant to be used in places that are run `a lot'.
+ *	  It is wasteful to make predictions in code that is run
+ *	  seldomly (e.g. at subsystem initialization time) as the
+ *	  basic block reordering that this affects can often generate
+ *	  larger code.
+ */
+#define	__predict_true(exp)     __builtin_expect((exp), 1)
+#define	__predict_false(exp)    __builtin_expect((exp), 0)
+
+#endif /* !_NEWLIB_SYS_CDEFS_H_ */
diff --git a/src/libnpf/external/include/pcap/bpf.h b/src/libnpf/external/include/pcap/bpf.h
new file mode 100644
index 0000000..eef9baa
--- /dev/null
+++ b/src/libnpf/external/include/pcap/bpf.h
@@ -0,0 +1,10 @@
+#ifndef __DUMMY_PCAP_BPF_H__
+#define	__DUMMY_PCAP_BPF_H__
+typedef u_int bpf_u_int32;
+struct bpf_insn {
+    u_short code;
+    u_char  jt;
+    u_char  jf;
+    bpf_u_int32 k;
+};
+#endif /* __DUMMY_PCAP_BPF_H__ */
diff --git a/src/libnpf/external/src/newlib/stpncpy.c b/src/libnpf/external/src/newlib/stpncpy.c
new file mode 100644
index 0000000..5a461d7
--- /dev/null
+++ b/src/libnpf/external/src/newlib/stpncpy.c
@@ -0,0 +1,107 @@
+/*
+FUNCTION
+	<<stpncpy>>---counted copy string returning a pointer to its end
+
+INDEX
+	stpncpy
+
+SYNOPSIS
+	#include <string.h>
+	char *stpncpy(char *restrict <[dst]>, const char *restrict <[src]>,
+                      size_t <[length]>);
+
+DESCRIPTION
+	<<stpncpy>> copies not more than <[length]> characters from the
+	the string pointed to by <[src]> (including the terminating
+	null character) to the array pointed to by <[dst]>.  If the
+	string pointed to by <[src]> is shorter than <[length]>
+	characters, null characters are appended to the destination
+	array until a total of <[length]> characters have been
+	written.
+
+RETURNS
+	This function returns a pointer to the end of the destination string,
+	thus pointing to the trailing '\0', or, if the destination string is
+	not null-terminated, pointing to dst + n.
+
+PORTABILITY
+<<stpncpy>> is a GNU extension, candidate for inclusion into POSIX/SUSv4.
+
+<<stpncpy>> requires no supporting OS subroutines.
+
+QUICKREF
+	stpncpy gnu
+*/
+
+#include <newlib/string.h>
+#include <limits.h>
+
+/*SUPPRESS 560*/
+/*SUPPRESS 530*/
+
+/* Nonzero if either X or Y is not aligned on a "long" boundary.  */
+#define UNALIGNED(X, Y) \
+  (((long)X & (sizeof (long) - 1)) | ((long)Y & (sizeof (long) - 1)))
+
+#if LONG_MAX == 2147483647L
+#define DETECTNULL(X) (((X) - 0x01010101) & ~(X) & 0x80808080)
+#else
+#if LONG_MAX == 9223372036854775807L
+/* Nonzero if X (a long int) contains a NULL byte. */
+#define DETECTNULL(X) (((X) - 0x0101010101010101) & ~(X) & 0x8080808080808080)
+#else
+#error long int is not a 32bit or 64bit type.
+#endif
+#endif
+
+#ifndef DETECTNULL
+#error long int is not a 32bit or 64bit byte
+#endif
+
+#define TOO_SMALL(LEN) ((LEN) < sizeof (long))
+
+char *
+stpncpy (char *__restrict dst,
+	const char *__restrict src,
+	size_t count)
+{
+  char *ret = NULL;
+
+#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
+  long *aligned_dst;
+  const long *aligned_src;
+
+  /* If SRC and DEST is aligned and count large enough, then copy words.  */
+  if (!UNALIGNED (src, dst) && !TOO_SMALL (count))
+    {
+      aligned_dst = (long*)dst;
+      aligned_src = (long*)src;
+
+      /* SRC and DEST are both "long int" aligned, try to do "long int"
+	 sized copies.  */
+      while (count >= sizeof (long int) && !DETECTNULL(*aligned_src))
+	{
+	  count -= sizeof (long int);
+	  *aligned_dst++ = *aligned_src++;
+	}
+
+      dst = (char*)aligned_dst;
+      src = (char*)aligned_src;
+    }
+#endif /* not PREFER_SIZE_OVER_SPEED */
+
+  while (count > 0)
+    {
+      --count;
+      if ((*dst++ = *src++) == '\0')
+	{
+	  ret = dst - 1;
+	  break;
+	}
+    }
+
+  while (count-- > 0)
+    *dst++ = '\0';
+
+  return ret ? ret : dst;
+}
diff --git a/src/libnpf/external/src/newlib/strcasecmp.c b/src/libnpf/external/src/newlib/strcasecmp.c
new file mode 100644
index 0000000..c75a3e2
--- /dev/null
+++ b/src/libnpf/external/src/newlib/strcasecmp.c
@@ -0,0 +1,51 @@
+/*
+FUNCTION
+	<<strcasecmp>>---case-insensitive character string compare
+	
+INDEX
+	strcasecmp
+
+SYNOPSIS
+	#include <strings.h>
+	int strcasecmp(const char *<[a]>, const char *<[b]>);
+
+DESCRIPTION
+	<<strcasecmp>> compares the string at <[a]> to
+	the string at <[b]> in a case-insensitive manner.
+
+RETURNS 
+
+	If <<*<[a]>>> sorts lexicographically after <<*<[b]>>> (after
+	both are converted to lowercase), <<strcasecmp>> returns a
+	number greater than zero.  If the two strings match,
+	<<strcasecmp>> returns zero.  If <<*<[a]>>> sorts
+	lexicographically before <<*<[b]>>>, <<strcasecmp>> returns a
+	number less than zero.
+
+PORTABILITY
+<<strcasecmp>> is in the Berkeley Software Distribution.
+
+<<strcasecmp>> requires no supporting OS subroutines. It uses
+tolower() from elsewhere in this library.
+
+QUICKREF
+	strcasecmp
+*/
+
+#include <strings.h>
+#include <ctype.h>
+
+int
+strcasecmp (const char *s1,
+	const char *s2)
+{
+  int d = 0;
+  for ( ; ; )
+    {
+      const int c1 = tolower(*s1++);
+      const int c2 = tolower(*s2++);
+      if (((d = c1 - c2) != 0) || (c2 == '\0'))
+        break;
+    }
+  return d;
+}
diff --git a/src/libnpf/npf.c b/src/libnpf/npf.c
index 34e7087..c867dbc 100644
--- a/src/libnpf/npf.c
+++ b/src/libnpf/npf.c
@@ -28,30 +28,29 @@
  */
 
 #include <sys/cdefs.h>
+#include <newlib/sys/cdefs.h>
 __KERNEL_RCSID(0, "$NetBSD$");
 
 #include <sys/types.h>
-#include <sys/mman.h>
-#include <sys/stat.h>
-#if !defined(_NPF_STANDALONE)
-#include <sys/ioctl.h>
-#endif
-#include <netinet/in_systm.h>
-#include <netinet/in.h>
-#include <net/if.h>
+
+#include <newlib/netinet/in.h>
+#include <newlib/linux/sys/socket.h>
 
 #include <stdlib.h>
 #include <string.h>
 #include <assert.h>
 #include <unistd.h>
-#include <errno.h>
-#include <err.h>
+
 
 #include <nv.h>
 #include <dnv.h>
 
 #include <cdbw.h>
 
+#ifndef __UNCONST
+#define __UNCONST(x) ((void *)(unsigned long)(const void*)(x))
+#endif
+
 #define	_NPF_PRIVATE
 #include "npf.h"
 
@@ -111,21 +110,6 @@ _npf_add_addr(nvlist_t *nvl, const char *name, int af, const npf_addr_t *addr)
 	return nvlist_error(nvl) == 0;
 }
 
-static unsigned
-_npf_get_addr(const nvlist_t *nvl, const char *name, npf_addr_t *addr)
-{
-	const void *d;
-	size_t sz = 0;
-
-	d = nvlist_get_binary(nvl, name, &sz);
-	switch (sz) {
-	case sizeof(struct in_addr):
-	case sizeof(struct in6_addr):
-		memcpy(addr, d, sz);
-		return (unsigned)sz;
-	}
-	return 0;
-}
 
 static bool
 _npf_dataset_lookup(const nvlist_t *dict, const char *dataset,
@@ -205,117 +189,7 @@ _npf_rules_process(nl_config_t *ncf, nvlist_t *dict, const char *key)
 	free(items);
 }
 
-/*
- * _npf_extract_error: check the error number field and extract the
- * error details into the npf_error_t structure.
- */
-static int
-_npf_extract_error(nvlist_t *resp, npf_error_t *errinfo)
-{
-	int error;
-
-	error = dnvlist_get_number(resp, "errno", 0);
-	if (error && errinfo) {
-		memset(errinfo, 0, sizeof(npf_error_t));
-
-		errinfo->id = dnvlist_get_number(resp, "id", 0);
-		errinfo->error_msg =
-		    dnvlist_take_string(resp, "error-msg", NULL);
-		errinfo->source_file =
-		    dnvlist_take_string(resp, "source-file", NULL);
-		errinfo->source_line =
-		    dnvlist_take_number(resp, "source-line", 0);
-	}
-	return error;
-}
-
-/*
- * npf_xfer_fd: transfer the given request and receive a response.
- *
- * => Sets the 'operation' key on the 'req' dictionary.
- * => On success: returns 0 and valid nvlist in 'resp'.
- * => On failure: returns an error number.
- */
-static int
-_npf_xfer_fd(int fd, unsigned long cmd, nvlist_t *req, nvlist_t **resp)
-{
-	struct stat st;
-	int kernver;
-
-	/*
-	 * Set the NPF version and operation.
-	 */
-	if (!nvlist_exists(req, "version")) {
-		nvlist_add_number(req, "version", NPF_VERSION);
-	}
-	nvlist_add_number(req, "operation", cmd);
-
-	/*
-	 * Determine the type of file descriptor:
-	 * - If socket, then perform nvlist_send()/nvlist_recv().
-	 * - If a character device, then use ioctl.
-	 */
-	if (fstat(fd, &st) == -1) {
-		goto err;
-	}
-	switch (st.st_mode & S_IFMT) {
-#if !defined(__NetBSD__)
-	case S_IFSOCK:
-		if (nvlist_send(fd, req) == -1) {
-			goto err;
-		}
-		if (resp && (*resp = nvlist_recv(fd, 0)) == NULL) {
-			goto err;
-		}
-		break;
-#endif
-#if !defined(_NPF_STANDALONE)
-	case S_IFBLK:
-	case S_IFCHR:
-		if (ioctl(fd, IOC_NPF_VERSION, &kernver) == -1) {
-			goto err;
-		}
-		if (kernver != NPF_VERSION) {
-			errno = EPROGMISMATCH;
-			goto err;
-		}
-		if (nvlist_xfer_ioctl(fd, cmd, req, resp) == -1) {
-			goto err;
-		}
-		break;
-#else
-		(void)kernver;
-#endif
-	default:
-		errno = ENOTSUP;
-		goto err;
-	}
-	return 0;
-err:
-	return errno ? errno : EIO;
-}
-
-/*
- * npf_xfer_fd_errno: same as npf_xfer_fd(), but:
- *
- * => After successful retrieval of the response, inspects it, extracts
- *    the 'errno' value (if any) and returns it.
- * => Destroys the response.
- */
-static int
-_npf_xfer_fd_errno(int fd, unsigned long cmd, nvlist_t *req)
-{
-	nvlist_t *resp;
-	int error;
 
-	error = _npf_xfer_fd(fd, cmd, req, &resp);
-	if (error) {
-		return error;
-	}
-	error = _npf_extract_error(resp, NULL);
-	nvlist_destroy(resp);
-	return error;
-}
 
 /*
  * CONFIGURATION INTERFACE.
@@ -335,48 +209,6 @@ npf_config_create(void)
 	return ncf;
 }
 
-int
-npf_config_submit(nl_config_t *ncf, int fd, npf_error_t *errinfo)
-{
-	nvlist_t *resp = NULL;
-	int error;
-
-	/* Ensure the config is built. */
-	(void)npf_config_build(ncf);
-
-	error = _npf_xfer_fd(fd, IOC_NPF_LOAD, ncf->ncf_dict, &resp);
-	if (error) {
-		return error;
-	}
-	error = _npf_extract_error(resp, errinfo);
-	nvlist_destroy(resp);
-	return error;
-}
-
-nl_config_t *
-npf_config_retrieve(int fd)
-{
-	nl_config_t *ncf;
-	nvlist_t *req, *resp = NULL;
-	int error;
-
-	ncf = calloc(1, sizeof(nl_config_t));
-	if (!ncf) {
-		return NULL;
-	}
-
-	req = nvlist_create(0);
-	error = _npf_xfer_fd(fd, IOC_NPF_SAVE, req, &resp);
-	nvlist_destroy(req);
-
-	if (error || _npf_extract_error(resp, NULL) != 0) {
-		nvlist_destroy(resp);
-		free(ncf);
-		return NULL;
-	}
-	ncf->ncf_dict = resp;
-	return ncf;
-}
 
 void *
 npf_config_export(nl_config_t *ncf, size_t *length)
@@ -403,22 +235,6 @@ npf_config_import(const void *blob, size_t len)
 	return ncf;
 }
 
-int
-npf_config_flush(int fd)
-{
-	nl_config_t *ncf;
-	npf_error_t errinfo;
-	int error;
-
-	ncf = npf_config_create();
-	if (!ncf) {
-		return ENOMEM;
-	}
-	nvlist_add_bool(ncf->ncf_dict, "flush", true);
-	error = npf_config_submit(ncf, fd, &errinfo);
-	npf_config_destroy(ncf);
-	return error;
-}
 
 bool
 npf_config_active_p(nl_config_t *ncf)
@@ -523,7 +339,6 @@ skip:
 		dparams = dnvlist_get_nvlist(ncf->ncf_dict,
 		    "params-defaults", NULL);
 		if (dparams == NULL) {
-			errno = EINVAL;
 			return NULL;
 		}
 		*defval = (int)nvlist_get_number(dparams, name);
@@ -545,82 +360,6 @@ _npf_nat_ruleset_p(const char *name)
 	    sizeof(NPF_RULESET_MAP_PREF) - 1) == 0;
 }
 
-int
-npf_ruleset_add(int fd, const char *rname, nl_rule_t *rl, uint64_t *id)
-{
-	const bool natset = _npf_nat_ruleset_p(rname);
-	nvlist_t *rule_nvl = rl->rule_dict, *resp;
-	int error;
-
-	nvlist_add_number(rule_nvl, "attr",
-	    NPF_RULE_DYNAMIC | nvlist_take_number(rule_nvl, "attr"));
-
-	if (natset && !dnvlist_get_bool(rule_nvl, "nat-rule", false)) {
-		errno = EINVAL;
-		return errno;
-	}
-	nvlist_add_string(rule_nvl, "ruleset-name", rname);
-	nvlist_add_bool(rule_nvl, "nat-ruleset", natset);
-	nvlist_add_number(rule_nvl, "command", NPF_CMD_RULE_ADD);
-
-	error = _npf_xfer_fd(fd, IOC_NPF_RULE, rule_nvl, &resp);
-	if (error) {
-		return error;
-	}
-	*id = nvlist_get_number(resp, "id");
-	nvlist_destroy(resp);
-	return 0;
-}
-
-int
-npf_ruleset_remove(int fd, const char *rname, uint64_t id)
-{
-	const bool natset = _npf_nat_ruleset_p(rname);
-	nvlist_t *rule_nvl = nvlist_create(0);
-	int error;
-
-	nvlist_add_string(rule_nvl, "ruleset-name", rname);
-	nvlist_add_bool(rule_nvl, "nat-ruleset", natset);
-	nvlist_add_number(rule_nvl, "command", NPF_CMD_RULE_REMOVE);
-	nvlist_add_number(rule_nvl, "id", id);
-
-	error = _npf_xfer_fd_errno(fd, IOC_NPF_RULE, rule_nvl);
-	nvlist_destroy(rule_nvl);
-	return error;
-}
-
-int
-npf_ruleset_remkey(int fd, const char *rname, const void *key, size_t len)
-{
-	const bool natset = _npf_nat_ruleset_p(rname);
-	nvlist_t *rule_nvl = nvlist_create(0);
-	int error;
-
-	nvlist_add_string(rule_nvl, "ruleset-name", rname);
-	nvlist_add_bool(rule_nvl, "nat-ruleset", natset);
-	nvlist_add_number(rule_nvl, "command", NPF_CMD_RULE_REMKEY);
-	nvlist_add_binary(rule_nvl, "key", key, len);
-
-	error = _npf_xfer_fd_errno(fd, IOC_NPF_RULE, rule_nvl);
-	nvlist_destroy(rule_nvl);
-	return error;
-}
-
-int
-npf_ruleset_flush(int fd, const char *rname)
-{
-	const bool natset = _npf_nat_ruleset_p(rname);
-	nvlist_t *rule_nvl = nvlist_create(0);
-	int error;
-
-	nvlist_add_string(rule_nvl, "ruleset-name", rname);
-	nvlist_add_bool(rule_nvl, "nat-ruleset", natset);
-	nvlist_add_number(rule_nvl, "command", NPF_CMD_RULE_FLUSH);
-
-	error = _npf_xfer_fd_errno(fd, IOC_NPF_RULE, rule_nvl);
-	nvlist_destroy(rule_nvl);
-	return error;
-}
 
 /*
  * NPF EXTENSION INTERFACE.
@@ -842,34 +581,6 @@ npf_rule_getcode(nl_rule_t *rl, int *type, size_t *len)
 	return dnvlist_get_binary(rl->rule_dict, "code", len, NULL, 0);
 }
 
-int
-_npf_ruleset_list(int fd, const char *rname, nl_config_t *ncf)
-{
-	const bool natset = _npf_nat_ruleset_p(rname);
-	nvlist_t *req, *resp;
-	int error;
-
-	req = nvlist_create(0);
-	nvlist_add_string(req, "ruleset-name", rname);
-	nvlist_add_bool(req, "nat-ruleset", natset);
-	nvlist_add_number(req, "command", NPF_CMD_RULE_LIST);
-
-	error = _npf_xfer_fd(fd, IOC_NPF_RULE, req, &resp);
-	nvlist_destroy(req);
-	if (error) {
-		return error;
-	}
-
-	if (nvlist_exists_nvlist_array(resp, "rules")) {
-		nvlist_t **rules;
-		size_t n;
-
-		rules = nvlist_take_nvlist_array(resp, "rules", &n);
-		nvlist_move_nvlist_array(ncf->ncf_dict, "rules", rules, n);
-	}
-	nvlist_destroy(resp);
-	return 0;
-}
 
 void
 npf_rule_destroy(nl_rule_t *rl)
@@ -1135,16 +846,15 @@ npf_table_add_entry(nl_table_t *tl, int af, const npf_addr_t *addr,
 	return 0;
 }
 
+
 static inline int
 _npf_table_build_const(nl_table_t *tl)
 {
 	struct cdbw *cdbw;
 	const nvlist_t * const *entries;
-	int error = 0, fd = -1;
-	size_t nitems, len;
-	void *cdb, *buf;
-	struct stat sb;
-	char sfn[32];
+	int error = 0;
+	size_t nitems, len = 0;
+	uint8_t *buf = NULL;
 
 	if (dnvlist_get_number(tl->table_dict, "type", 0) != NPF_TABLE_CONST) {
 		return 0;
@@ -1158,7 +868,7 @@ _npf_table_build_const(nl_table_t *tl)
 	 * Create a constant database and put all the entries.
 	 */
 	if ((cdbw = cdbw_open()) == NULL) {
-		return errno;
+		return -1; //errno;
 	}
 	entries = nvlist_get_nvlist_array(tl->table_dict, "entries", &nitems);
 	for (unsigned i = 0; i < nitems; i++) {
@@ -1172,48 +882,18 @@ _npf_table_build_const(nl_table_t *tl)
 			goto out;
 		}
 		if (cdbw_put(cdbw, addr, alen, addr, alen) == -1) {
-			error = errno;
+			error = -1; //errno;
 			goto out;
 		}
 	}
 
 	/*
-	 * Write the constant database into a temporary file.
+	 * Write the constant database into a binary buffer.
 	 */
-	strncpy(sfn, "/tmp/npfcdb.XXXXXX", sizeof(sfn));
-	sfn[sizeof(sfn) - 1] = '\0';
-
-	if ((fd = mkstemp(sfn)) == -1) {
-		error = errno;
-		goto out;
-	}
-	unlink(sfn);
-
-	if (cdbw_output(cdbw, fd, "npf-table-cdb", NULL) == -1) {
-		error = errno;
-		goto out;
-	}
-	if (fstat(fd, &sb) == -1) {
-		error = errno;
-		goto out;
-	}
-	len = sb.st_size;
-
-	/*
-	 * Memory-map the database and copy it into a buffer.
-	 */
-	buf = malloc(len);
-	if (!buf) {
-		error = ENOMEM;
-		goto out;
-	}
-	cdb = mmap(NULL, len, PROT_READ, MAP_FILE | MAP_PRIVATE, fd, 0);
-	if (cdb == MAP_FAILED) {
-		error = errno;
-		free(buf);
+	if (cdbw_output(cdbw, &buf, &len, "npf-table-cdb", NULL) == -1) {
+		error = -1; //errno;
 		goto out;
 	}
-	munmap(cdb, len);
 
 	/*
 	 * Move the data buffer to the nvlist.
@@ -1221,13 +901,12 @@ _npf_table_build_const(nl_table_t *tl)
 	nvlist_move_binary(tl->table_dict, "data", buf, len);
 	error = nvlist_error(tl->table_dict);
 out:
-	if (fd != -1) {
-		close(fd);
-	}
 	cdbw_close(cdbw);
 	return error;
 }
 
+
+
 int
 npf_table_insert(nl_config_t *ncf, nl_table_t *tl)
 {
@@ -1250,25 +929,6 @@ npf_table_insert(nl_config_t *ncf, nl_table_t *tl)
 	return 0;
 }
 
-int
-npf_table_replace(int fd, nl_table_t *tl, npf_error_t *errinfo)
-{
-	nvlist_t *resp = NULL;
-	int error;
-
-	/* Ensure const tables are built. */
-	if ((error = _npf_table_build_const(tl)) != 0) {
-		return error;
-	}
-	error = _npf_xfer_fd(fd, IOC_NPF_TABLE_REPLACE, tl->table_dict, &resp);
-	if (error) {
-		assert(resp == NULL);
-		return errno;
-	}
-	error = _npf_extract_error(resp, errinfo);
-	nvlist_destroy(resp);
-	return error;
-}
 
 nl_table_t *
 npf_table_iterate(nl_config_t *ncf, nl_iter_t *iter)
@@ -1341,183 +1001,14 @@ typedef struct {
 	in_port_t	port[3];
 } npf_connpoint_t;
 
-static int
-_npf_conn_lookup(int fd, const int af, npf_addr_t *addr[2], in_port_t port[2],
-    unsigned proto, const char *ifname, unsigned di)
-{
-	nvlist_t *req = NULL, *resp = NULL, *key_nv;
-	const nvlist_t *nat;
-	int error = EINVAL;
-
-	/*
-	 * Setup the connection lookup key.
-	 */
-	if ((key_nv = nvlist_create(0)) == NULL) {
-		return ENOMEM;
-	}
-	if (!_npf_add_addr(key_nv, "saddr", af, addr[0])) {
-		nvlist_destroy(key_nv);
-		goto out;
-	}
-	if (!_npf_add_addr(key_nv, "daddr", af, addr[1])) {
-		nvlist_destroy(key_nv);
-		goto out;
-	}
-	nvlist_add_number(key_nv, "sport", htons(port[0]));
-	nvlist_add_number(key_nv, "dport", htons(port[1]));
-	nvlist_add_number(key_nv, "proto", proto);
-	if (ifname) {
-		nvlist_add_string(key_nv, "ifname", ifname);
-	}
-	if (di) {
-		nvlist_add_number(key_nv, "di", di);
-	}
-
-	/*
-	 * Setup the request.
-	 */
-	if ((req = nvlist_create(0)) == NULL) {
-		error = ENOMEM;
-		goto out;
-	}
-	nvlist_move_nvlist(req, "key", key_nv);
-
-	/* Lookup: retrieve the connection entry. */
-	error = _npf_xfer_fd(fd, IOC_NPF_CONN_LOOKUP, req, &resp);
-	if (error) {
-		goto out;
-	}
-
-	/*
-	 * Get the NAT entry and extract the translated pair.
-	 */
-	if ((nat = dnvlist_get_nvlist(resp, "nat", NULL)) == NULL) {
-		error = ENOENT;
-		goto out;
-	}
-	if (_npf_get_addr(nat, "oaddr", addr[0]) == 0 ||
-	    _npf_get_addr(nat, "taddr", addr[1]) == 0) {
-		error = EINVAL;
-		goto out;
-	}
-	port[0] = ntohs(nvlist_get_number(nat, "oport"));
-	port[1] = ntohs(nvlist_get_number(nat, "tport"));
-out:
-	if (resp) {
-		nvlist_destroy(resp);
-	}
-	if (req) {
-		nvlist_destroy(req);
-	}
-	return error;
-}
-
-int
-npf_nat_lookup(int fd, int af, npf_addr_t *addr[2], in_port_t port[2],
-    int proto, int di __unused)
-{
-	int error;
-
-	port[0] = ntohs(port[0]); port[1] = ntohs(port[1]);
-	error = _npf_conn_lookup(fd, af, addr, port, proto, NULL, 0);
-	port[0] = htons(port[0]); port[1] = htons(port[1]);
-	return error;
-}
-
-static bool
-npf_connkey_handle(const nvlist_t *key_nv, npf_connpoint_t *ep)
-{
-	unsigned alen1, alen2;
-
-	alen1 = _npf_get_addr(key_nv, "saddr", &ep->addr[0]);
-	alen2 = _npf_get_addr(key_nv, "daddr", &ep->addr[1]);
-	if (alen1 == 0 || alen1 != alen2) {
-		return false;
-	}
-	ep->alen = alen1;
-	ep->port[0] = ntohs(nvlist_get_number(key_nv, "sport"));
-	ep->port[1] = ntohs(nvlist_get_number(key_nv, "dport"));
-	ep->proto = nvlist_get_number(key_nv, "proto");
-	return true;
-}
-
-static void
-npf_conn_handle(const nvlist_t *conn, npf_conn_func_t func, void *arg)
-{
-	const nvlist_t *key_nv, *nat_nv;
-	const char *ifname;
-	npf_connpoint_t ep;
 
-	memset(&ep, 0, sizeof(npf_connpoint_t));
 
-	ifname = dnvlist_get_string(conn, "ifname", NULL);
-	key_nv = dnvlist_get_nvlist(conn, "forw-key", NULL);
-	if (!npf_connkey_handle(key_nv, &ep)) {
-		goto err;
-	}
-	if ((nat_nv = dnvlist_get_nvlist(conn, "nat", NULL)) != NULL) {
-		if (_npf_get_addr(nat_nv, "taddr", &ep.addr[2]) != ep.alen) {
-			goto err;
-		}
-		ep.port[2] = ntohs(nvlist_get_number(nat_nv, "tport"));
-	}
-	/*
-	 * XXX: add 'proto' and 'flow'; perhaps expand and pass the
-	 * whole to npf_connpoint_t?
-	 */
-	(*func)((unsigned)ep.alen, ep.addr, ep.port, ifname, arg);
-err:
-	return;
-}
 
-int
-npf_conn_list(int fd, npf_conn_func_t func, void *arg)
-{
-	nl_config_t *ncf;
-	const nvlist_t * const *conns;
-	size_t nitems;
-
-	ncf = npf_config_retrieve(fd);
-	if (!ncf) {
-		return errno;
-	}
-	if (!nvlist_exists_nvlist_array(ncf->ncf_dict, "conn-list")) {
-		return 0;
-	}
-	conns = nvlist_get_nvlist_array(ncf->ncf_dict, "conn-list", &nitems);
-	for (unsigned i = 0; i < nitems; i++) {
-		const nvlist_t *conn = conns[i];
-		npf_conn_handle(conn, func, arg);
-	}
-	npf_config_destroy(ncf);
-	return 0;
-}
 
 /*
  * MISC.
  */
 
-void
-_npf_debug_addif(nl_config_t *ncf, const char *ifname)
-{
-	nvlist_t *debug;
-
-	/*
-	 * Initialise the debug dictionary on the first call.
-	 */
-	debug = dnvlist_take_nvlist(ncf->ncf_dict, "debug", NULL);
-	if (debug == NULL) {
-		debug = nvlist_create(0);
-	}
-	if (!_npf_dataset_lookup(debug, "interfaces", "name", ifname)) {
-		nvlist_t *ifdict = nvlist_create(0);
-		nvlist_add_string(ifdict, "name", ifname);
-		nvlist_add_number(ifdict, "index", if_nametoindex(ifname));
-		nvlist_append_nvlist_array(debug, "interfaces", ifdict);
-		nvlist_destroy(ifdict);
-	}
-	nvlist_move_nvlist(ncf->ncf_dict, "debug", debug);
-}
 
 void
 _npf_config_dump(nl_config_t *ncf, int fd)
diff --git a/src/libnpf/npf.h b/src/libnpf/npf.h
index aab769f..e5e3d99 100644
--- a/src/libnpf/npf.h
+++ b/src/libnpf/npf.h
@@ -31,6 +31,10 @@
 #define _NPF_LIB_H_
 
 #include <sys/types.h>
+// TODO!
+#ifndef TZR_PTA_OPTEE
+#define TZR_TRIMMED_NPF
+#endif
 #include <net/npf.h>
 
 __BEGIN_DECLS
@@ -77,9 +81,6 @@ typedef int (*npf_conn_func_t)(unsigned, const npf_addr_t *,
 
 nl_config_t *	npf_config_create(void);
 void		npf_config_destroy(nl_config_t *);
-int		npf_config_submit(nl_config_t *, int, npf_error_t *);
-nl_config_t *	npf_config_retrieve(int);
-int		npf_config_flush(int);
 nl_config_t *	npf_config_import(const void *, size_t);
 void *		npf_config_export(nl_config_t *, size_t *);
 bool		npf_config_active_p(nl_config_t *);
@@ -92,10 +93,6 @@ int		npf_param_get(nl_config_t *, const char *, int *);
 int		npf_param_set(nl_config_t *, const char *, int);
 const char *	npf_param_iterate(nl_config_t *, nl_iter_t *, int *, int *);
 
-int		npf_ruleset_add(int, const char *, nl_rule_t *, uint64_t *);
-int		npf_ruleset_remove(int, const char *, uint64_t);
-int		npf_ruleset_remkey(int, const char *, const void *, size_t);
-int		npf_ruleset_flush(int, const char *);
 
 nl_ext_t *	npf_ext_construct(const char *);
 void		npf_ext_param_u32(nl_ext_t *, const char *, uint32_t);
@@ -140,9 +137,6 @@ in_port_t	npf_nat_getport(nl_nat_t *);
 unsigned	npf_nat_gettable(nl_nat_t *);
 unsigned	npf_nat_getalgo(nl_nat_t *);
 int		npf_nat_insert(nl_config_t *, nl_nat_t *);
-int		npf_nat_lookup(int, int, npf_addr_t *[2], in_port_t [2], int, int);
-
-int		npf_conn_list(int, npf_conn_func_t, void *);
 
 nl_table_t *	npf_table_create(const char *, unsigned, int);
 const char *	npf_table_getname(nl_table_t *);
@@ -153,19 +147,16 @@ int		npf_table_add_entry(nl_table_t *, int,
 int		npf_table_insert(nl_config_t *, nl_table_t *);
 void		npf_table_destroy(nl_table_t *);
 
-int		npf_table_replace(int, nl_table_t *, npf_error_t *);
 
 #ifdef _NPF_PRIVATE
 
-#include <ifaddrs.h>
+#include <newlib/ifaddrs.h>
 
 nl_rule_t *	npf_rule_iterate(nl_config_t *, nl_iter_t *, unsigned *);
 nl_nat_t *	npf_nat_iterate(nl_config_t *, nl_iter_t *);
 nl_rproc_t *	npf_rproc_iterate(nl_config_t *, nl_iter_t *);
 nl_table_t *	npf_table_iterate(nl_config_t *, nl_iter_t *);
 
-int		_npf_ruleset_list(int, const char *, nl_config_t *);
-void		_npf_debug_addif(nl_config_t *, const char *);
 void		_npf_config_dump(nl_config_t *, int);
 
 #endif
diff --git a/src/libnpf/sub.mk b/src/libnpf/sub.mk
new file mode 100644
index 0000000..caa30bf
--- /dev/null
+++ b/src/libnpf/sub.mk
@@ -0,0 +1,25 @@
+#global-incdirs-y += include
+
+incdirs-y += external/include
+#srcs-y += external/newlib/src/strcasecmp.c
+
+incdirs-y += net
+incdirs-y += ../kern/stand
+incdirs-y += ../../../libqsbr/src
+incdirs-y += ../../../thmap/src
+incdirs-y += ../../../liblpm/src
+#TODO: pcap/bpf.h header is missing! (-> libpcap-devel) | Q: Is ARM vs. x86 header different?
+#TODO: incdirs-y += ../../../bpfjit/src
+srcs-y += npf.c
+srcs-y += external/src/newlib/stpncpy.c
+
+# To remove a certain compiler flag, add a line like this
+#cflags-template_ta.c-y += -Wno-strict-prototypes
+
+incdirs-y += ../../../nvlist/src/
+libnames += nvlist
+libdirs += ../../../nvlist/out/tlib/
+
+incdirs-y += ../../../libcdb/src/
+libnames += cdb
+libdirs += ../../../libcdb/out/tlib/
\ No newline at end of file
diff --git a/src/npfctl/.gitignore b/src/npfctl/.gitignore
new file mode 100644
index 0000000..e579d69
--- /dev/null
+++ b/src/npfctl/.gitignore
@@ -0,0 +1,5 @@
+*.o
+npf_parse.c
+npf_scan.c
+npf_parse.h
+npfctl
diff --git a/src/npfctl/Makefile b/src/npfctl/Makefile
index a06c71d..0bf387e 100644
--- a/src/npfctl/Makefile
+++ b/src/npfctl/Makefile
@@ -11,10 +11,12 @@ CFLAGS+=	-D_GNU_SOURCE -D_DEFAULT_SOURCE
 CFLAGS+=	-I. -D__RCSID\(x\)= -D__dead= -D__printflike\(x,y\)=
 CFLAGS+=	-Wno-unused-local-typedefs -Wno-unused-result
 
+CFLAGS+=    -Wno-implicit-fallthrough
+
 #
 # Extended warning flags.
 #
-CFLAGS+=	-Wno-unknown-warning-option # gcc vs clang
+#CFLAGS+=	-Wno-unknown-warning-option # gcc vs clang
 
 CFLAGS+=	-Wstrict-prototypes -Wmissing-prototypes -Wpointer-arith
 CFLAGS+=	-Wmissing-declarations #-Wredundant-decls -Wnested-externs
@@ -66,6 +68,9 @@ install:	IMAN8DIR=	$(DESTDIR)/$(MANDIR)/man8/
 # Targets
 #
 
+%.o: %.c
+	$(CC) -c -o $@ $< $(CFLAGS) -Wno-sign-compare
+
 all: $(OBJS)
 	$(CC) $^ -o $(BIN) $(LDFLAGS)
 
diff --git a/src/npfctl/external b/src/npfctl/external
new file mode 120000
index 0000000..07d880e
--- /dev/null
+++ b/src/npfctl/external
@@ -0,0 +1 @@
+../../../arm64-packets
\ No newline at end of file
diff --git a/src/npftest/libnpftest/npf_bpf_test.c b/src/npftest/libnpftest/npf_bpf_test.c
index 0659f71..cab3777 100644
--- a/src/npftest/libnpftest/npf_bpf_test.c
+++ b/src/npftest/libnpftest/npf_bpf_test.c
@@ -31,10 +31,6 @@
  * NPF tests of BPF coprocessor.
  */
 
-#ifdef _KERNEL
-#include <sys/types.h>
-#include <sys/endian.h>
-#endif
 
 #define	NPF_BPFCOP
 #include "npf_impl.h"
@@ -56,11 +52,7 @@ test_bpf_code(void *code, size_t size)
 	m = mbuf_get_pkt(AF_INET, IPPROTO_TCP,
 	    "192.168.2.100", "10.0.0.1", 15000, 80);
 	npc = get_cached_pkt(m, NULL);
-#ifdef _NPF_STANDALONE
 	bc_args.pkt = (const uint8_t *)nbuf_dataptr(npc->npc_nbuf);
-#else
-	bc_args.pkt = (const uint8_t *)m;
-#endif
 	bc_args.buflen = m_length(m);
 	bc_args.wirelen = bc_args.buflen;
 	bc_args.mem = memstore;
diff --git a/src/npftest/libnpftest/npf_gc_test.c b/src/npftest/libnpftest/npf_gc_test.c
index 3c3ee57..abfd19f 100644
--- a/src/npftest/libnpftest/npf_gc_test.c
+++ b/src/npftest/libnpftest/npf_gc_test.c
@@ -4,10 +4,6 @@
  * Public Domain.
  */
 
-#ifdef _KERNEL
-#include <sys/types.h>
-#include <sys/kmem.h>
-#endif
 
 #include "npf.h"
 #include "npf_impl.h"
diff --git a/src/npftest/libnpftest/npf_mbuf_subr.c b/src/npftest/libnpftest/npf_mbuf_subr.c
index 4d9c0d6..08a6526 100644
--- a/src/npftest/libnpftest/npf_mbuf_subr.c
+++ b/src/npftest/libnpftest/npf_mbuf_subr.c
@@ -4,16 +4,11 @@
  * Public Domain.
  */
 
-#ifdef _KERNEL
-#include <sys/types.h>
-#include <sys/kmem.h>
-#endif
 
 #include "npf_impl.h"
 #include "npf_test.h"
 
 
-#if defined(_NPF_STANDALONE)
 struct mbuf *
 npfkern_m_get(npf_t *npf __unused, unsigned flags, size_t space)
 {
@@ -28,13 +23,6 @@ npfkern_m_get(npf_t *npf __unused, unsigned flags, size_t space)
 	}
 	return m;
 }
-#else
-struct mbuf *
-npfkern_m_get(npf_t *npf __unused, unsigned flags, size_t space)
-{
-	return m_get(flags, space);
-}
-#endif
 
 static void *
 npfkern_m_getdata(const struct mbuf *m)
@@ -70,7 +58,6 @@ npfkern_m_length(const struct mbuf *m)
 void
 npfkern_m_freem(struct mbuf *m)
 {
-#ifdef _NPF_STANDALONE
 	struct mbuf *n;
 
 	do {
@@ -79,9 +66,6 @@ npfkern_m_freem(struct mbuf *m)
 		free(m);
 		m = n;
 	} while (m);
-#else
-	m_freem(m);
-#endif
 }
 
 static bool
diff --git a/src/npftest/libnpftest/npf_nat_test.c b/src/npftest/libnpftest/npf_nat_test.c
index d3a06c0..cf9798b 100644
--- a/src/npftest/libnpftest/npf_nat_test.c
+++ b/src/npftest/libnpftest/npf_nat_test.c
@@ -4,9 +4,6 @@
  * Public Domain.
  */
 
-#ifdef _KERNEL
-#include <sys/types.h>
-#endif
 
 #include "npf_impl.h"
 #include "npf_test.h"
diff --git a/src/npftest/libnpftest/npf_nbuf_test.c b/src/npftest/libnpftest/npf_nbuf_test.c
index d32d969..9e9d16e 100644
--- a/src/npftest/libnpftest/npf_nbuf_test.c
+++ b/src/npftest/libnpftest/npf_nbuf_test.c
@@ -4,10 +4,6 @@
  * Public Domain.
  */
 
-#ifdef _KERNEL
-#include <sys/types.h>
-#include <sys/kmem.h>
-#endif
 
 #include "npf_impl.h"
 #include "npf_test.h"
diff --git a/src/npftest/libnpftest/npf_perf_test.c b/src/npftest/libnpftest/npf_perf_test.c
index 6c71715..1206e4a 100644
--- a/src/npftest/libnpftest/npf_perf_test.c
+++ b/src/npftest/libnpftest/npf_perf_test.c
@@ -4,14 +4,6 @@
  * Public Domain.
  */
 
-#ifdef _KERNEL
-#include <sys/types.h>
-#include <sys/param.h>
-
-#include <sys/kernel.h>
-#include <sys/kmem.h>
-#include <sys/kthread.h>
-#endif
 
 #include "npf_impl.h"
 #include "npf_test.h"
diff --git a/src/npftest/libnpftest/npf_rule_test.c b/src/npftest/libnpftest/npf_rule_test.c
index 6b57d79..e97d833 100644
--- a/src/npftest/libnpftest/npf_rule_test.c
+++ b/src/npftest/libnpftest/npf_rule_test.c
@@ -4,9 +4,6 @@
  * Public Domain.
  */
 
-#ifdef _KERNEL
-#include <sys/types.h>
-#endif
 
 #include "npf_impl.h"
 #include "npf_test.h"
diff --git a/src/npftest/libnpftest/npf_state_test.c b/src/npftest/libnpftest/npf_state_test.c
index 1a5b3a5..3d679c4 100644
--- a/src/npftest/libnpftest/npf_state_test.c
+++ b/src/npftest/libnpftest/npf_state_test.c
@@ -4,10 +4,6 @@
  * Public Domain.
  */
 
-#ifdef _KERNEL
-#include <sys/types.h>
-#include <sys/kmem.h>
-#endif
 
 #include "npf_impl.h"
 #include "npf_test.h"
diff --git a/src/npftest/libnpftest/npf_table_test.c b/src/npftest/libnpftest/npf_table_test.c
index b70c4de..52a8396 100644
--- a/src/npftest/libnpftest/npf_table_test.c
+++ b/src/npftest/libnpftest/npf_table_test.c
@@ -4,10 +4,6 @@
  * Public Domain.
  */
 
-#ifdef _KERNEL
-#include <sys/types.h>
-#include <sys/kmem.h>
-#endif
 
 #ifdef __linux__
 #include <endian.h>
diff --git a/src/npftest/libnpftest/npf_test.h b/src/npftest/libnpftest/npf_test.h
index 3ca7ed9..7f75128 100644
--- a/src/npftest/libnpftest/npf_test.h
+++ b/src/npftest/libnpftest/npf_test.h
@@ -5,24 +5,6 @@
 #ifndef _LIB_NPF_TEST_H_
 #define _LIB_NPF_TEST_H_
 
-#ifdef _KERNEL
-#include <sys/types.h>
-#include <sys/mbuf.h>
-
-#include <netinet/in_systm.h>
-#include <netinet/in.h>
-#include <netinet6/in6.h>
-
-#include <netinet/ip.h>
-#include <netinet/ip6.h>
-#include <netinet/tcp.h>
-#include <netinet/udp.h>
-#include <netinet/ip_icmp.h>
-
-#include <net/if.h>
-#include <net/if_ether.h>
-#include <net/ethertypes.h>
-#endif
 
 #define	IFNAME_DUMMY	"npftest999"
 
@@ -52,7 +34,6 @@
 #define	NET_A_IP1	"10.100.7.126"
 #define	NET_B_IP1	"10.255.7.126"
 
-#if defined(_NPF_STANDALONE)
 
 #define	MLEN		512
 
@@ -79,7 +60,6 @@ struct mbuf {
 #define	m_freem(m)		npfkern_m_freem(m)
 #define	mtod(m, t)		((t)((m)->m_data))
 
-#endif
 
 #define	CHECK_TRUE(x)	\
     if (!(x)) { printf("FAIL: %s line %d\n", __func__, __LINE__); return 0; }
diff --git a/src/npftest/libnpftest/npf_test_subr.c b/src/npftest/libnpftest/npf_test_subr.c
index 83ebedc..7d6756f 100644
--- a/src/npftest/libnpftest/npf_test_subr.c
+++ b/src/npftest/libnpftest/npf_test_subr.c
@@ -4,13 +4,6 @@
  * Public Domain.
  */
 
-#ifdef _KERNEL
-#include <sys/types.h>
-#include <sys/cprng.h>
-#include <sys/kmem.h>
-#include <net/if.h>
-#include <net/if_types.h>
-#endif
 
 #include "npf_impl.h"
 #include "npf_test.h"
@@ -261,13 +254,3 @@ npf_inet_ntop(int af, const void *src, char *dst, socklen_t size)
 	return _ntop_func(af, src, dst, size);
 }
 
-#ifdef _KERNEL
-/*
- * Need to override cprng_fast32() -- we need deterministic PRNG.
- */
-uint32_t
-cprng_fast32(void)
-{
-	return (uint32_t)(_random_func ? _random_func() : random());
-}
-#endif
diff --git a/src/npftest/npfstream.c b/src/npftest/npfstream.c
index e0a835b..a2b570a 100644
--- a/src/npftest/npfstream.c
+++ b/src/npftest/npfstream.c
@@ -16,17 +16,6 @@
 
 #include <arpa/inet.h>
 
-#if !defined(_NPF_STANDALONE)
-#include <net/if.h>
-#include <net/ethertypes.h>
-#include <net/if_ether.h>
-#include <netinet/in_systm.h>
-#include <netinet/ip.h>
-#include <netinet/ip.h>
-#include <netinet/tcp.h>
-
-#include <rump/rump.h>
-#endif
 
 #include "npftest.h"
 
diff --git a/src/npftest/npftest.c b/src/npftest/npftest.c
index 6aa857a..803fb6d 100644
--- a/src/npftest/npftest.c
+++ b/src/npftest/npftest.c
@@ -17,17 +17,6 @@
 
 #include <sys/mman.h>
 #include <sys/stat.h>
-#if !defined(_NPF_STANDALONE)
-#include <sys/ioctl.h>
-#include <net/if.h>
-#include <arpa/inet.h>
-
-#include <dnv.h>
-#include <nv.h>
-
-#include <rump/rump.h>
-#include <rump/rump_syscalls.h>
-#endif
 
 #include <cdbw.h>
 
@@ -168,22 +157,11 @@ generate_test_cdb(size_t *size)
 static void
 npf_kern_init(void)
 {
-#if !defined(_NPF_STANDALONE)
-	/* XXX rn_init */
-	extern int rumpns_max_keylen;
-	rumpns_max_keylen = 1;
-
-	rump_init();
-	rump_schedule();
-#endif
 }
 
 static void
 npf_kern_fini(void)
 {
-#if !defined(_NPF_STANDALONE)
-	rump_unschedule();
-#endif
 }
 
 int
diff --git a/src/npftest/npftest.h b/src/npftest/npftest.h
index 964bb59..671b8a4 100644
--- a/src/npftest/npftest.h
+++ b/src/npftest/npftest.h
@@ -10,9 +10,6 @@
 #include <inttypes.h>
 #include <stdbool.h>
 
-#if !defined(_NPF_STANDALONE)
-#include <net/if.h>
-#else
 #define	rumpns_npf_test_addif		npf_test_addif
 #define	rumpns_npf_test_load		npf_test_load
 #define	rumpns_npf_test_init		npf_test_init
@@ -27,7 +24,6 @@
 #define	rumpns_npf_gc_test		npf_gc_test
 #define	rumpns_npf_test_conc		npf_test_conc
 #define	rumpns_npf_test_statetrack	npf_test_statetrack
-#endif
 
 #include "npf.h"
 
