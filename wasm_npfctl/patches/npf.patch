diff --git a/.github/ISSUE_TEMPLATE/bug_report.md b/.github/ISSUE_TEMPLATE/bug_report.md
deleted file mode 100644
index 6d2eca1..0000000
--- a/.github/ISSUE_TEMPLATE/bug_report.md
+++ /dev/null
@@ -1,32 +0,0 @@
----
-name: Bug report
-about: Create a report to help us improve
-title: ''
-labels: bug
-assignees: ''
-
----
-
-### Description
-
-- Please provide a clear and concise problem description here.
-- Make sure you explain how to reproduce the problem.
-- If applicable, describe the expected behaviour.
-
-### Environment and configuration
-
-Environment:
-- NPF environment: [ NPF-Router | bespoke Linux/DPDK application | NetBSD | other ]
-- Operating system version: [ distribution/release and output of `uname -a` ]
-- NPF version: [ GIT commit, package or release version ]
-
-Configuration:
-- If applicable, provide your `npf.conf` configuration.
-- If applicable, provide the output of: `npfctl debug -c npf.conf -o npf.nvlist`
-- If applicable, describe your network setup and/or logical topology.
-
-### Any additional information
-
-- You can describe a proposed fix, patch or suggestion, if you have one.
-- If reporting a crash, try to obtain the stack trace from GDB or other debugger.
-- If applicable, attach the relevant tcpdump output or _pcap_ files.
diff --git a/.github/ISSUE_TEMPLATE/feature-or-change-request.md b/.github/ISSUE_TEMPLATE/feature-or-change-request.md
deleted file mode 100644
index acccacf..0000000
--- a/.github/ISSUE_TEMPLATE/feature-or-change-request.md
+++ /dev/null
@@ -1,25 +0,0 @@
----
-name: Feature or change request
-about: Suggest an idea for this project
-title: ''
-labels: enhancement
-assignees: ''
-
----
-
-### Description
-
-- Please provide a clear and concise description here.
-- Double check the manuals to be sure that this functionality is not already available.
-- Unless it is obvious, please explain your use case.
-- **Note:** While feature requests are welcome, you are strongly encouraged to contribute patches!
-
-### Environment
-
-If applicable, describe the environment:
-- [ NPF-Router | bespoke Linux/DPDK application | NetBSD | other ]
-
-### Any additional information
-
-- You can describe a proposed fix, patch or suggestion, if you have one.
-- You can discuss the design, expected behaviour, configuration syntax, etc.
diff --git a/.github/ISSUE_TEMPLATE/other-issue.md b/.github/ISSUE_TEMPLATE/other-issue.md
deleted file mode 100644
index 1df9ae6..0000000
--- a/.github/ISSUE_TEMPLATE/other-issue.md
+++ /dev/null
@@ -1,18 +0,0 @@
----
-name: Other issue
-about: Report other issues here
-title: ''
-labels: ''
-assignees: ''
-
----
-
-### Description
-
-- Please provide a clear and concise description here.
-- If you ask for help, please double check the manual pages and documentation that your question is certainly not addressed there (e.g. double-check the `pcap-filter` capability).
-
-### Environment
-
-If applicable, describe the environment:
-- [ NPF-Router | bespoke Linux/DPDK application | NetBSD | other ]
diff --git a/app/README.md b/app/README.md
deleted file mode 100644
index 937bf04..0000000
--- a/app/README.md
+++ /dev/null
@@ -1,28 +0,0 @@
-# NPF-Router: a demo NPF+DPDK application
-
-**NPF-Router** is a NPF+DPDK application provided as a Docker container.
-It illustrates how NPF can be integrated with the Intel DPDK framework.
-Together with _docker-compose_, it can also be used to spawn a virtual test
-network for basic NPF functionality testing.
-
-**WARNING**: This is an application for demos and testing: do not expect
-compliance with the standards, security or maximum performance.
-
-# Running
-
-**Prerequisite**: Docker running on a Linux host.
-
-Spin up the test network:
-```shell
-docker-compose up
-```
-
-(Re)load NPF configuration:
-```shell
-docker-compose exec npf-router npfctl reload
-```
-
-Enter the router shell:
-```shell
-docker-compose exec npf-router bash -i
-```
diff --git a/app/conf/host.Dockerfile b/app/conf/host.Dockerfile
deleted file mode 100644
index 12e435d..0000000
--- a/app/conf/host.Dockerfile
+++ /dev/null
@@ -1,14 +0,0 @@
-##########################################################################
-# NPF demo host -- CentOS 8.x image
-#
-FROM centos:centos8
-
-RUN dnf update -y
-RUN dnf install -y epel-release dnf-plugins-core
-RUN dnf config-manager --set-enabled PowerTools
-
-RUN dnf install -y man-pages net-tools tcpdump traceroute mtr
-RUN dnf install -y nmap-ncat socat nmap telnet curl bind-utils
-
-WORKDIR /app
-COPY ./app/run_host.sh /app/
diff --git a/app/conf/npf-deps.Dockerfile b/app/conf/npf-deps.Dockerfile
deleted file mode 100644
index 497f016..0000000
--- a/app/conf/npf-deps.Dockerfile
+++ /dev/null
@@ -1,50 +0,0 @@
-##########################################################################
-# NPF and dependency builder -- CentOS 8.x image
-#
-FROM centos:centos8 AS npf-builder
-WORKDIR /build
-
-# Install/enable EPEL and Power Tools repositories.
-RUN dnf install -y epel-release dnf-plugins-core
-RUN dnf config-manager --set-enabled PowerTools
-RUN dnf install -y net-tools man-pages
-
-#
-# Install all the packages for building.
-#
-RUN dnf install -y gcc make gdb rpm-build libasan libubsan lua-devel
-RUN dnf install -y libtool byacc flex jemalloc-devel
-RUN dnf install -y libpcap libpcap-devel openssl-libs openssl-devel
-RUN dnf install -y git subversion
-
-# Install DPDK dependencies (to caching for the build).
-RUN dnf install -y kernel-modules kernel-modules-extra dpdk-devel libibverbs
-
-# Make it work with unprivileged container.
-ENV LSAN_OPTIONS=detect_leaks=false
-
-# nvlist
-RUN git clone https://github.com/rmind/nvlist
-RUN cd nvlist/pkg && make rpm && rpm -ihv RPMS/*/*.rpm
-# libqsbr
-RUN git clone https://github.com/rmind/libqsbr
-RUN cd libqsbr/pkg && make rpm && rpm -ihv RPMS/*/*.rpm
-# libthmap
-RUN git clone https://github.com/rmind/thmap
-RUN cd thmap/pkg && make rpm && rpm -ihv RPMS/*/*.rpm
-# liblpm
-RUN git clone https://github.com/rmind/liblpm
-RUN cd liblpm/pkg && make rpm && rpm -ihv RPMS/*/*.rpm
-# rhashmap
-RUN git clone https://github.com/rmind/rhashmap
-RUN cd rhashmap/pkg && make rpm && rpm -ihv RPMS/*/*.rpm
-# bpfjit
-RUN git clone https://github.com/rmind/bpfjit
-RUN cd bpfjit && make rpm && rpm -ihv RPMS/*/*.rpm
-# libcdb
-RUN git clone https://github.com/rmind/libcdb
-RUN cd libcdb && make rpm && rpm -ihv RPMS/*/*.rpm
-
-# Copy all RPMs.
-WORKDIR /pkg
-RUN find /build -name '*.rpm' -exec cp {} /pkg \;
diff --git a/app/conf/npf-pkg.Dockerfile b/app/conf/npf-pkg.Dockerfile
deleted file mode 100644
index 0f39a98..0000000
--- a/app/conf/npf-pkg.Dockerfile
+++ /dev/null
@@ -1,14 +0,0 @@
-##########################################################################
-# NPF builder -- contains all the dependencies
-#
-FROM npf-deps AS npf-pkg
-
-#
-# - Copy over the source code and build NPF.
-# - Build the standalone NPF components.
-# - Copy over the NPF packages.
-#
-COPY . /build/npf
-RUN cd /build/npf/pkg && make rpm-libnpf && \
-    rpm -ihv RPMS/*/*.rpm && make rpm-npfctl
-RUN find /build/npf -name '*.rpm' -exec cp {} /pkg \;
diff --git a/app/conf/npf-router.Dockerfile b/app/conf/npf-router.Dockerfile
deleted file mode 100644
index a62fb06..0000000
--- a/app/conf/npf-router.Dockerfile
+++ /dev/null
@@ -1,30 +0,0 @@
-##########################################################################
-# NPF + DPDK builder
-#
-FROM npf-pkg AS npf-router-dev
-WORKDIR /build
-COPY . /build/npf
-
-#
-# Build the application.
-#
-RUN cd /build/npf/app/src && \
-    make && mkdir -p /build/bin && \
-    DESTDIR="/build/bin" BINDIR="" make install
-RUN cp /build/npf/app/run.sh /build/bin/
-
-##########################################################################
-# Create a separate NPF-router image.
-#
-
-FROM centos:centos8 AS npf
-RUN dnf install -y epel-release dnf-plugins-core
-RUN dnf config-manager --set-enabled PowerTools
-RUN dnf install -y kernel-modules kernel-modules-extra dpdk libibverbs
-RUN dnf install -y man-pages net-tools traceroute
-
-COPY --from=npf-router-dev /pkg/*.rpm /pkg/
-RUN dnf install -y /pkg/*.x86_64.rpm
-
-WORKDIR /app
-COPY --from=npf-router-dev /build/bin/* /app/
diff --git a/app/docker-compose.yaml b/app/docker-compose.yaml
deleted file mode 100644
index ee98846..0000000
--- a/app/docker-compose.yaml
+++ /dev/null
@@ -1,83 +0,0 @@
-version: '3.4'
-
-services:
-
-  npf-deps:
-    build:
-      context: ..
-      dockerfile: app/conf/npf-deps.Dockerfile
-    image: npf-deps
-    volumes:
-      - ../:/src
-
-  npf-pkg:
-    build:
-      context: ..
-      dockerfile: app/conf/npf-pkg.Dockerfile
-    depends_on:
-      - npf-deps
-    image: npf-pkg
-    volumes:
-      - ../:/src
-
-  npf-router-dev:
-    build:
-      context: ..
-      dockerfile: app/conf/npf-router.Dockerfile
-      target: npf-router-dev
-    image: npf_router_dev
-    privileged: true
-    depends_on:
-      - npf-pkg
-    hostname: npf-router
-    networks:
-      default:
-      testnet:
-        ipv4_address: 10.0.0.254
-    volumes:
-      - ../:/src
-    command:
-      - "/bin/true"
-
-  npf-router:
-    build:
-      context: ..
-      dockerfile: app/conf/npf-router.Dockerfile
-    image: npf_router
-    privileged: true
-    depends_on:
-      - npf-pkg
-    hostname: npf-router
-    networks:
-      default:
-      testnet:
-        ipv4_address: 10.0.0.2
-    command:
-      - "/app/run.sh"
-
-  host-1:
-    build:
-      context: ..
-      dockerfile: app/conf/host.Dockerfile
-    image: npf_host_1
-    privileged: true
-    hostname: npf_host_1
-    networks:
-      testnet:
-        ipv4_address: 10.0.0.3
-    #depends_on:
-    #  - npf-router
-    command:
-      - "/app/run_host.sh"
-
-networks:
-  testnet:
-    #
-    # NOTE: Must the 'macvlan' driver, otherwise Docker interferes
-    # at the Ethernet layer.
-    #
-    driver: macvlan
-    internal: true
-    ipam:
-      config:
-        - subnet: 10.0.0.0/24
diff --git a/app/run.sh b/app/run.sh
deleted file mode 100755
index 0d0eb40..0000000
--- a/app/run.sh
+++ /dev/null
@@ -1,62 +0,0 @@
-#!/bin/sh
-
-set -eu
-
-get_eth_addr() { ifconfig $1 | awk '/inet / { print $2 }'; }
-get_default_gw() { netstat -nr | grep 'UG[ \t]' | awk '{print $2}'; }
-
-system_configure()
-{
-	local cfg="/sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages"
-	local val=$(sysctl kernel.randomize_va_space | awk '{print $3}')
-
-	[ "$(cat $cfg)" = "1024" ] || echo 1024 > "$cfg";
-	[ "$val" = "0" ] || sysctl -w kernel.randomize_va_space=0;
-
-	mount | grep -q ' /mnt/huge ' || {
-		mkdir -p /mnt/huge && mount -t hugetlbfs nodev /mnt/huge;
-	}
-
-	modprobe sch_multiq
-}
-
-router_configure()
-{
-	[ ! -f /etc/npf-router.conf ] || return 0;
-
-	echo "ifconfig dtap0 $(get_eth_addr eth0)" >> /etc/npf-router.conf
-	echo "ifconfig dtap1 $(get_eth_addr eth1)" >> /etc/npf-router.conf
-	echo "route 0.0.0.0/0 dtap0 $(get_default_gw)" >> /etc/npf-router.conf
-	echo "route 10.0.0.0/24 dtap1" >> /etc/npf-router.conf
-
-	cat > /etc/npf.conf <<-EOF
-	\$ext_if = dtap0
-	\$int_if = dtap1
-
-	map \$ext_if dynamic 10.0.0.0/24 -> $(get_eth_addr eth0)
-
-	group "external" on \$ext_if {
-	  pass stateful out final all
-	}
-
-	group "internal" on \$int_if {
-	  pass final all
-	}
-
-	group default {
-	  block all
-	}
-	EOF
-	npfctl debug -c /etc/npf.conf | tail -n1
-}
-
-run()
-{
-	/app/npf_router \
-	    --vdev=net_tap0,remote=eth0 \
-	    --vdev=net_tap1,remote=eth1
-}
-
-system_configure
-router_configure
-run
diff --git a/app/run_host.sh b/app/run_host.sh
deleted file mode 100755
index 6c3c3c2..0000000
--- a/app/run_host.sh
+++ /dev/null
@@ -1,8 +0,0 @@
-#!/bin/sh
-
-set -eu
-
-route del default
-route add default gw 10.0.0.2
-arping -f 10.0.0.2
-ping -i 60 -W 30 1.1.1.1
diff --git a/app/src/Makefile b/app/src/Makefile
deleted file mode 100644
index 8d7dfc4..0000000
--- a/app/src/Makefile
+++ /dev/null
@@ -1,85 +0,0 @@
-#
-# NPF + DPDK demo application.
-# This file is in the Public Domain.
-#
-
-BIN=		npf_router
-
-SYSNAME:=	$(shell uname -s)
-
-#
-# Common C compiler flags.
-#
-CFLAGS+=	-std=gnu11 -O2 -g -Wall -Wextra -Werror
-
-#
-# Extended warning flags.
-#
-CFLAGS+=	-Wno-unknown-warning-option # gcc vs clang
-
-CFLAGS+=	-Wstrict-prototypes -Wmissing-prototypes -Wpointer-arith
-CFLAGS+=	-Wmissing-declarations -Wredundant-decls -Wnested-externs
-CFLAGS+=	-Wshadow -Wcast-qual -Wcast-align -Wwrite-strings
-CFLAGS+=	-Wold-style-definition
-CFLAGS+=	-Wsuggest-attribute=noreturn -Wjump-misses-init
-CFLAGS+=	-Wduplicated-cond -Wmisleading-indentation -Wnull-dereference
-CFLAGS+=	-Wduplicated-branches -Wrestrict
-
-#
-# System-specific or compiler-specific flags.
-#
-
-ifeq ($(SYSNAME),Linux)
-CFLAGS+=	-D_POSIX_C_SOURCE=200809L
-CFLAGS+=	-D_GNU_SOURCE -D_DEFAULT_SOURCE
-CFLAGS+=	-Dgetprogname\(\)=\"$(BIN)\"
-endif
-
-#
-# Standard vs debug build flags.
-#
-ifeq ($(DEBUG),1)
-CFLAGS+=	-O0 -DDEBUG -fno-omit-frame-pointer
-CFLAGS+=	-fsanitize=address -fsanitize=undefined
-LDFLAGS+=	-fsanitize=address -fsanitize=undefined
-else
-CFLAGS+=	-DNDEBUG
-endif
-
-#
-# Dependencies: compiler flags and libraries to link.
-#
-CFLAGS+=	-march=native -I/usr/include/dpdk
-LDFLAGS+=	-lpthread -ldpdk -lrte_mbuf -lrte_net -lrte_ethdev
-LDFLAGS+=	-lrte_pmd_tap -lrte_pmd_virtio
-LDFLAGS+=	-lthmap -llpm
-ifeq ($(DEBUG),1)
-LDFLAGS+=	-lnpfkern-dbg
-else
-LDFLAGS+=	-lnpfkern
-endif
-LDFLAGS+=	-lnpf # XXX
-
-#
-# Objects to compile and binary to produce.
-#
-
-OBJS=		npf_dpdk_ops.o if_dpdk.o
-OBJS+=		npf_router.o worker.o arp.o route.o config.o
-
-#
-# Targets
-#
-
-install:	IBINDIR=	$(DESTDIR)/$(BINDIR)
-
-all: $(OBJS)
-	$(CC) $^ -o $(BIN) $(LDFLAGS)
-
-install:
-	mkdir -p $(IBINDIR) && install -c $(BIN) $(IBINDIR)
-
-clean:
-	rm -f $(BIN) *.o
-
-.PHONY: all install clean
diff --git a/app/src/arp.c b/app/src/arp.c
deleted file mode 100644
index 2243049..0000000
--- a/app/src/arp.c
+++ /dev/null
@@ -1,256 +0,0 @@
-/*
- * Copyright (c) 2020 Mindaugas Rasiukevicius <rmind at noxt eu>
- * All rights reserved.
- *
- * Use is subject to license terms, as specified in the LICENSE file.
- */
-
-/*
- * Minimalistic ARP implementation (demo only).
- *
- * Ethernet Address Resolution Protocol, RFC 826, November 1982.
- */
-
-#include <stdio.h>
-#include <arpa/inet.h>
-
-#include <rte_ether.h>
-#include <rte_arp.h>
-#include <rte_mbuf.h>
-
-#include "npf_router.h"
-#include "utils.h"
-
-typedef struct {
-	uint32_t		ipaddr;
-	struct ether_addr	hwaddr;
-} arp_entry_t;
-
-static void
-arp_cache(ifnet_t *ifp, const uint32_t *ipaddr,
-    const struct ether_addr *hwaddr, const bool allow_new)
-{
-	arp_entry_t *ac;
-	bool ok;
-
-	ac = thmap_get(ifp->arp_cache, ipaddr, sizeof(uint32_t));
-	if (__predict_true(ac)) {
-		/* TODO: Update. */
-		return;
-	}
-	if (!allow_new || (ac = malloc(sizeof(arp_entry_t))) == NULL) {
-		return;
-	}
-	memcpy(&ac->ipaddr, ipaddr, sizeof(ac->ipaddr));
-	memcpy(&ac->hwaddr, hwaddr, sizeof(ac->hwaddr));
-
-	ok = thmap_put(ifp->arp_cache, &ac->ipaddr, sizeof(ac->ipaddr), ac) == ac;
-	if (__predict_false(!ok)) {
-		/* Race: already cached. */
-		free(ac);
-	}
-}
-
-static int
-arp_cache_lookup(ifnet_t *ifp, const uint32_t *ipaddr, struct ether_addr *hwaddr)
-{
-	arp_entry_t *ac;
-
-	ac = thmap_get(ifp->arp_cache, ipaddr, sizeof(uint32_t));
-	if (ac == NULL) {
-		return -1;
-	}
-	ether_addr_copy(&ac->hwaddr, hwaddr);
-	return 0;
-}
-
-/*
- * arp_request: construct an ARP REQUEST packet.
- *
- * => On success, returns an mbuf with Ethernet header; NULL otherwise.
- */
-static struct rte_mbuf *
-arp_request(worker_t *worker, const struct ether_addr *src_hwaddr,
-    const uint32_t *src_addr, const uint32_t *target)
-{
-	struct rte_mbuf *m;
-	struct ether_hdr *eh;
-	struct arp_hdr *ah;
-	struct arp_ipv4 *arp;
-
-	m = rte_pktmbuf_alloc(worker->router->mbuf_pool);
-	if (m == NULL) {
-		return NULL;
-	}
-	eh = rte_pktmbuf_mtod(m, struct ether_hdr *);
-	m->l2_len = sizeof(struct ether_hdr);
-	m->l3_len = sizeof(struct arp_hdr);
-	m->data_len = m->l2_len + m->l3_len;
-	m->pkt_len = m->data_len;
-
-	memset(&eh->d_addr, 0xff, sizeof(struct ether_addr));
-	ether_addr_copy(src_hwaddr, &eh->s_addr);
-	eh->ether_type = htons(ETHER_TYPE_ARP);
-
-	/*
-	 * ARP Ethernet REQUEST.
-	 */
-	ah = rte_pktmbuf_mtod_offset(m, struct arp_hdr *, m->l2_len);
-	ah->arp_hrd = htons(ARP_HRD_ETHER);
-	ah->arp_pro = htons(ETHER_TYPE_IPv4);
-	ah->arp_hln = ETHER_ADDR_LEN;
-	ah->arp_pln = sizeof(struct in_addr);
-	ah->arp_op = htons(ARP_OP_REQUEST);
-
-	arp = &ah->arp_data;
-	ether_addr_copy(src_hwaddr, &arp->arp_sha);
-	memcpy(&arp->arp_sip, src_addr, sizeof(arp->arp_sip));
-
-	/* Broadcast message to look for the target. */
-	memset(&arp->arp_tha, 0xff, sizeof(arp->arp_tha));
-	memcpy(&arp->arp_tip, target, sizeof(arp->arp_tip));
-	return m;
-}
-
-/*
- * arp_resolve: given the IPv4 address and an interface, both specified
- * by the route, resolve its MAC address in the Ethernet network.
- *
- * => Performs a lookup in the ARP cache or sends an ARP request.
- * => On success, return 0 and writes the MAC address into the buffer.
- * => On failure, return -1.
- */
-int
-arp_resolve(worker_t *worker, const route_info_t *rt,
-    struct ether_addr *hwaddr)
-{
-	const uint32_t *addr = (const void *)&rt->next_hop;
-	struct rte_mbuf *m;
-	ifnet_t *ifp;
-	int ret;
-
-	if ((ifp = ifnet_get(worker->router, rt->if_idx)) == NULL) {
-		return -1;
-	}
-
-	/* Lookup in the ARP cache. */
-	ret = arp_cache_lookup(ifp, addr, hwaddr);
-	if (ret == 0) {
-		ifnet_put(ifp);
-		return 0;
-	}
-
-	/* Construct an ARP request. */
-	m = arp_request(worker, &ifp->hwaddr, (const void *)&ifp->ipaddr, addr);
-	ifnet_put(ifp);
-
-	/* Send an ARP request. */
-	if (m && pktq_enqueue(worker, rt->if_idx, m) == -1) {
-		return -1;
-	}
-
-	/* XXX: Just drop the packet for now; the caller will retry. */
-	return -1;
-}
-
-static inline bool
-arp_is_interesting(const struct arp_hdr *ah, const ifnet_t *ifp, bool *targeted)
-{
-	const struct arp_ipv4 *arp = &ah->arp_data;
-	const struct ether_addr *tha = &arp->arp_tha;
-	bool ucast, bcast;
-
-	/* Unicast to us, broadcast or ARP probe? */
-	ucast = is_same_ether_addr(&ifp->hwaddr, &arp->arp_tha);
-	bcast = is_broadcast_ether_addr(tha) || is_zero_ether_addr(tha);
-	if (ucast || bcast) {
-		/* Is the target IP matching the interface? */
-		*targeted = memcmp(&ifp->ipaddr,
-		    &arp->arp_tip, sizeof(arp->arp_tip)) == 0;
-		return true;
-	}
-	return false;
-}
-
-/*
- * arp_input: process an ARP packet.
- */
-int
-arp_input(worker_t *worker, struct rte_mbuf *m, const unsigned if_idx)
-{
-	ifnet_t *ifp = NULL;
-	struct ether_hdr *eh;
-	struct arp_hdr *ah;
-	struct arp_ipv4 *arp;
-	bool targeted;
-
-	/*
-	 * Get the ARP header and verify 1) hardware address type
-	 * 2) hardware address length 3) protocol address length.
-	 */
-	ah = rte_pktmbuf_mtod_offset(m, struct arp_hdr *, m->l2_len);
-	if (ah->arp_hrd != htons(ARP_HRD_ETHER) ||
-	    ah->arp_hln != ETHER_ADDR_LEN ||
-	    ah->arp_pln != sizeof(in_addr_t)) {
-		goto drop;
-	}
-	arp = &ah->arp_data;
-
-	if ((ifp = ifnet_get(worker->router, if_idx)) == NULL) {
-		goto drop;
-	}
-
-	if (!arp_is_interesting(ah, ifp, &targeted)) {
-		goto drop;
-	}
-
-	/*
-	 * ARP cache entry:
-	 *
-	 * => If target IP is us, then CREATE or UPDATE.
-	 * => Otherwise, UPDATE (only if the entry already exists).
-	 */
-	arp_cache(ifp, &arp->arp_sip, &arp->arp_sha, targeted);
-
-	/*
-	 * If ARP REQUEST for us, then process it producing APR REPLY.
-	 */
-	if (targeted && ntohs(ah->arp_op) == ARP_OP_REQUEST) {
-		const uint32_t ipaddr = arp->arp_tip; // copy
-
-		/*
-		 * Prepare an ARP REPLY.  Swap the source and target fields,
-		 * both for the hardware and protocol addresses.
-		 */
-		ah->arp_op = htons(ARP_OP_REPLY);
-
-		memcpy(&arp->arp_tha, &arp->arp_sha, sizeof(arp->arp_tha));
-		memcpy(&arp->arp_tip, &arp->arp_sip, sizeof(arp->arp_tip));
-
-		memcpy(&arp->arp_sha, &ifp->hwaddr, sizeof(arp->arp_sha));
-		memcpy(&arp->arp_sip, &ipaddr, sizeof(arp->arp_sip));
-
-		/* Update the Ethernet frame too. */
-		eh = rte_pktmbuf_mtod(m, struct ether_hdr *);
-		ether_addr_copy(&eh->s_addr, &eh->d_addr);
-		ether_addr_copy(&ifp->hwaddr, &eh->s_addr);
-
-		ifnet_put(ifp);
-
-		if (pktq_enqueue(worker, if_idx, m) == -1) {
-			goto drop;
-		}
-		return 1; // consume
-	}
-drop:
-	/*
-	 * Drop the packet:
-	 * - Release the interface, if holding.
-	 * - Free the packet.
-	 */
-	if (ifp) {
-		ifnet_put(ifp);
-	}
-	rte_pktmbuf_free(m);
-	return -1;
-}
diff --git a/app/src/config.c b/app/src/config.c
deleted file mode 100644
index 326dc17..0000000
--- a/app/src/config.c
+++ /dev/null
@@ -1,131 +0,0 @@
-/*
- * Copyright (c) 2020 Mindaugas Rasiukevicius <rmind at noxt eu>
- * All rights reserved.
- *
- * Use is subject to license terms, as specified in the LICENSE file.
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <err.h>
-
-#include <arpa/inet.h>
-#include <lpm.h>
-
-#include "npf_router.h"
-#include "utils.h"
-
-#define	NPF_ROUTER_CONFIG	"/etc/npf-router.conf"
-
-static unsigned
-str_tokenize(char *line, char **tokens, unsigned n)
-{
-	const char *sep = " \t";
-	unsigned i = 0;
-	char *token;
-
-	while ((token = strsep(&line, sep)) != NULL && i < n) {
-		if (*sep == '\0' || strpbrk(token, sep) != NULL) {
-			continue;
-		}
-		tokens[i++] = token;
-	}
-	return i;
-}
-
-static int
-parse_command(npf_router_t *router, char **tokens, size_t n)
-{
-	int if_idx;
-
-	if (strcasecmp(tokens[0], "route") == 0) {
-		route_table_t *rtable = router->rtable;
-		unsigned char addr[16];
-		route_info_t rt;
-		unsigned plen;
-		size_t alen;
-
-		if (n < 3) {
-			return -1;
-		}
-		if (lpm_strtobin(tokens[1], addr, &alen, &plen) == -1) {
-			return -1;
-		}
-		if ((if_idx = ifnet_register(router, tokens[2])) == -1) {
-			warnx("unknown interface '%s'", tokens[2]);
-			return -1;
-		}
-
-		memset(&rt, 0, sizeof(route_info_t));
-		rt.if_idx = if_idx;
-		if (n >= 4) {
-			if (inet_pton(AF_INET, tokens[3], &rt.next_hop) == -1) {
-				warnx("invalid gateway '%s'", tokens[3]);
-				return -1;
-			}
-			rt.addr_len = sizeof(in_addr_t);
-		}
-		if (route_add(rtable, addr, alen, plen, &rt) == -1) {
-			return -1;
-		}
-		return 0;
-	}
-	if (strcasecmp(tokens[0], "ifconfig") == 0) {
-		if (n < 2) {
-			return -1;
-		}
-		if ((if_idx = ifnet_register(router, tokens[1])) == -1) {
-			warnx("unknown interface '%s'", tokens[1]);
-			return -1;
-		}
-		router->ifnet_addrs[if_idx] = strdup(tokens[2]);
-		return 0;
-	}
-	return -1;
-}
-
-static int
-parse_config(npf_router_t *router, FILE *fp)
-{
-	char *line = NULL;
-	size_t ln = 0, n, linesz = 0;
-	ssize_t len;
-
-	while ((len = getline(&line, &linesz, fp)) > 0) {
-		char *tokens[] = { NULL, NULL, NULL, NULL };
-		ln++;
-
-		if (line[0] == '#') {
-			continue;
-		}
-		line[len - 1] = '\0';
-
-		n = str_tokenize(line, tokens, __arraycount(tokens));
-		if (n == 0) {
-			continue;
-		}
-		if (parse_command(router, tokens, n) == -1) {
-			warnx("invalid command at line %zu", ln);
-			free(line);
-			return -1;
-		}
-	}
-	free(line);
-	return 0;
-}
-
-int
-load_config(npf_router_t *router)
-{
-	const char *fpath = getenv("NPFR_CONFIG");
-	ssize_t ret = -1;
-	FILE *fp;
-
-	fp = fopen(fpath ? fpath : NPF_ROUTER_CONFIG, "r");
-	if (fp) {
-		ret = (parse_config(router, fp) || ferror(fp)) ? -1 : 0;
-		fclose(fp);
-	}
-	return ret;
-}
diff --git a/app/src/if_dpdk.c b/app/src/if_dpdk.c
deleted file mode 100644
index c655c67..0000000
--- a/app/src/if_dpdk.c
+++ /dev/null
@@ -1,178 +0,0 @@
-/*
- * Copyright (c) 2020 Mindaugas Rasiukevicius <rmind at noxt eu>
- * All rights reserved.
- *
- * Use is subject to license terms, as specified in the LICENSE file.
- */
-
-/*
- * DPDK abstracts NIC ports.  We concern only the Ethernet ports.
- */
-
-#include <stdio.h>
-#include <inttypes.h>
-#include <net/if.h>
-#include <arpa/inet.h>
-
-#include <rte_mempool.h>
-#include <rte_mbuf.h>
-#include <rte_ethdev.h>
-
-#include "npf_router.h"
-#include "utils.h"
-
-#define	RX_RING_SIZE	1024
-#define	TX_RING_SIZE	1024
-
-static const struct rte_eth_conf eth_conf_default = {
-	.rxmode = {
-		.max_rx_pkt_len = ETHER_MAX_LEN,
-	},
-};
-
-int
-ifnet_setup(npf_router_t *router, const unsigned port_id, const unsigned nqueues)
-{
-	struct rte_eth_conf pconf = eth_conf_default;
-	uint16_t nb_rxd = RX_RING_SIZE, nb_txd = TX_RING_SIZE;
-	struct rte_eth_dev_info dev_info;
-	struct rte_eth_txconf txconf;
-
-	/*
-	 * Obtain and setup some information about the Ethernet port.
-	 */
-	if (!rte_eth_dev_is_valid_port(port_id)) {
-		return -1;
-	}
-	rte_eth_dev_info_get(port_id, &dev_info);
-	if (dev_info.tx_offload_capa & DEV_TX_OFFLOAD_MBUF_FAST_FREE) {
-		pconf.txmode.offloads |= DEV_TX_OFFLOAD_MBUF_FAST_FREE;
-	}
-	txconf = dev_info.default_txconf;
-	txconf.offloads = pconf.txmode.offloads;
-
-	/*
-	 * Configure the Ethernet device.
-	 * Allocate and setup RX and TX rings and queues.
-	 */
-	if (rte_eth_dev_configure(port_id, nqueues, nqueues, &pconf) < 0) {
-		return -1;
-	}
-	if (rte_eth_dev_adjust_nb_rx_tx_desc(port_id, &nb_rxd, &nb_txd) < 0) {
-		return -1;
-	}
-	for (unsigned q = 0; q < nqueues; q++) {
-		if (rte_eth_rx_queue_setup(port_id, (uint16_t)q, nb_rxd,
-		    rte_eth_dev_socket_id(port_id), NULL,
-		    router->mbuf_pool) < 0) {
-			return -1;
-		}
-	}
-	for (unsigned q = 0; q < nqueues; q++) {
-		if (rte_eth_tx_queue_setup(port_id, (uint16_t)q, nb_txd,
-		    rte_eth_dev_socket_id(port_id), &txconf) < 0) {
-			return -1;
-		}
-	}
-
-	/*
-	 * Start the Ethernet port and enable the promiscuous mode.
-	 */
-	if (rte_eth_dev_start(port_id) < 0) {
-		return -1;
-	}
-	rte_eth_promiscuous_enable(port_id);
-	return 0;
-}
-
-int
-ifnet_register(npf_router_t *router, const char *name)
-{
-	unsigned if_idx, port_id;
-
-	if ((if_idx = if_nametoindex(name)) == 0) {
-		return -1;
-	}
-	RTE_ETH_FOREACH_DEV(port_id) {
-		struct rte_eth_dev_info dev_info;
-
-		rte_eth_dev_info_get(port_id, &dev_info);
-		if (dev_info.if_index == if_idx) {
-			/* Register this port ID as of "interest". */
-			ASSERT(port_id < MAX_IFNET_IDS);
-			router->ifnet_bitset |= (1U << port_id);
-			return port_id;
-		}
-	}
-	return -1;
-}
-
-bool
-ifnet_interesting(npf_router_t *router, const unsigned port_id)
-{
-	ASSERT(port_id < MAX_IFNET_IDS);
-	return (router->ifnet_bitset & (1U << port_id)) != 0;
-}
-
-int
-ifnet_ifattach(npf_router_t *router, const unsigned port_id)
-{
-	struct rte_eth_dev_info dev_info;
-	char name[IF_NAMESIZE];
-	in_addr_t addr;
-	ifnet_t *ifp;
-
-	rte_eth_dev_info_get(port_id, &dev_info);
-	if (if_indextoname(dev_info.if_index, name) == NULL) {
-		return -1;
-	}
-	if ((ifp = calloc(1, sizeof(ifnet_t))) == NULL) {
-		return -1;
-	}
-	ifp->arp_cache = thmap_create(0, NULL, THMAP_NOCOPY);
-	if (ifp->arp_cache == NULL) {
-		free(ifp);
-		return -1;
-	}
-
-	ifp->port_id = port_id;
-	strncpy(ifp->name, name, sizeof(ifp->name));
-	rte_eth_macaddr_get(port_id, &ifp->hwaddr);
-	if (!router->ifnet_addrs[port_id]) {
-		free(ifp);
-		return -1;
-	}
-	addr = inet_addr(router->ifnet_addrs[port_id]); // XXX: IPv4 only for now
-	memcpy(&ifp->ipaddr, &addr, sizeof(in_addr_t));
-
-	LIST_INSERT_HEAD(&router->ifnet_list, ifp, entry);
-	router->ifnet_map[port_id] = ifp;
-
-	npfk_ifmap_attach(router->npf, ifp);
-	return 0;
-}
-
-void
-ifnet_ifdetach(npf_router_t *router, ifnet_t *ifp)
-{
-	router->ifnet_map[ifp->port_id] = NULL;
-	LIST_REMOVE(ifp, entry);
-
-	npfk_ifmap_detach(router->npf, ifp);
-	thmap_destroy(ifp->arp_cache);
-	free(ifp);
-}
-
-ifnet_t *
-ifnet_get(npf_router_t *router, const unsigned port_id)
-{
-	ASSERT(port_id < MAX_IFNET_IDS);
-	return router->ifnet_map[port_id];
-}
-
-void
-ifnet_put(ifnet_t *ifp)
-{
-	(void)ifp;
-	// release
-}
diff --git a/app/src/npf_dpdk_ops.c b/app/src/npf_dpdk_ops.c
deleted file mode 100644
index be71a4b..0000000
--- a/app/src/npf_dpdk_ops.c
+++ /dev/null
@@ -1,155 +0,0 @@
-/*
- * Copyright (c) 2015-2020 Mindaugas Rasiukevicius <rmind at noxt eu>
- * All rights reserved.
- *
- * Use is subject to license terms, as specified in the LICENSE file.
- */
-
-#include <sys/queue.h>
-#include <net/if.h>
-#include <string.h>
-
-#include <rte_common.h>
-#include <rte_mempool.h>
-#include <rte_mbuf.h>
-
-#include <net/npf.h>
-#include <net/npfkern.h>
-#include <npf.h>
-
-#include "npf_router.h"
-#include "utils.h"
-
-struct mbuf;
-
-/*
- * Virtual DPDK interfaces.
- */
-
-static const char *
-dpdk_ifop_getname(npf_t *npf __unused, ifnet_t *ifp)
-{
-	return ifp->name;
-}
-
-static ifnet_t *
-dpdk_ifop_lookup(npf_t *npf, const char *ifname)
-{
-	npf_router_t *router = npfk_getarg(npf);
-	ifnet_t *ifp;
-
-	LIST_FOREACH(ifp, &router->ifnet_list, entry) {
-		if (!strcmp(ifp->name, ifname))
-			break;
-	}
-	return ifp;
-}
-
-static void
-dpdk_ifop_flush(npf_t *npf, void *arg)
-{
-	npf_router_t *router = npfk_getarg(npf);
-	ifnet_t *ifp;
-
-	LIST_FOREACH(ifp, &router->ifnet_list, entry) {
-		ifp->arg = arg;
-	}
-}
-
-static void *
-dpdk_ifop_getmeta(npf_t *npf __unused, const ifnet_t *ifp)
-{
-	return ifp->arg;
-}
-
-static void
-dpdk_ifop_setmeta(npf_t *npf __unused, ifnet_t *ifp, void *arg)
-{
-	ifp->arg = arg;
-}
-
-/*
- * DPDK mbuf wrappers.
- */
-
-static struct mbuf *
-dpdk_mbuf_alloc(npf_t *npf, unsigned flags __unused, size_t size __unused)
-{
-	npf_router_t *router = npfk_getarg(npf);
-	return (void *)rte_pktmbuf_alloc(router->mbuf_pool);
-}
-
-static void
-dpdk_mbuf_free(struct mbuf *m0)
-{
-	struct rte_mbuf *m = (void *)m0;
-	rte_pktmbuf_free(m);
-}
-
-static void *
-dpdk_mbuf_getdata(const struct mbuf *m0)
-{
-	const struct rte_mbuf *m = (const void *)m0;
-	return rte_pktmbuf_mtod(m, void *);
-}
-
-static struct mbuf *
-dpdk_mbuf_getnext(struct mbuf *m0)
-{
-	struct rte_mbuf *m = (void *)m0;
-	return (void *)m->next;
-}
-
-static size_t
-dpdk_mbuf_getlen(const struct mbuf *m0)
-{
-	const struct rte_mbuf *m = (const void *)m0;
-	return rte_pktmbuf_data_len(m);
-}
-
-static size_t
-dpdk_mbuf_getchainlen(const struct mbuf *m0)
-{
-	const struct rte_mbuf *m = (const void *)m0;
-	return rte_pktmbuf_pkt_len(m);
-}
-
-static bool
-dpdk_mbuf_ensure_config(struct mbuf **mp, size_t len)
-{
-	struct rte_mbuf *m = (void *)*mp;
-
-	if (len > rte_pktmbuf_data_len(m) && rte_pktmbuf_linearize(m) < 0) {
-		return false;
-	}
-	return len <= rte_pktmbuf_data_len(m);
-}
-
-/*
- * NPF ops vectors.
- */
-
-static const npf_mbufops_t npf_mbufops = {
-	.alloc			= dpdk_mbuf_alloc,
-	.free			= dpdk_mbuf_free,
-	.getdata		= dpdk_mbuf_getdata,
-	.getnext		= dpdk_mbuf_getnext,
-	.getlen			= dpdk_mbuf_getlen,
-	.getchainlen		= dpdk_mbuf_getchainlen,
-	.ensure_contig		= dpdk_mbuf_ensure_config,
-	.ensure_writable	= NULL,
-};
-
-static const npf_ifops_t npf_ifops = {
-	.getname		= dpdk_ifop_getname,
-	.lookup			= dpdk_ifop_lookup,
-	.flush			= dpdk_ifop_flush,
-	.getmeta		= dpdk_ifop_getmeta,
-	.setmeta		= dpdk_ifop_setmeta,
-};
-
-npf_t *
-npf_dpdk_create(int flags, npf_router_t *router)
-{
-	return npfk_create(flags, &npf_mbufops, &npf_ifops, router);
-}
diff --git a/app/src/npf_router.c b/app/src/npf_router.c
deleted file mode 100644
index 5dafdea..0000000
--- a/app/src/npf_router.c
+++ /dev/null
@@ -1,369 +0,0 @@
-/*
- * Copyright (c) 2020 Mindaugas Rasiukevicius <rmind at noxt eu>
- * All rights reserved.
- *
- * Use is subject to license terms, as specified in the LICENSE file.
- */
-
-#include <sys/socket.h>
-#include <sys/un.h>
-
-#include <stdio.h>
-#include <stdbool.h>
-#include <unistd.h>
-#include <err.h>
-
-#include <rte_eal.h>
-#include <rte_launch.h>
-#include <rte_mempool.h>
-#include <rte_malloc.h>
-#include <rte_mbuf.h>
-#include <rte_ethdev.h>
-#include <rte_ether.h>
-#include <rte_ip.h>
-
-#include "npf_router.h"
-#include "utils.h"
-
-#define	BURST_SIZE		(256)
-#define	NUM_MBUFS		((8 * 1024) - 1)
-#define	MBUF_CACHE_SIZE		(256)
-
-static volatile sig_atomic_t	stop = false;
-
-static int	worker_fini(void *);
-static void	router_destroy(npf_router_t *);
-
-static void
-sighandler(int sig)
-{
-	(void)sig;
-	stop = true;
-}
-
-static void
-setup_signals(void)
-{
-	struct sigaction sa;
-
-	memset(&sa, 0, sizeof(struct sigaction));
-	sa.sa_handler = sighandler;
-	sigaction(SIGTERM, &sa, NULL);
-	sigaction(SIGINT, &sa, NULL);
-}
-
-static worker_t *
-get_worker_ctx(npf_router_t *router)
-{
-	const unsigned locore_id = rte_lcore_id();
-	const unsigned i = rte_lcore_index(locore_id) - 1;
-	return (i < router->worker_count) ? router->worker[i] : NULL;
-}
-
-static int
-worker_init(void *arg)
-{
-	npf_router_t *router = arg;
-	const unsigned locore_id = rte_lcore_id();
-	const unsigned i = rte_lcore_index(locore_id) - 1;
-	const int socket_id = rte_socket_id();
-	worker_t *w;
-	size_t len;
-
-	if (i >= router->worker_count) {
-		return 0;
-	}
-
-	/* Initialize the worker structure. */
-	len = offsetof(worker_t, queue[router->ifnet_count]);
-	w = rte_zmalloc_socket("worker-mm", len, 0, socket_id);
-	if ((router->worker[i] = w) == NULL) {
-		return -1;
-	}
-	w->router = router;
-	w->i = i;
-
-	/* Register the NPF worker. */
-	npfk_thread_register(router->npf);
-	w->npf = router->npf;
-
-	/*
-	 * Initialize the packet queues.
-	 */
-	for (unsigned q = 0; q < router->ifnet_count; q++) {
-		pktqueue_t *pq;
-
-		len = offsetof(worker_t, queue[router->pktqueue_size]);
-		pq = rte_zmalloc_socket("pktq-mm", len, 0, socket_id);
-		if (pq == NULL) {
-			goto err;
-		}
-		w->queue[q] = pq;
-	}
-	printf("  worker %u (lcore %u) ready\n", i, locore_id);
-	return 0;
-err:
-	worker_fini(arg);
-	return -1;
-}
-
-static int
-worker_fini(void *arg)
-{
-	npf_router_t *router = arg;
-	worker_t *worker = get_worker_ctx(router);
-
-	if (!worker) {
-		return 0;
-	}
-	npfk_thread_unregister(router->npf);
-
-	for (unsigned q = 0; q < router->ifnet_count; q++) {
-		pktqueue_t *pq = worker->queue[q];
-		rte_free(pq);
-	}
-	rte_free(worker);
-	return 0;
-}
-
-static int
-worker_run(void *arg)
-{
-	npf_router_t *router = arg;
-	worker_t *worker = get_worker_ctx(router);
-
-	if (!worker)
-		return 0;
-
-	while (!stop) {
-		uint16_t port_id;
-
-		/*
-		 * Process each interface of interest.
-		 */
-		RTE_ETH_FOREACH_DEV(port_id) {
-			if (ifnet_interesting(router, port_id)) {
-				if_input(worker, port_id);
-			}
-		}
-	}
-	return 0;
-}
-
-static int
-config_listen(const char *sockpath)
-{
-	struct sockaddr_un addr;
-	int sock;
-
-	if (unlink(sockpath) == -1 && errno != ENOENT) {
-		return -1;
-	}
-
-	if ((sock = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
-		return -1;
-	}
-
-	memset(&addr, 0, sizeof(addr));
-	strncpy(addr.sun_path, sockpath, sizeof(addr.sun_path) - 1);
-	addr.sun_family = AF_UNIX;
-
-	if (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) == -1) {
-		close(sock);
-		return -1;
-	}
-	if (listen(sock, 1024) == -1) {
-		close(sock);
-		return -1;
-	}
-	return sock;
-}
-
-static npf_router_t *
-router_create(void)
-{
-	npf_router_t *router;
-	unsigned nworkers;
-	size_t len;
-
-	if ((nworkers = rte_lcore_count()) <= 1) {
-		return NULL;
-	}
-	nworkers--; // exclude the master
-
-	/*
-	 * Allocate the router structure.
-	 */
-	len = offsetof(npf_router_t, worker[nworkers]);
-	if ((router = rte_zmalloc(NULL, len, 0)) == NULL) {
-		return NULL;
-	}
-	router->worker_count = nworkers;
-	router->pktqueue_size = BURST_SIZE;
-	LIST_INIT(&router->ifnet_list);
-
-	/*
-	 * Initialize mbuf pool.
-	 */
-	router->mbuf_pool = rte_pktmbuf_pool_create("mbuf-pl",
-	    NUM_MBUFS * MAX_IFNET_IDS, MBUF_CACHE_SIZE,
-	    RTE_CACHE_LINE_ROUNDUP(sizeof(npf_mbuf_priv_t)),
-	    RTE_MBUF_DEFAULT_BUF_SIZE, SOCKET_ID_ANY);
-	if (!router->mbuf_pool) {
-		rte_free(router);
-		return NULL;
-	}
-
-	/*
-	 * NPF instance and its operations.
-	 */
-	npfk_sysinit(1);
-
-	router->npf = npf_dpdk_create(0, router);
-	if (!router->npf) {
-		goto err;
-	}
-	if (npf_alg_icmp_init(router->npf) != 0) {
-		goto err;
-	}
-	router->config_sock = config_listen(NPF_CONFSOCK_PATH);
-	if (router->config_sock == -1) {
-		goto err;
-	}
-	router->rtable = route_table_create();
-	if (!router->rtable) {
-		goto err;
-	}
-	return router;
-err:
-	router_destroy(router);
-	return NULL;
-}
-
-static void
-router_destroy(npf_router_t *router)
-{
-	if (router->config_sock > 0) {
-		close(router->config_sock);
-	}
-	for (unsigned i = 0; i < MAX_IFNET_IDS; i++) {
-		ifnet_t *ifp;
-
-		if ((ifp = router->ifnet_map[i]) != NULL) {
-			ifnet_ifdetach(router, ifp);
-		}
-		free(router->ifnet_addrs[i]);
-	}
-	if (router->rtable) {
-		route_table_destroy(router->rtable);
-	}
-	if (router->npf) {
-		npf_alg_icmp_fini(router->npf);
-		npfk_destroy(router->npf);
-	}
-	npfk_sysfini();
-	rte_free(router);
-}
-
-int
-main(int argc, char **argv)
-{
-	npf_router_t *router;
-	unsigned lcore_id, port_id;
-
-	puts("- Initializing DPDK");
-	if (rte_eal_init(argc, argv) == -1) {
-		rte_exit(EXIT_FAILURE, "rte_eal_init() failed");
-	}
-	setup_signals();
-
-	/*
-	 * Setup the NPF router configuration.
-	 */
-	puts("- Initializing NPF");
-	if ((router = router_create()) == NULL) {
-		errx(EXIT_FAILURE, "router_create() failed");
-	}
-
-	/*
-	 * Load the configuration.
-	 */
-	if (load_config(router) == -1) {
-		errx(EXIT_FAILURE, "failed to load the configuration");
-	}
-
-	/*
-	 * Initialize network interfaces.
-	 */
-	puts("- Initializing network interfaces");
-	RTE_ETH_FOREACH_DEV(port_id) {
-		if (!ifnet_interesting(router, port_id)) {
-			continue;
-		}
-		if (ifnet_setup(router, port_id, router->worker_count) == -1) {
-			rte_exit(EXIT_FAILURE, "ifnet_setup");
-		}
-		if (ifnet_ifattach(router, port_id) == -1) {
-			rte_exit(EXIT_FAILURE, "ifnet_ifattach");
-		}
-		printf("  configured network interface %u\n", port_id);
-		router->ifnet_count++;
-	}
-	if (router->ifnet_count == 0) {
-		errx(EXIT_FAILURE, "no routable interfaces; exiting. ");
-	}
-	ASSERT(router->ifnet_count < MAX_IFNET_IDS);
-
-	/*
-	 * Initialize all workers.
-	 */
-	puts("- Initializing workers");
-	RTE_LCORE_FOREACH_SLAVE(lcore_id) {
-		rte_eal_remote_launch(worker_init, router, lcore_id);
-	}
-	RTE_LCORE_FOREACH_SLAVE(lcore_id) {
-		if (rte_eal_wait_lcore(lcore_id) == -1) {
-			rte_exit(EXIT_FAILURE, "worker_init");
-		}
-	}
-
-	/*
-	 * Spin up the worker processing.
-	 */
-	puts("- Starting router");
-	RTE_LCORE_FOREACH_SLAVE(lcore_id) {
-		rte_eal_remote_launch(worker_run, router, lcore_id);
-	}
-
-	/*
-	 * Master process will handle the configuration updates.
-	 */
-	while (!stop) {
-		int sock;
-
-		sock = accept(router->config_sock, NULL, NULL);
-		if (sock == -1) {
-			if (errno == EINTR) {
-				continue;
-			}
-			err(EXIT_FAILURE, "accept");
-		}
-		puts("- NPF configuration control call");
-		if (npfk_socket_load(router->npf, sock) == -1) {
-			warnx("npfk_socket_load");
-		}
-		close(sock);
-	}
-	rte_eal_mp_wait_lcore();
-
-	/*
-	 * Destroy the NPF router resources.
-	 */
-	puts("- Exiting");
-	RTE_LCORE_FOREACH_SLAVE(lcore_id) {
-		rte_eal_remote_launch(worker_fini, router, lcore_id);
-	}
-	rte_eal_mp_wait_lcore();
-	router_destroy(router);
-	return 0;
-}
diff --git a/app/src/npf_router.h b/app/src/npf_router.h
deleted file mode 100644
index 409fcda..0000000
--- a/app/src/npf_router.h
+++ /dev/null
@@ -1,134 +0,0 @@
-/*
- * Copyright (c) 2020 Mindaugas Rasiukevicius <rmind at noxt eu>
- * All rights reserved.
- *
- * Use is subject to license terms, as specified in the LICENSE file.
- */
-
-#ifndef _NPF_ROUTER_H_
-#define _NPF_ROUTER_H_
-
-#include <sys/queue.h>
-#include <inttypes.h>
-
-#include <rte_ether.h>
-#include <thmap.h>
-
-#include <net/if.h>
-#include <net/npf.h>
-#include <net/npfkern.h>
-
-struct ifnet;
-struct worker;
-
-typedef struct route_table route_table_t;
-
-#define	NPF_CONFSOCK_PATH	"/dev/npf"
-
-#define	MAX_IFNET_IDS		(32) // XXX: hardcoded, e.g. worker_t::bitmap
-
-/*
- * NPF router structures.
- */
-
-typedef struct {
-	unsigned		if_idx;
-	unsigned		addr_len;
-	npf_addr_t		next_hop;
-} route_info_t;
-
-#define	MBUF_NPF_NEED_L2	0x01
-
-typedef struct {
-	unsigned		flags;
-	unsigned		ether_type;
-	route_info_t		route;
-} npf_mbuf_priv_t;
-
-typedef struct ifnet {
-	unsigned		port_id;
-
-	npf_addr_t		ipaddr;
-	struct ether_addr	hwaddr;
-
-	void *			arg;
-	LIST_ENTRY(ifnet)	entry;
-
-	thmap_t *		arp_cache;
-	char			name[IF_NAMESIZE];
-} ifnet_t;
-
-typedef struct npf_router {
-	npf_t *			npf;
-	int			config_sock;
-	struct rte_mempool *	mbuf_pool;
-	unsigned		pktqueue_size;
-	route_table_t *		rtable;
-
-	/*
-	 * Interface list, map, count as well as bitmap.
-	 */
-	LIST_HEAD(, ifnet)	ifnet_list;
-	unsigned		ifnet_count;
-	uint32_t		ifnet_bitset;
-	ifnet_t *		ifnet_map[MAX_IFNET_IDS];
-	char *			ifnet_addrs[MAX_IFNET_IDS];
-
-	unsigned		worker_count;
-	struct worker *		worker[];
-} npf_router_t;
-
-typedef struct {
-	unsigned		count;
-	struct rte_mbuf *	pkt[];
-} pktqueue_t;
-
-typedef struct worker {
-	unsigned		i;
-	npf_t *			npf;
-	npf_router_t *		router;
-
-	uint32_t		bitmap;
-	pktqueue_t *		queue[];
-} worker_t;
-
-/*
- * NPF DPDK operations, network interface and configuration loading.
- */
-
-npf_t *		npf_dpdk_create(int, npf_router_t *);
-
-int		ifnet_setup(npf_router_t *, const unsigned, const unsigned);
-int		ifnet_register(npf_router_t *, const char *);
-bool		ifnet_interesting(npf_router_t *, const unsigned);
-
-int		ifnet_ifattach(npf_router_t *, const unsigned);
-void		ifnet_ifdetach(npf_router_t *, ifnet_t *);
-ifnet_t *	ifnet_get(npf_router_t *, const unsigned);
-void		ifnet_put(ifnet_t *);
-
-int		load_config(npf_router_t *);
-
-/*
- * Routing and ARP.
- */
-
-route_table_t *	route_table_create(void);
-void		route_table_destroy(route_table_t *);
-
-int		route_add(route_table_t *, const void *, unsigned, unsigned,
-		    const route_info_t *);
-int		route_lookup(route_table_t *, const void *, unsigned,
-		    route_info_t *);
-
-int		arp_resolve(worker_t *, const route_info_t *, struct ether_addr *);
-int		arp_input(worker_t *, struct rte_mbuf *, const unsigned);
-
-/*
- * Worker / processing.
- */
-
-int		pktq_enqueue(worker_t *, unsigned, struct rte_mbuf *);
-void		if_input(worker_t *, const unsigned);
-
-#endif
diff --git a/app/src/route.c b/app/src/route.c
deleted file mode 100644
index 2867458..0000000
--- a/app/src/route.c
+++ /dev/null
@@ -1,85 +0,0 @@
-/*
- * Copyright (c) 2020 Mindaugas Rasiukevicius <rmind at noxt eu>
- * All rights reserved.
- *
- * Use is subject to license terms, as specified in the LICENSE file.
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <inttypes.h>
-
-#include <lpm.h>
-
-#include "npf_router.h"
-#include "utils.h"
-
-struct route_table {
-	lpm_t *		lpm;
-	unsigned	nitems;
-};
-
-typedef struct rtentry {
-	unsigned	flags;
-	route_info_t	rt;
-} rtentry_t;
-
-route_table_t *
-route_table_create(void)
-{
-	route_table_t *rtbl;
-
-	rtbl = calloc(1, sizeof(route_table_t));
-	if (rtbl == NULL) {
-		return NULL;
-	}
-	rtbl->lpm = lpm_create();
-	return rtbl;
-}
-
-static void
-route_table_dtor(void *arg __unused, const void *key __unused,
-    size_t len __unused, void *val)
-{
-	free(val);
-}
-
-void
-route_table_destroy(route_table_t *rtbl)
-{
-	lpm_clear(rtbl->lpm, route_table_dtor, NULL);
-	lpm_destroy(rtbl->lpm);
-	free(rtbl);
-}
-
-int
-route_add(route_table_t *rtbl, const void *addr, unsigned alen,
-    unsigned preflen, const route_info_t *rt)
-{
-	rtentry_t *rtentry;
-
-	if ((rtentry = calloc(1, sizeof(rtentry_t))) == NULL) {
-		return -1;
-	}
-	memcpy(&rtentry->rt, rt, sizeof(route_info_t));
-
-	if (lpm_insert(rtbl->lpm, addr, alen, preflen, rtentry) == -1) {
-		free(rtentry);
-		return -1;
-	}
-	return 0;
-}
-
-int
-route_lookup(route_table_t *rtbl, const void *addr, unsigned alen,
-    route_info_t *output_rt)
-{
-	rtentry_t *rtentry;
-
-	rtentry = lpm_lookup(rtbl->lpm, addr, alen);
-	if (rtentry == NULL) {
-		return -1;
-	}
-	memcpy(output_rt, &rtentry->rt, sizeof(route_info_t));
-	return 0;
-}
diff --git a/app/src/utils.h b/app/src/utils.h
deleted file mode 100644
index f6675fd..0000000
--- a/app/src/utils.h
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Copyright (c) 2020 Mindaugas Rasiukevicius <rmind at noxt eu>
- * All rights reserved.
- *
- * Use is subject to license terms, as specified in the LICENSE file.
- */
-
-#ifndef _UTILS_H_
-#define _UTILS_H_
-
-#include <assert.h>
-
-/*
- * A regular assert (debug/diagnostic only).
- */
-
-#if defined(DEBUG)
-#define	ASSERT		assert
-#else
-#define	ASSERT(x)
-#endif
-
-/*
- * Branch prediction macros.
- */
-
-#ifndef __predict_true
-#define	__predict_true(x)	__builtin_expect((x) != 0, 1)
-#define	__predict_false(x)	__builtin_expect((x) != 0, 0)
-#endif
-
-/*
- * Various C helpers and attribute macros.
- */
-
-#ifndef __unused
-#define	__unused		__attribute__((__unused__))
-#endif
-
-#ifndef __arraycount
-#define	__arraycount(__x)	(sizeof(__x) / sizeof(__x[0]))
-#endif
-
-void	dump_eth_addr(const char *, const struct ether_addr *);
-void	dump_ip4_addr(const char *, int, const void *);
-void	dump_pkt(char, const struct rte_mbuf *);
-
-#endif
diff --git a/app/src/worker.c b/app/src/worker.c
deleted file mode 100644
index f78f8a9..0000000
--- a/app/src/worker.c
+++ /dev/null
@@ -1,335 +0,0 @@
-/*
- * Copyright (c) 2020 Mindaugas Rasiukevicius <rmind at noxt eu>
- * All rights reserved.
- *
- * Use is subject to license terms, as specified in the LICENSE file.
- */
-
-/*
- * Worker of the NPF-router.
- */
-
-#include <stdio.h>
-#include <arpa/inet.h>
-
-#include <rte_eal.h>
-#include <rte_launch.h>
-#include <rte_mempool.h>
-#include <rte_malloc.h>
-#include <rte_mbuf.h>
-#include <rte_ethdev.h>
-#include <rte_ether.h>
-#include <rte_ip.h>
-
-#include "npf_router.h"
-#include "utils.h"
-
-static int
-firewall_process(npf_t *npf, struct rte_mbuf **mp, ifnet_t *ifp, const int di)
-{
-	int error;
-
-	error = npfk_packet_handler(npf, (struct mbuf **)mp, ifp, di);
-
-	/* Note: NPF may consume the packet. */
-	if (error || *mp == NULL) {
-		if (*mp) {
-			rte_pktmbuf_free(*mp);
-		}
-		return -1;
-	}
-	return 0;
-}
-
-static int
-if_output(worker_t *worker, unsigned if_idx, struct rte_mbuf *m)
-{
-	const npf_mbuf_priv_t *minfo = rte_mbuf_to_priv(m);
-	struct ether_hdr *eh;
-	ifnet_t *ifp;
-
-	/*
-	 * If the packet already has L2 header, then nothing more to do.
-	 */
-	if ((minfo->flags & MBUF_NPF_NEED_L2) == 0) {
-		return 0;
-	}
-
-	if ((ifp = ifnet_get(worker->router, if_idx)) == NULL) {
-		return -1; // drop
-	}
-
-	/*
-	 * Add the Ethernet header.
-	 */
-	ASSERT(m->l2_len == ETHER_HDR_LEN);
-	eh = (void *)rte_pktmbuf_prepend(m, ETHER_HDR_LEN);
-	if (eh == NULL) {
-		ifnet_put(ifp);
-		return -1; // drop
-	}
-	ether_addr_copy(&ifp->hwaddr, &eh->s_addr);
-	ifnet_put(ifp);
-
-	/*
-	 * Perform ARP resolution.
-	 */
-	if (arp_resolve(worker, &minfo->route, &eh->d_addr) == -1) {
-		return -1; // drop
-	}
-	eh->ether_type = minfo->ether_type;
-	return 0;
-}
-
-/*
- * pkt_enqueue: enqueue the packet for TX.
- */
-int
-pktq_enqueue(worker_t *worker, unsigned if_idx, struct rte_mbuf *m)
-{
-	const unsigned pktq_size = worker->router->pktqueue_size;
-	pktqueue_t *pq;
-
-	ASSERT(if_idx < worker->router->ifnet_count);
-	pq = worker->queue[if_idx];
-
-	if (__predict_false(pq->count >= pktq_size)) {
-		return -1; // drop
-	}
-	if (if_output(worker, if_idx, m) == -1) {
-		return -1; // drop
-	}
-	worker->bitmap |= (1U << if_idx);
-	pq->pkt[pq->count++] = m;
-	return 0;
-}
-
-static unsigned
-pktq_tx(worker_t *worker, const unsigned if_idx)
-{
-	pktqueue_t *pq = worker->queue[if_idx];
-	const unsigned pktcount = pq->count;
-	unsigned sent;
-
-	/* Send a burst of packets. */
-	sent = rte_eth_tx_burst(if_idx, worker->i, pq->pkt, pktcount);
-
-	/* Destroy any remaining packets. */
-	for (unsigned i = sent; i < pktcount; i++) {
-		rte_pktmbuf_free(pq->pkt[i]);
-		pq->pkt[i] = NULL;
-	}
-	pq->count = 0;
-	return sent;
-}
-
-static void
-pktq_tx_all(worker_t *worker)
-{
-	unsigned if_idx;
-
-	while ((if_idx = ffs(worker->bitmap)) != 0) {
-		if_idx--;
-
-		/*
-		 * Transmit the queue (send a burst of packets).
-		 */
-		pktq_tx(worker, if_idx);
-
-		/* Next .. */
-		worker->bitmap &= ~(1U << if_idx);
-	}
-	ASSERT(worker->bitmap == 0);
-}
-
-static int
-l2_input(worker_t *worker, struct rte_mbuf *m, const unsigned if_idx)
-{
-	npf_mbuf_priv_t *minfo = rte_mbuf_to_priv(m);
-	const struct ether_hdr *eh;
-
-	/*
-	 * Do we have an L2 header?  If not, then nothing to do.
-	 */
-	if ((m->packet_type & RTE_PTYPE_L2_MASK) == 0) {
-		return 0;
-	}
-
-	/*
-	 * We have an L2 header, which must be Ethernet.  Save it in the
-	 * mbuf private area for later pre-pending.
-	 */
-
-	eh = rte_pktmbuf_mtod(m, const struct ether_hdr *);
-	minfo->ether_type = eh->ether_type;
-
-	ASSERT(sizeof(struct ether_hdr) == ETHER_HDR_LEN);
-	m->l2_len = ETHER_HDR_LEN;
-
-	switch (ntohs(eh->ether_type)) {
-	case ETHER_TYPE_ARP:
-		return arp_input(worker, m, if_idx);
-	default:
-		break;
-	}
-
-	/*
-	 * Remove the L2 header as we are preparing for L3 processing.
-	 */
-	rte_pktmbuf_adj(m, sizeof(struct ether_hdr));
-	minfo->flags |= MBUF_NPF_NEED_L2;
-	return 0;
-}
-
-/*
- * ip_route: find a route for the IPv4/IPv6 packet.
- */
-static int
-ip_route(npf_router_t *router, struct rte_mbuf *m)
-{
-	npf_mbuf_priv_t *minfo = rte_mbuf_to_priv(m);
-	route_info_t *rt = &minfo->route;
-	const void *addr;
-	unsigned alen;
-
-	/*
-	 * Determine whether it is IPv4 or IPv6 packet.
-	 */
-	if (RTE_ETH_IS_IPV4_HDR(m->packet_type)) {
-		const struct ipv4_hdr *ip4;
-
-		ip4 = rte_pktmbuf_mtod(m, const struct ipv4_hdr *);
-		addr = &ip4->dst_addr;
-		alen = sizeof(ip4->dst_addr);
-		m->ol_flags |= (PKT_TX_IPV4 | PKT_TX_IP_CKSUM);
-
-		if (ip4->time_to_live <= 1) {
-			/* ICMP_TIMXCEED */
-			return -1;
-		}
-		/* TODO: ip4->time_to_live--; */
-
-	} else if (RTE_ETH_IS_IPV6_HDR(m->packet_type)) {
-		const struct ipv6_hdr *ip6;
-
-		ip6 = rte_pktmbuf_mtod(m, const struct ipv6_hdr *);
-		addr = &ip6->dst_addr;
-		alen = sizeof(ip6->dst_addr);
-		m->ol_flags |= (PKT_TX_IPV6 | PKT_TX_IP_CKSUM);
-
-		if (ip6->hop_limits <= 1) {
-			/* ICMP_TIMXCEED */
-			return -1;
-		}
-		/* TODO: ip6->hop_limits--; */
-
-	} else {
-		return -1;
-	}
-
-	/*
-	 * Lookup the route and get the interface and next hop.
-	 */
-	if (route_lookup(router->rtable, addr, alen, rt) == -1) {
-		return -1;
-	}
-	if (!rt->addr_len) {
-		/*
-		 * There is next-hop specified with route, so it will be
-		 * the destination address.
-		 */
-		memcpy(&rt->next_hop, addr, alen);
-		rt->addr_len = alen;
-	}
-	return rt->if_idx;
-}
-
-static int
-ip_output(worker_t *worker, struct rte_mbuf *m, const unsigned if_idx)
-{
-	ifnet_t *ifp;
-	int ret;
-
-	/*
-	 * Firewall -- outbound.
-	 */
-	if ((ifp = ifnet_get(worker->router, if_idx)) == NULL) {
-		rte_pktmbuf_free(m);
-		return -1;
-	}
-	ret = firewall_process(worker->npf, &m, ifp, PFIL_OUT);
-	ifnet_put(ifp);
-	if (ret) {
-		/* Consumed or dropped. */
-		return 0;
-	}
-
-	/*
-	 * Enqueue for the destination interface.
-	 */
-	if (pktq_enqueue(worker, if_idx, m) == -1) {
-		rte_pktmbuf_free(m);
-		return -1;
-	}
-	return 0;
-}
-
-void
-if_input(worker_t *worker, const unsigned rx_if_idx)
-{
-	const unsigned burst_size = worker->router->pktqueue_size;
-	struct rte_mbuf *mbufs[burst_size];
-	ifnet_t *rx_ifp;
-	unsigned npkts;
-
-	/* Get a burst of packets on this interface. */
-	if ((rx_ifp = ifnet_get(worker->router, rx_if_idx)) == NULL) {
-		return; // raced with interface detach
-	}
-	npkts = rte_eth_rx_burst(rx_if_idx, worker->i, mbufs, burst_size);
-	if (__predict_false(npkts == 0)) {
-		ifnet_put(rx_ifp);
-		return; // nothing to do here
-	}
-
-	/*
-	 * Route each packet.
-	 */
-	worker->bitmap = 0;
-	for (unsigned i = 0; i < npkts; i++) {
-		struct rte_mbuf *m = mbufs[i];
-		int if_idx;
-
-		/*
-		 * L2 processing.
-		 */
-		if (l2_input(worker, m, rx_if_idx)) {
-			/* Consumed (dropped or re-enqueued). */
-			continue;
-		}
-
-		/*
-		 * Firewall -- inbound.
-		 */
-		if (firewall_process(worker->npf, &m, rx_ifp, PFIL_IN)) {
-			/* Consumed or dropped. */
-			continue;
-		}
-
-		/*
-		 * L3 routing.
-		 */
-		if ((if_idx = ip_route(worker->router, m)) == -1) {
-			/* Packet could not be routed -- drop it. */
-			rte_pktmbuf_free(m);
-			continue;
-		}
-		(void)ip_output(worker, m, if_idx);
-	}
-	ifnet_put(rx_ifp);
-
-	/*
-	 * Send packets on the destination interfaces.
-	 */
-	pktq_tx_all(worker);
-}
diff --git a/docs/README.md b/docs/README.md
deleted file mode 100644
index 3d6d69b..0000000
--- a/docs/README.md
+++ /dev/null
@@ -1,14 +0,0 @@
-# NPF documentation
-
-Table of contents:
-- [Introduction](intro.md)
-  - [Mode of operation](intro.md#mode-of-operation)
-  - [Brief notes on design](intro.md#brief-notes-on-design)
-  - [Processing](intro.md#processing)
-- [Configuration](configuration.md)
-  - [Structure and syntax](configuration.md#structure-and-syntax)
-  - [Control and operation](configuration.md#control-and-operation)
-- [Dynamic rules](dynamic_rules.md)
-- [Stateful filtering](stateful.md)
-- [Network address translation](nat.md)
-- [Extensions API](extensions.md)
diff --git a/docs/_config.yml b/docs/_config.yml
deleted file mode 100644
index 4dadc91..0000000
--- a/docs/_config.yml
+++ /dev/null
@@ -1,4 +0,0 @@
-theme: jekyll-theme-cayman
-plugins:
-   - jekyll-readme-index
-   - jekyll-sitemap
diff --git a/docs/configuration.md b/docs/configuration.md
deleted file mode 100644
index 0477b2e..0000000
--- a/docs/configuration.md
+++ /dev/null
@@ -1,382 +0,0 @@
-# Configuration
-
-This chapter will describe NPF configuration in the context of NetBSD
-or a similar UNIX-like system environment.
-
-The standalone NPF configuration would be constructed using the `libnpf`
-library and submitted to the kernel-side component, using the `npfkern`
-library.  See the libnpf(3) and npfkern(3) manual pages for the API.
-
----
-NetBSD beginners can consult
-[rc(8)](http://man.netbsd.org/cgi-bin/man-cgi?rc+8+NetBSD-current),
-[rc.conf(5)](http://man.netbsd.org/cgi-bin/man-cgi?rc.conf+5+NetBSD-current),
-[ifconfig.if(5)](http://man.netbsd.org/cgi-bin/man-cgi?ifconfig.if+5+NetBSD-current),
-[route(8)](http://man.netbsd.org/cgi-bin/man-cgi?route+8+NetBSD-current)
-and other manual pages for the general networking configuration in the system.
-
----
-
-## Structure and syntax
-
-The NPF configuration is represented by a file, called `npf.conf` (the
-default location is `/etc/npf.conf`).  It is loaded and NPF is generally
-operated via the command line utility called `npfctl`.  For a reference,
-use
-[npf.conf(5)](http://man.netbsd.org/cgi-bin/man-cgi?npf.conf+5+NetBSD-current)
-and
-[npfctl(8)](http://man.netbsd.org/cgi-bin/man-cgi?npfctl+8+NetBSD-current)
-manual pages.
-
-There are multiple structural elements that `npf.conf` may contain, such as:
-- variables
-- table definitions (with or without content)
-- abstraction groups
-- packet filtering rules
-- map rules for address translation
-- application level gateways
-- procedure definitions to call on filtered packets.
-
-### Variables
-
-Variables are specified using the dollar (`$`) sign, which is used for both
-definition and referencing of a variable.  Variables are defined by
-assigning a value to them as follows:
-```
-$var1 = 10.0.0.1
-```
-A variable may also be defined as a set:
-```
-$var2 = { 10.0.0.1, 10.0.0.2 }
-```
-
-Common variable definitions are for IP addresses, networks, ports, and
-interfaces.
-
-### Tables
-
-Tables are specified using a name between angle brackets `<` and `>`.
-The following is an example of table definition:
-```
-table <blocklist> type ipset
-```
-
-Currently, tables support three data storage types: `ipset`, `lpm`, or `const`.
-The contents of the table may be pre-loaded from the specified file.
-The `const` tables are immutable (no insertions or deletions after loading)
-and therefore must always be loaded from a file.
-
-The specified file should contain a list of IP addresses and/or networks
-in the form of 10.1.1.1 or 10.0.0.0/24
-
-Tables of type `ipset` and `const` can only contain IP addresses.  The `lpm`
-tables can contain networks and they will perform the longest prefix match
-on lookup.
-
-### Interfaces
-
-In NPF, an interface can be referenced directly by using its name, or can
-be passed to an extraction function which will return a list of IP
-addresses configured on the actual associated interface.
-
-It is legal to pass an extracted list from an interface in keywords where
-NPF would expect instead a direct reference to said interface.  In this
-case, NPF infers a direct reference to the interface, and does not con
-sider the list.
-
-There are two types of IP address lists.  With a static list, NPF will
-capture the interface addresses on configuration load, whereas with a
-dynamic list NPF will capture the runtime list of addresses, reflecting
-any changes to the interface, including the attach and detach.  Note that
-with a dynamic list, bringing the interface down has no effect, all
-addresses will remain present.
-
-The following functions exist, to extract addresses from an interface with
-a chosen list type and IP address type:
-
-| Function | Type | Description |
-| -------------------- | ------------ | -------------- |
-| `inet4(interface)`   | static list  | IPv4 addresses |
-| `inet6(interface)`   | static list  | IPv6 addresses |
-| `ifaddrs(interface)` | dynamic list | Both IPv4 and IPv6.  The family keyword of a filtering rule can be used in combination to explicitly select an IP address type. |
-
-Example of configuration:
-```
-$var1 = inet4(wm0)
-$var2 = ifaddrs(wm0)
-
-group default {
-  block in on wm0 all               # rule 1
-  block in on $var1 all             # rule 2
-  block in on inet4(wm0) all        # rule 3
-  pass in on inet6(wm0) from $var2  # rule 4
-  pass in on wm0 from ifaddrs(wm0)  # rule 5
-}
-```
-
-In the above example, $var1 is the static list of IPv4 addresses configured
-on wm0, and $var2 is the dynamic list of all the IPv4 and IPv6
-addresses configured on wm0.  The first three rules are equivalent,
-because with the `block ... on <interface>` syntax, NPF expects a direct
-reference to an interface, and therefore does not consider the extraction
-functions.  The fourth and fifth rules are equivalent, for the same reason.
-
-### Groups
-
-NPF requires that all rules be defined within groups.  Groups can be
-thought of as higher level rules which can contain subrules.  Groups may
-have the following options: name, interface, and direction.  Packets
-matching group criteria are passed to the ruleset of that group.  If a
-packet does not match any group, it is passed to the default group.  The
-default group must always be defined.
-
-Example of configuration:
-```
-group "myname" in on wm0 {
-  # List of rules, for packets received on wm0
-}
-
-group default {
-  # List of rules, for the other packets
-}
-```
-
-### Rules
-
-With a rule statement NPF is instructed to `pass` or `block` a packet
-depending on packet header information, transit direction and the interface it
-arrived on, either immediately upon match or using the last match.
-
-If a packet matches a rule which has the `final` option set, this rule is
-considered the last matching rule, and evaluation of subsequent rules is
-skipped.  Otherwise, the last matching rule is used.
-
-The `proto` keyword can be used to filter packets by layer 4 protocol (TCP,
-UDP, ICMP or other).  Its parameter should be a protocol number or its
-symbolic name, as specified in the `/etc/protocols` file.  This keyword can
-additionally have protocolspecific options, such as `flags`.
-
-The `flags` keyword can be used to match the packets against specific TCP
-flags, according to the following syntax:
-```
-proto tcp flags match[/mask]
-```
-
-Where match is the set of TCP flags to be matched, out of the mask set,
-both sets being represented as a string combination of: `S` (SYN), `A`
-(ACK), `F` (FIN), and `R` (RST).  The flags that are not present in _mask_
-are ignored.
-
-To notify the sender of a blocking decision, three return options can be
-used in conjunction with a block rule:
-
-| Keyword | Description |
-| --- | --- |
-| `return` | Behaves as returnrst or returnicmp, depending on whether the packet being blocked is TCP or UDP. |
-| `returnrst` | Return a TCP RST message, when the packet being blocked is a TCP packet.  Applies to IPv4 and IPv6. |
-| `returnicmp` | Return an ICMP UNREACHABLE message, when the packet being blocked is a UDP packet.  Applies to IPv4 and IPv6. |
-
-Further packet specification at present is limited to TCP and UDP under
-standing source and destination ports, and ICMP and IPv6ICMP understand
-ing icmptype.
-
-A rule can also instruct NPF to create an entry in the state table when
-passing the packet or to apply a procedure to the packet (e.g. "log").
-
-A "fullyfeatured" rule would for example be:
-```
-pass stateful in final family inet4 proto tcp flags S/SA \
-  from $source port $sport to $dest port $dport apply "someproc"
-```
-
-Alternatively, NPF supports
-[pcap-filter(7)](http://man.netbsd.org/cgi-bin/man-cgi?pcap-filter+7+NetBSD-current)
-syntax, for example:
-```
-block out final pcapfilter "tcp and dst 10.1.1.252"
-```
-
-Fragments are not selectable since NPF always reassembles packets before
-further processing.
-
-### Stateful
-
-Stateful packet inspection is enabled using the `stateful` or `statefulends`
-keywords.  The former creates a state which is uniquely identified by a
-5tuple (source and destination IP addresses, port numbers and an inter
-face identifier).  The latter excludes the interface identifier and must
-be used with precaution.  In both cases, a full TCP state tracking is
-performed for TCP connections and a limited tracking for messagebased
-protocols (UDP and ICMP).
-
-By default, a stateful rule implies SYNonly flag check ("flags S/SAFR")
-for the TCP packets.  It is not advisable to change this behavior; how
-ever, it can be overridden with the aforementioned `flags` keyword.
-
-### Map
-
-Network Address Translation (NAT) is expressed in a form of segment map
-ping.  The translation may be dynamic (stateful) or static (stateless).
-The following mapping types are available:
-
-| Syntax | Description |
-|:------:| --- |
-| `>`   | outbound NAT (translation of the source) |
-| `<`   | inbound NAT (translation of the destination) |
-| `<>`  | bidirectional NAT (combination of inbound and outbound NAT) |
-
-The following would translate the source (10.1.1.0/24) to the IP address
-specified by `$pub_ip` for the packets on the interface `$ext_if`.
-```
-map $ext_if dynamic 10.1.1.0/24 > $pub_ip
-```
-
-Translations are implicitly filtered by limiting the operation to the
-network segments specified, that is, translation would be performed only
-on packets originating from the 10.1.1.0/24 network.  Explicit filter
-criteria can be specified using `pass criteria ...` as an additional option
-of the mapping.
-
-The dynamic NAT implies network address and port translation (NAPT).  The
-port translation can be controlled explicitly.  For example, the following
-provides "port forwarding", redirecting the public port 9022 to the
-port 22 of an internal host:
-```
-map $ext_if dynamic proto tcp 10.1.1.2 port 22 < $ext_if port 9022
-```
-
-If the dynamic NAT is configured with multiple translation addresses,
-then a custom selection algorithm can be chosen using the `algo` keyword.
-The currently available algorithms are:
-
-| Algorithm | Description |
-|:---------:| --- |
-| `ip-hash` | The translation address for a new connection is selected based on a hash of the original source and destination addresses. This algorithms attempts to keep all connections of particular client associated with the same translation address. This is the default algorithm. |
-| `round-robin` | The translation address for each new connection is selected on a round-robin basis. |
-
-The static NAT can also have different address translation algorithms,
-chosen using the `algo` keyword.  The currently available algorithms are:
-
-| Algorithm | Description |
-|:---------:| --- |
-| `netmap`  | Network address mapping from one segment to another, leaving the host part as-is. The new address is computed as following: `addr = net-addr | (orig-addr & ~mask)` |
-| `npt66`   | IPv6toIPv6 network prefix translation (NPTv6) |
-
-If no algorithm is specified, then 1:1 address mapping is assumed.
-Currently, the static NAT algorithms do not perform port translation.
-
-### Application Level Gateways
-
-Certain application layer protocols are not compatible with NAT and
-require translation outside layers 3 and 4.  Such translation is per
-formed by packet filter extensions called Application Level Gateways
-(ALGs).
-
-NPF supports the following ALGs:
-- ICMP ALG (keyword `icmp`): Applies to IPv4 and IPv6.  Allows to find an
-  active connection by looking at the ICMP payload, and to perform NAT
-  translation of the ICMP payload.  Generally, this ALG is necessary to
-  support `traceroute(8)` behind the NAT, when using the UDP or TCP probes.
-
-The ALGs are builtin.  If NPF is used as kernel module, then they come
-as kernel modules too.  In such case, the ALG kernel modules can be
-autoloaded through the configuration, using the `alg` keyword.
-
-For example:
-```
-alg "icmp"
-```
-
-Alternatively, the ALG kernel modules can be loaded manually, using
-`modload(8)`.
-
-### Procedures
-
-A rule procedure is defined as a collection of extension calls (it may
-have none).  Every extension call has a name and a list of options in the
-form of keyvalue pairs.  Depending on the call, the key might represent
-the argument and the value might be optional.  Available options:
-- `log: interface`: Log events. This requires the `npf_ext_log`
-  kernel module, which would normally get auto loaded by NPF.  The specified
-  npflog interface would also be autocreated once the configuration is loaded.
-  The log packets can be written to a file using the `npfd(8)` daemon.
-- `normalize: option1[, option2 ...]`: Modify packets according to the
-  specified normalization options.  This requires the `npf_ext_normalize`
-  kernel module, which would normally get autoloaded by NPF.
-
-The available normalization options are:
-
-| Parameter | Description |
-| --- | --- |
-| `maxmss <value>` | Enforce a maximum value for the Maximum Segment Size (MSS) TCP option.  Typically, for "MSS clamping".
-| `minttl <value>` | Enforce a minimum value for the IPv4 Time To Live (TTL) parameter.
-| `nodf` | Remove the Don't Fragment (DF) flag from IPv4 packets.
-| `randomid` | Randomize the IPv4 ID parameter. |
-
-For example:
-```
-procedure "someproc" {
-  log: npflog0
-  normalize: "randomid", "minttl" 64, "maxmss" 1432
-}
-```
-
-In this case, the procedure calls the logging and normalization modules.
-
-### Misc
-
-Text after a hash (`#`) character is considered a comment.  The backslash
-(`\`) character at the end of a line marks a continuation line, i.e., the
-next line is considered an extension of the present line.
-
-## Control and operation
-
-NPF is controlled using the
-[npfctl(8)](http://man.netbsd.org/cgi-bin/man-cgi?npfctl+8+NetBSD-current)
-utility.
-```
-$ npfctl
-Usage:	npfctl start | stop | flush | show | stats
-	npfctl validate | reload [<rule-file>]
-	npfctl rule "rule-name" { add | rem } <rule-syntax>
-	npfctl rule "rule-name" rem-id <rule-id>
-	npfctl rule "rule-name" { list | flush }
-	npfctl table "table-name" { add | rem | test } <address/mask>
-	npfctl table "table-name" { list | flush }
-	npfctl table "table-name" replace [-n "name"] [-t <type>] <table-file>
-	npfctl save | load
-	npfctl list [-46hNnw] [-i <ifname>]
-	npfctl debug [<rule-file>] [<raw-output>]
-```
-
-Once the NPF configuration file has been written, use `npfctl` to load it
-and then start the packet handling:
-```
-$ npfctl load
-$ npfctl start
-```
-
-Any modifications of npf.conf require reloading of the ruleset by performing
-a `reload` command in order to make the changes active.  One difference from
-other packet filters is the behaviour of the `start` and `stop` commands.
-These commands do not actually change (i.e. load or unload) the active
-configuration.  Running `start` will only enable the passing of packets
-through NPF, while `stop` will disable such passing.  Therefore,
-configuration should first be activated using the `reload` command and then
-filtering enabled with `start`.  Similarly, clearing of the active
-configuration is done by performing the `stop` and `flush` commands.
-Such behaviour allows users to efficiently disable and enable filtering
-without actually changing the active configuration, as it may be unnecessary.
-
-### Autostart on boot
-
-In NetBSD, the rc.d system can be used to start NPF on boot.  The following
-is an example for starting NPF and loading the configuration through the rc.d
-script:
-```
-$ echo 'npf=YES' >> /etc/rc.conf
-$ /etc/rc.d/npf reload
-Reloading NPF ruleset.
-$ /etc/rc.d/npf start
-Enabling NPF.
-```
diff --git a/docs/dynamic_rules.md b/docs/dynamic_rules.md
deleted file mode 100644
index 2e0e3f8..0000000
--- a/docs/dynamic_rules.md
+++ /dev/null
@@ -1,38 +0,0 @@
-# Dynamic rules
-
-NPF has support for dynamic rules which can be added or removed to a given
-ruleset without reloading the entire configuration.  Consider the following
-fragment:
-```
-group default {
-  ruleset "test-set"
-}
-```
-
-Dynamic rules can be managed using
-[npfctl(8)](http://man.netbsd.org/cgi-bin/man-cgi?npfctl+8+NetBSD-current):
-```
-$ npfctl rule "test-set" add block proto icmp from 192.168.0.6
-OK 1
-$ npfctl rule "test-set" list
-block proto icmp from 192.168.0.6
-$ npfctl rule "test-set" add block from 192.168.0.7
-OK 2
-$ npfctl rule "test-set" list
-block proto icmp from 192.168.0.6
-block from 192.168.0.7 
-$ npfctl rule "test-set" rem block from 192.168.0.7
-$ npfctl rule "test-set" rem-id 1
-$ npfctl rule "test-set" list
-```
-
-Each rule gets a unique identifier which is returned on addition.  The
-identifier should be considered as alphanumeric string.  As shown in the
-example, there are two methods to remove a rule:
-
-* Using a unique identifier (`rem-id` command).
-* Passing the exact rule and using a hash computed on a rule (`rem` command).
-
-In the second case, SHA1 hash is computed on a rule to identify it.  Although
-very unlikely, it is subject to hash collisions.  For a fully reliable and
-more efficient way, it is recommended to use the first method.
diff --git a/docs/extensions.md b/docs/extensions.md
deleted file mode 100644
index 3a16a24..0000000
--- a/docs/extensions.md
+++ /dev/null
@@ -1,178 +0,0 @@
-# Extensions API
-
-NPF provides extensions framework for easy addition of custom functionality.
-An extension implements the mechanism which can be applied to the packets
-or the connections using rule procedures described in a previous chapter.
-
-An extension consists of two parts: a parser module which is a dynamic library
-(.so file) supplementing the
-[npfctl(8)](http://man.netbsd.org/cgi-bin/man-cgi?npfctl+8+NetBSD-current)
-utility and a kernel module.  The syntax of npf.conf supports arbitrary
-procedures with their parameters, as supplied by the modules.
-
-As an example to illustrate the interface, source code of the random-block
-extension will be used.  Reference:
-
-* Parser module for npfctl: [npfext_rndblock.c](../src/libext/ext_rndblock/npfext_rndblock.c)
-* Kernel module: [npf_ext_rndblock.c](../src/kern/npf_ext_rndblock.c)
-
-The reader is assumed to have basic familiarity with the kernel interfaces.
-
-## Parser module
-
-The parser module is responsible for indicating which functions are
-provided by the extension, parsing their parameters and constructing
-a structure (object) to pass for the kernel module.
-
-The dynamic module should have the following routines, where <extname>
-represents the name of the extension:
-
-* Initialisation routine: `int npfext_<extname>_init(void);`
-* Constructor: `nl_ext_t *npfext_<extname>_construct(const char *name);`
-* Parameter processor: `int npfext_<extname>_param(nl_ext_t *ext,
-  const char *param, const char *val);`
-
-Initialisation routine is called once DSO is loaded.  Any state initialisation
-can be performed here.  The constructor routine is called for every rule
-procedure which has an invoking call to an extension.  Consider the following
-rule procedures in npf.conf:
-```
-procedure "test1" {
-  rndblock: percentage 30.0;
-}
-
-procedure "test2" {
-  rndblock: percentage 20.0;
-  log: npflog0;
-}
-```
-
-There will be three calls to `npfext_extname_construct()`: two with the
-`name` "rndblock" and one with the name "log".  The routine should match the
-name against "rndblock", ignoring the "log" case.  Note that the first two
-ought to construct two separate objects having different properties.
-Therefore:
-```c
-nl_ext_t *
-npfext_rndblock_construct(const char *name)
-{
-	if (strcmp(name, "rndblock") != 0) {
-		return NULL;
-	}
-	return npf_ext_construct(name);
-}
-```
-
-Multiple functions can be supported by a single extension, e.g. it may
-match "rndblock", "rnd-block" or another function implementing some
-different functionality.
-
-Upon object creation, parameter processing routine is invoked for every
-specified function argument which is a key-value pair.  Therefore, for the
-first case, `npfext_rndblock_param()` would be called with `param` value
-"percentage" and `val` being "30.0".  This routine is responsible for parsing
-the values, validating them and setting the extension object accordingly.
-For an example, see
-[npfext_rndblock_param()](../src/libext/ext_rndblock/npfext_rndblock.c#npfext_rndblock_param).
-Note that a single parameter may be passed and `val` can be `NULL`.
-The routine should return zero on success and error number on failure,
-in which case npfctl will issue an error.  The
-[libnpf(3)](http://man.netbsd.org/cgi-bin/man-cgi?libnpf+3+NetBSD-current)
-library provides an interface to set attributes of various types,
-e.g. `npf_ext_param_u32`.
-
-The extension object will be passed to the kernel during the configuration
-load.  The kernel module will be the consumer.
-
-## Kernel module
-
-The kernel module of the NPF extensions is the component which implements
-the actual functionality.  It consumes the data provided by the parser module
-i.e. configuration provided from the userspace.  As there can be multiple rule
-procedures, there can be multiple configurations (extension objects) passed.
-
-The kernel module should have the following:
-
-* Module definition:
-  ```c
-  NPF_EXT_MODULE(npf_ext_<extname>, "");
-  ```
-* Module control routine:
-  ```c
-  static int npf_ext_<extname>_modcmd(modcmd_t cmd, void *arg);
-  ```
-* Register itself on module load:
-  ```c
-  void *npf_ext_register(const char *name, const npf_ext_ops_t *ops);
-  ```
-* Unregister itself on module unload with:
-  ```c
-  int npf_ext_unregister(void *extid);
-  ```
-
-See
-[npf_ext_rndblock_modcmd()](../src/kern/npf_ext_rndblock.c#npf_ext_rndblock_modcmd)
-for an example of the control routine.  A set of operations to register:
-```c
-static const npf_ext_ops_t npf_rndblock_ops = {
-	.version	= NPFEXT_RNDBLOCK_VER,
-	.ctx		= NULL,
-	.ctor		= npf_ext_rndblock_ctor,
-	.dtor		= npf_ext_rndblock_dtor,
-	.proc		= npf_ext_rndblock
-};
-```
-
-The structure has the following members:
-
-* `.version` -- is used as a guard for the interface versioning
-* `.ctx` -- an optional "context" argument passed to each routine
-* `.ctor` -- constructor for each extension object received from the
-npfctl dynamic module
-* `.dtor` -- destructor for in-kernel extension objects
-* `.proc` -- the processing routine executed for each packet
-
-The constructor is called on configuration load.  This routine should retrieve
-the data (extension object) passed by the parser module and create in-kernel
-object associated with a rule procedure.  The construction shall have these
-arguments:
-```c
-static int npf_ext_rndblock_ctor(npf_rproc_t *rp, const nvlist_t *params);
-```
-
-* `rp` -- rule procedure to associate with
-* `params` -- data from the parser module, as a nvlist, see
-[nvlist(3)](https://github.com/wheelsystems/nvlist).
-
-A new object (metadata) shall be associated with the rule procedure using
-`npf_rproc_assign` routine.
-
-The destructor is called when the rule procedure is destroyed (due to the
-flush of configuration or reload with procedure removed).  It shall have
-these arguments:
-```c
-static void npf_ext_rndblock_dtor(npf_rproc_t *rp, void *meta);
-```
-
-* `rp` -- associated rule procedure
-* `meta` -- metadata object
-
-It is the responsibility of this routine to destroy `meta` object and any
-other resources created in the constructor.
-
-The processing routine is a key routine, which inspects the packet or the
-connection and can perform an arbitrary action (including the modification
-of the packet) or decide its destiny (pass or block).  This routine shall
-have the following arguments:
-```c
-static void npf_ext_rndblock(npf_cache_t *npc, void *meta, const npf_match_info_t *mi, int *decision);
-```
-
-* `npc` -- structure containing information about L3/L4 headers
-* `meta` -- metadata object
-* `mi` -- matching rule information
-* `decision` -- the current decision made by upper layer, which may be
-`NPF_DECISION_BLOCK` or `NPF_DECISION_PASS`.
-
-The extension may set `decision` accordingly.  Normally, an extension should
-not override `NPF_DECISION_BLOCK`.
diff --git a/docs/intro.md b/docs/intro.md
deleted file mode 100644
index d0e32dd..0000000
--- a/docs/intro.md
+++ /dev/null
@@ -1,81 +0,0 @@
-# Introduction
-
-NPF is a layer 3 packet filter, supporting IPv4 and IPv6, as well as layer 4
-protocols such as TCP, UDP and ICMP.  NPF offers a traditional set of features
-provided by most packet filters.  This includes stateful packet filtering,
-various forms of network address translation (NAT), IP sets (tables which
-provide different data structures as a container), rule procedures for easy
-development of NPF extensions, packet normalisation and logging, connection
-saving and restoring and more.
-
-It was designed with a focus on high performance, scalability, multi-threading
-and modularity. NPF was written from scratch in 2009.  It is written in C99
-and distributed under the 2-clause BSD license.
-
-## Mode of operation
-
-NPF was originally developed for the NetBSD operating system.  However, NPF
-is also provided as a userspace library to be used in a bespoke application
-to process packets.  Typically, in combination with such frameworks like
-[Data Plane Development Kit (DPDK)](https://www.dpdk.org/) or
-[netmap](https://www.freebsd.org/cgi/man.cgi?query=netmap&sektion=4).
-
-Some aspects of this documentation, particularly concerning the configuration,
-will be in the context of NetBSD (or other UNIX-like system).  However, the
-general principles and concepts apply to the standalone NPF (as-a-library).
-
-## Brief notes on design
-
-NPF uses
-[Berkeley Packet Filter (BPF) byte-code](http://man.netbsd.org/cgi-bin/man-cgi?bpf+4+NetBSD-current),
-which is just-in-time (JIT) compiled into the machine code.  Each rule is
-described by a sequence of low level operations to perform for a packet.
-This design has the advantage of protocol independence, therefore support
-for new protocols (for example, layer 7) or custom filtering patterns can
-be easily added at userspace level without any modifications to the kernel
-itself.
-
-NPF provides rule procedures as the main interface to implement custom
-extensions.  The configuration syntax file supports arbitrary procedures
-with their parameters, as supplied by the extensions.  An extension consists
-of two parts: a dynamic module (.so file) supplementing the
-[npfctl(8)](http://man.netbsd.org/cgi-bin/man-cgi?npfctl+8+NetBSD-current)
-utility and a kernel module (.kmod file).  Kernel interfaces are available
-for use and avoid modifications to the NPF core code.
-
-The internals of NPF are abstracted into well defined modules and follow
-strict interfacing principles to ease the extensibility.  Communication
-between userspace and the kernel is provided through the library -- **libnpf**,
-described in the
-[libnpf(3)](http://man.netbsd.org/cgi-bin/man-cgi?libnpf+3+NetBSD-current)
-manual page.  It can be conveniently used by the developers who create their
-own extensions or third party products based on NPF.  Application level
-gateways (ALGs), such as support for
-[traceroute(8)](http://man.netbsd.org/cgi-bin/man-cgi?traceroute+8+NetBSD-current),
-are also abstracted in separate modules.
-
-## Processing
-
-NPF intercepts the packets at layer 3 of the TCP/IP stack.  The packet
-may be rejected before the NPF inspection if it is malformed and has invalid
-IPv4 or IPv6 header or some fields.  Incoming IP packets are passed to NPF
-before the IP reassembly.  Unless disabled, reassembly is performed by NPF.
-
-Processing is performed on each interface a packet is traversing, either as
-_incoming_ or _outgoing_.  Support for processing on _forwarding_ path and
-fast-forward optimisation is planned for the future release.
-
-Packets can be _incoming_ or _outgoing_ with respect to an interface.
-_Connection direction_ is identified by the direction of its first packet.
-The meaning of incoming/outgoing packet in the context of connection direction
-can be confusing.  Therefore, we will use the terms _forwards stream_ and
-_backwards stream_, where packets in the forwards stream mean the packets
-travelling in the direction as the connection direction.
-
-Processing order within NPF is as follows:
-```
-state inspection
-  -> rule inspection (if no state)
-    -> address/port translation
-      -> rule procedure processing
-```
diff --git a/docs/nat.md b/docs/nat.md
deleted file mode 100644
index c8810fe..0000000
--- a/docs/nat.md
+++ /dev/null
@@ -1,78 +0,0 @@
-# Network Address Translation
-
-NPF supports various forms of network address translation (NAT).  The
-translation may be dynamic (stateful) or static (stateless).  This includes
-includes traditional NAT (known as NAPT or masquerading), bi-directional NAT
-and port forwarding (redirection).  Static NAT currently supports simple 1:1
-mapping of IPv4 addresses and IPv6-to-IPv6 network prefix translation (NPTv6).
-NAT64 (the protocol translation) is planned for a future release of NPF.
-It should be remembered that dynamic NAT, as a concept, relies on stateful
-filtering, therefore it is performing it implicitly.
-
-NAT rules are expressed in a form of segment mapping:
-```
-map	= "map" interface
-	  ( "static" [ "algo" algorithm ] | "dynamic" )
-	  net-seg ( "->" | "<-" | "<->" ) net-seg
-	  [ "pass" [ proto ] filtopts ]
-```
-
-The following is an example configuration fragment of a traditional NAPT setup:
-```
-map $ext_if dynamic $localnet -> $ext_if
-
-group "external" on $ext_if {
-  pass stateful out final proto tcp from $localnet
-}
-```
-
-The first line enables traditional NAPT (keyword `map`) on the interface
-specified by `$ext_if` for all packets from the network defined in
-`$localnet` to any other network (0.0.0.0/0), where the address to translate to
-is the (only) one on the interface `$ext_if` (it may be specified directly
-as well, and has to be specified directly if the interface has more than
-one IPv4 address).
-
-The arrow indicates the translation type, which can be one of the following:
-
-* `->`&nbsp;&nbsp;&nbsp; for outbound NAT (also known as source NAT).
-* `<-`&nbsp;&nbsp;&nbsp; for inbound NAT (destination NAT).
-* `<->`&nbsp; for bi-directional NAT.
-
-The rule `pass ...` permits all outgoing packets from the specified
-network.  It additionally has stateful tracking enabled with the keyword
-`stateful`.  Therefore, any incoming packets belonging to the connections
-which were created by initial outgoing packets will be implicitly passed.
-
-The following two lines are example fragments of bi-directional NAT and
-port 8080 forwarding to a local IP address, port 80:
-```
-map $ext_alt_if dynamic $local_host_1 <-> $ext_alt_if
-map $ext_if dynamic $local_host_2 port 80 <- $ext_if port 8080
-```
-
-In the examples above, NPF determines the filter criteria from the segments
-on the left and right hand side implicitly.  Filter criteria can be specified
-explicitly using an optional `pass ...` syntax in conjunction with `map`.
-In such case the criteria has to be full, i.e. for both the source and the
-destination.  For example:
-```
-map $ext_if dynamic 127.0.0.1 port 8080 <- 0.0.0.0 \
-    pass from 10.0.0.1 to $rdr_ip port 80
-```
-
-This rule would redirect traffic only from 10.0.0.1 host with destination
-port 80 and according destination address.  The left hand side (as it is
-inbound NAT), according to the arrow, is used as a translation address.
-It should be noted that the right hand side is ignored (and thus can be
-0.0.0.0) as the filter criteria is specified explicitly.
-
-The following lines illustrate a static NAT rule which performs IPv6 Network
-Prefix Translation (NPTv6), as described in
-[RFC 6296](https://tools.ietf.org/html/rfc6296):
-```
-$net6_inner = fd01:203:405::/48
-$net6_outer = 2001:db8:1::/48
-
-map $ext_if static algo npt66 $net6_inner <-> $net6_outer
-```
diff --git a/docs/stateful.md b/docs/stateful.md
deleted file mode 100644
index b0b4202..0000000
--- a/docs/stateful.md
+++ /dev/null
@@ -1,76 +0,0 @@
-# Stateful filtering
-
-TCP is a connection-oriented protocol, which means that network stacks
-have a state structure for each connection.  The state is updated during
-the connection.  A specific connection is determined by the source and
-destination IP addresses, port numbers and the direction of the initial packet.
-Additionally, TCP is responsible for reliable transmission, which is
-achieved using TCP sequence and window numbers.  Validating the data of each
-packet according to the data in the state structure, as well as updating
-the state structure, is called TCP state tracking.  Since packet filters are
-the middle points between the hosts (i.e. senders and receivers) they have
-to perform their own TCP state tracking for each connection in order to
-reliably distinguish different TCP connections and perform connection-based
-filtering.
-
-Heuristic algorithms are used to handle out-of-order packets, packet losses
-and prevent connections from malicious packet injections.  Using the
-conceptually same technique, limited tracking of message-based protocols,
-mainly UDP and ICMP, can also be done.  Packet filters which have the
-described functionality are called _stateful_ packet filters.  For a more
-detailed description of the mechanism, one can refer to
-[Rooij G., "Real stateful TCP packet filtering in IP Filter",
-10th USENIX Security Symposium invited talk, Aug. 2001](
-http://www.usenix.org/events/sec01/invitedtalks/rooij.pdf) paper.
-
-NPF is a stateful packet filter capable of tracking TCP connections,
-as well as performing limited UDP and ICMP tracking.  Stateful filtering is
-enabled using the `stateful` or `stateful-all` keywords.  The former creates
-a state which is uniquely identified by a 5-tuple (source and destination IP
-addresses, port numbers and an interface identifier).  The latter excludes
-the interface identifier and must be used with precaution.  Once the state is
-created, as described in the previous paragraph, all further packets of the
-connection are tracked.  Packets in the backwards stream, after having been
-confirmed to belong to the same connection, are passed without ruleset
-inspection.  Example configuration fragment with stateful rules:
-
-```
-group "external" on $ext_if {
-  block all
-  pass stateful in final proto tcp flags S/SA to $ext_if port ssh
-}
-```
-
-In this example, all incoming and outgoing traffic on the `$ext_if` interface
-will be blocked, with the exception of incoming SSH traffic (with the
-destination being an IP address of this interface) and the implicitly
-passed backwards stream (outgoing reply packets) of these SSH connections.
-Since initial TCP packets opening a connection are SYN packets, such rules
-often have additional TCP filter criterion.  The expression `flags S/SA`
-extracts SYN and ACK flags and checks that SYN is set and ACK is not.
-If there are no `flags` specified, then stateful rules imply `flags S/SAFR`
-for the TCP connections, i.e. the rules will pass and create the state only
-on TCP connection request (SYN packets).  This is not the case if
-[pcap-filter(7)](http://man.netbsd.org/cgi-bin/man-cgi?pcap-filter+7+NetBSD-current)
-is used.
-
----
-IMPORTANT: Stateful rules imply `flags S/SAFR` for TCP packets.
-
----
-
-It is important to understand the implications of `stateful-all`.  Bypassing
-the ruleset on other interfaces can have undesirable effects, e.g. a packet
-with a spoofed IP address might bypass ingress filtering.  Associating a state
-with two interfaces (forwarding case) may also cause problems if the routes
-change.  On the other hand, picking up the state on any interface may lead
-to higher performance in certain configurations and may also handle some
-asymmetric routing cases.  The administrator is free to choose whether
-`stateful` or `stateful-all` is more suitable.
-
----
-WARNING: The `stateful-all` keyword must be used with precaution.
-
----
-
-// Connection save/restore
diff --git a/misc/npf_to_netbsd.sh b/misc/npf_to_netbsd.sh
deleted file mode 100755
index 66895c5..0000000
--- a/misc/npf_to_netbsd.sh
+++ /dev/null
@@ -1,28 +0,0 @@
-#!/bin/sh
-
-base_netbsd="$1"
-set -eu
-
-if [ -z "$base_netbsd" ]; then
-	echo "ERROR: ./npf_to_netbsd.sh <base-netbsd-src>" >&2
-	exit 1
-fi
-
-base_npf="$(dirname $0)/../src"
-cd "$base_npf"
-
-# npfkern
-scp ./kern/files.npf "$base_netbsd/sys/net/npf/"
-scp ./kern/*npf*.{c,h} "$base_netbsd/sys/net/npf/"
-scp ./kern/npf-params.7 "$base_netbsd/usr.sbin/npf/"
-
-# npfctl
-scp ./npfctl/npf?*.{c,h,l,y,5,8} "$base_netbsd/usr.sbin/npf/npfctl/"
-
-# libnpf
-scp ./libnpf/libnpf.3 "$base_netbsd/lib/libnpf/"
-scp ./libnpf/npf*.{c,h} "$base_netbsd/lib/libnpf/"
-
-# npftest
-scp ./npftest/npf*.{c,h,conf} "$base_netbsd/usr.sbin/npf/npftest/"
-scp ./npftest/libnpftest/npf*.{c,h} "$base_netbsd/usr.sbin/npf/npftest/libnpftest/"
diff --git a/pkg/Makefile b/pkg/Makefile
deleted file mode 100644
index 19865cb..0000000
--- a/pkg/Makefile
+++ /dev/null
@@ -1,34 +0,0 @@
-#
-# Makefile to build RPM/DEB packages.
-# This is primarily for the developer use.
-#
-
-PROJ?=	libnpf
-
-all:
-	@ echo "targets"
-	@ echo "	make rpm"
-	@ echo "	make deb"
-
-rpm-npfctl:
-	@ # npfctl
-	mkdir -p SOURCES && tar czpvf SOURCES/npfctl.tar.gz ../src
-	rpmbuild -ba -v --define "_topdir ${PWD}" SPECS/npfctl.spec
-
-rpm-libnpf:
-	@ # libnpf
-	mkdir -p SOURCES && tar czpvf SOURCES/libnpf.tar.gz ../src
-	rpmbuild -ba -v --define "_topdir ${PWD}" SPECS/libnpf.spec
-
-rpm: rpm-libnpf #rpm-npfctl
-	@ echo && printf "\x1B[32mRPM packages:\033[0m\n" && ls -1 RPMS/*
-
-deb:
-	cp -R ../src ./SOURCES
-	dpkg-buildpackage -rfakeroot -us -uc -b
-	@ echo && printf "\x1B[32mDEB packages:\033[0m\n" && ls -1 ../*.deb
-
-clean:
-	rm -rf BUILD BUILDROOT RPMS SOURCES SRPMS
-
-.PHONY: all rpm deb clean
diff --git a/pkg/SPECS/libnpf.spec b/pkg/SPECS/libnpf.spec
deleted file mode 100644
index 15ffd67..0000000
--- a/pkg/SPECS/libnpf.spec
+++ /dev/null
@@ -1,72 +0,0 @@
-%define version	%(cat %{_topdir}/version.txt)
-
-Name:		libnpf
-Version:	%{version}
-Release:	1%{?dist}
-Summary:	Standalone NPF package
-License:	BSD
-URL:		https://github.com/rmind/npf
-Source0:	libnpf.tar.gz
-
-BuildRequires:	make
-BuildRequires:	libtool
-BuildRequires:	libnv
-BuildRequires:	libbpfjit
-BuildRequires:	libqsbr
-BuildRequires:	libthmap
-BuildRequires:	liblpm >= 0.2.0
-BuildRequires:	libcdb
-BuildRequires:	jemalloc-devel
-
-Requires:	libnv
-Requires:	libbpfjit
-Requires:	libqsbr
-Requires:	libthmap
-Requires:	liblpm
-Requires:	libcdb
-Requires:	jemalloc
-
-%description
-NPF is a layer 3 packet filter, supporting IPv4 and IPv6 as well as layer
-4 protocols such as TCP, UDP, and ICMP.  It was designed with a focus on
-high performance, scalability and modularity.  NPF was written from
-scratch in 2009.  It is written in C99 and distributed under the 2-clause
-BSD license.
-
-This RPM package is a standalone version of NPF.  It contains the libnpf
-and libnpfkern libraries.
-
-
-%prep
-%setup -q -n src
-
-
-%build
-make %{?_smp_mflags} LIBDIR=%{_libdir}
-
-
-%install
-for t in kern libnpf; do
-	cd $t && make install \
-	    DESTDIR=%{buildroot} \
-	    LIBDIR=%{_libdir} \
-	    INCDIR=%{_includedir} \
-	    MANDIR=%{_mandir}
-	cd ..
-done
-cd kern && make clean && make install \
-    DEBUG=1 \
-    DESTDIR=%{buildroot} \
-    LIBDIR=%{_libdir} \
-    INCDIR=%{_includedir} \
-    MANDIR=%{_mandir}
-
-
-%files
-%{_libdir}/libnpf*
-%{_includedir}/*
-%{_mandir}/*
-
-
-%changelog
-
diff --git a/pkg/SPECS/npfctl.spec b/pkg/SPECS/npfctl.spec
deleted file mode 100644
index cfd3dba..0000000
--- a/pkg/SPECS/npfctl.spec
+++ /dev/null
@@ -1,54 +0,0 @@
-%define version	%(cat %{_topdir}/version.txt)
-
-Name:		npfctl
-Version:	%{version}
-Release:	1%{?dist}
-Summary:	Standalone NPF package: npfctl utility
-License:	BSD
-URL:		https://github.com/rmind/npf
-Source0:	npfctl.tar.gz
-
-BuildRequires:	make
-BuildRequires:	libtool
-BuildRequires:	openssl-devel
-BuildRequires:	flex
-BuildRequires:	byacc
-BuildRequires:	libnpf
-
-Requires:	libnv
-Requires:	libnpf
-
-%description
-NPF is a layer 3 packet filter, supporting IPv4 and IPv6 as well as layer
-4 protocols such as TCP, UDP, and ICMP.  It was designed with a focus on
-high performance, scalability and modularity.  NPF was written from
-scratch in 2009.  It is written in C99 and distributed under the 2-clause
-BSD license.
-
-This RPM package contains npfctl(8) utility.
-
-
-%prep
-%setup -q -n src
-
-
-%build
-(cd npfctl && make %{?_smp_mflags})
-(cd lib && make %{?_smp_mflags} LIBDIR=%{_libdir})
-
-
-%install
-(cd npfctl && make install \
-    DESTDIR=%{buildroot} BINDIR=%{_bindir} MANDIR=%{_mandir})
-(cd lib && make install \
-    DESTDIR=%{buildroot} LIBDIR=%{_libdir})
-
-
-%files
-%{_libdir}/npf/*
-%{_bindir}/*
-%{_mandir}/*
-
-
-%changelog
-
diff --git a/pkg/debian/changelog b/pkg/debian/changelog
deleted file mode 100644
index 1064603..0000000
--- a/pkg/debian/changelog
+++ /dev/null
@@ -1,5 +0,0 @@
-npf (0.0.1) unstable; urgency=medium
-
-  * Initial release.
-
- -- rmind <rmind@noxt.eu>  Fri, 18 May 2018 23:34:33 +0100
diff --git a/pkg/debian/compat b/pkg/debian/compat
deleted file mode 100644
index f599e28..0000000
--- a/pkg/debian/compat
+++ /dev/null
@@ -1 +0,0 @@
-10
diff --git a/pkg/debian/control b/pkg/debian/control
deleted file mode 100644
index 4818dc0..0000000
--- a/pkg/debian/control
+++ /dev/null
@@ -1,54 +0,0 @@
-Source: npf
-Priority: extra
-Maintainer: https://github.com/rmind
-Build-Depends:
- debhelper (>= 9),
- make,
- libtool,
- flex,
- byacc,
- libssl-dev,
- libjemalloc-dev,
- libpcap0.8-dev,
- libnv-dev,
- libbpfjit-dev,
- libqsbr-dev,
- liblpm-dev,
- libcdb-dev,
- libthmap-dev
-Standards-Version: 3.9.1
-Homepage: https://github.com/rmind/npf
-License: BSD-2-clause
-
-Package: libnpf1
-Section: lib
-Architecture: any
-Depends: ${shlibs:Depends}, ${misc:Depends}
-Description: Standalone NPF package: libraries
- NPF is a layer 3 packet filter, supporting IPv4 and IPv6 as well as layer
- 4 protocols such as TCP, UDP, and ICMP.  It was designed with a focus on
- high performance, scalability and modularity.  NPF was written from
- scratch in 2009.  It is written in C99 and distributed under the 2-clause
- BSD license.
-
-Package: libnpf1-dbg
-Section: debug
-Architecture: any
-Depends: ${misc:Depends}, libnpf1 (= ${binary:Version})
-Description: Debug symbols for libnpf1
- Debug symbols for libnpf1.
-
-Package: libnpf-dev
-Section: libdevel
-Architecture: any
-Depends: ${shlibs:Depends}, ${misc:Depends}, libnpf1 (= ${binary:Version})
-Description: Development files for libnpf1
- Development files for libnpf1.
-
-Package: npfctl
-Section: misc
-Architecture: any
-Build-Depends: libnpf-dev
-Depends: ${shlibs:Depends}, ${misc:Depends}, libnpf1 (= ${binary:Version})
-Description: Standalone NPF package: npfctl utility
- This package contains npfctl(8) utility of the standalone NPF package.
diff --git a/pkg/debian/libnpf-dev.install b/pkg/debian/libnpf-dev.install
deleted file mode 100644
index 65ee3e7..0000000
--- a/pkg/debian/libnpf-dev.install
+++ /dev/null
@@ -1,5 +0,0 @@
-usr/include/*
-usr/lib/*/lib*.a
-usr/lib/*/lib*.so
-usr/share/man/man3/*
-usr/share/man/man7/*
diff --git a/pkg/debian/libnpf1.install b/pkg/debian/libnpf1.install
deleted file mode 100644
index 3ddde58..0000000
--- a/pkg/debian/libnpf1.install
+++ /dev/null
@@ -1 +0,0 @@
-usr/lib/*/lib*.so.*
diff --git a/pkg/debian/npfctl.install b/pkg/debian/npfctl.install
deleted file mode 100644
index ad65acc..0000000
--- a/pkg/debian/npfctl.install
+++ /dev/null
@@ -1,2 +0,0 @@
-usr/bin/*
-usr/lib/npf/*
diff --git a/pkg/debian/rules b/pkg/debian/rules
deleted file mode 100755
index 96bf5d4..0000000
--- a/pkg/debian/rules
+++ /dev/null
@@ -1,49 +0,0 @@
-#!/usr/bin/make -f
-
-#export DH_VERBOSE = 1
-
-PKGVERSION:=$(shell cat version.txt)
-DEB_HOST_MULTIARCH?=$(shell dpkg-architecture -qDEB_HOST_MULTIARCH)
-
-DESTDIR=$(CURDIR)/debian/tmp
-
-BINDIR:=/usr/bin
-LIBDIR:=/usr/lib/$(DEB_HOST_MULTIARCH)
-INCDIR:=/usr/include
-MANDIR:=/usr/share/man
-
-# Install extension .so files at the /usr/lib/npf/ path.
-EXT_LIBDIR:=/usr/lib/
-
-%:
-	dh $@ --sourcedirectory=SOURCES --parallel
-
-override_dh_auto_build:
-	dh_auto_build -- LIBDIR=$(LIBDIR)
-	@ # Build the debug library for npftest
-	dh_auto_build -- -C kern lib LIBDIR=$(LIBDIR) DEBUG=1
-
-override_dh_auto_test:
-	dh_auto_test tests
-
-override_dh_auto_install:
-	dh_auto_install -- -C libnpf \
-	    LIBDIR=$(LIBDIR) INCDIR=$(INCDIR) MANDIR=$(MANDIR)
-	dh_auto_install -- -C kern \
-	    LIBDIR=$(LIBDIR) INCDIR=$(INCDIR) MANDIR=$(MANDIR)
-	@ # Install the debug library
-	dh_auto_install -- -C kern \
-	    LIBDIR=$(LIBDIR) INCDIR=$(INCDIR) MANDIR=$(MANDIR) DEBUG=1
-	@ # Build and install npfctl; FIXME: figure out the DEB dependency mess
-	LIBRARY_PATH=$(DESTDIR)/$(LIBDIR) dh_auto_build -- -C npfctl
-	dh_auto_install -- -C npfctl BINDIR=$(BINDIR) MANDIR=$(MANDIR)
-	@ # Install npfctl extensions; FIXME
-	LIBRARY_PATH=$(DESTDIR)/$(LIBDIR) \
-	    dh_auto_install -- -C lib LIBDIR=$(EXT_LIBDIR)
-
-override_dh_strip:
-	dh_strip -p libnpf1 --dbg-package=libnpf1-dbg
-	dh_strip -a --remaining-packages
-
-override_dh_gencontrol:
-	dh_gencontrol -- -v$(PKGVERSION)
diff --git a/pkg/debian/source/format b/pkg/debian/source/format
deleted file mode 100644
index 163aaf8..0000000
--- a/pkg/debian/source/format
+++ /dev/null
@@ -1 +0,0 @@
-3.0 (quilt)
diff --git a/pkg/version.txt b/pkg/version.txt
deleted file mode 100644
index 3eefcb9..0000000
--- a/pkg/version.txt
+++ /dev/null
@@ -1 +0,0 @@
-1.0.0
diff --git a/src/Makefile b/src/Makefile
deleted file mode 100644
index 69a769d..0000000
--- a/src/Makefile
+++ /dev/null
@@ -1,26 +0,0 @@
-SYSARCH:=	$(shell uname -m)
-
-ifeq ($(SYSARCH),x86_64)
-NJOBS:=		$(shell getconf _NPROCESSORS_ONLN)
-MKFLAGS=	-j $(NJOBS)
-else
-MKFLAGS=
-endif
-
-all:
-	make $(MKFLAGS) -C kern lib
-	make $(MKFLAGS) -C libnpf lib
-	make $(MKFLAGS) -C lib
-
-install:
-	make -C kern install
-	make -C libnpf install
-	make -C lib install
-
-clean:
-	make -C kern clean
-	make -C libnpf clean
-	make -C lib clean
-	make -C npfctl clean
-
-.PHONY: all install clean
diff --git a/src/kern/Makefile b/src/kern/Makefile
deleted file mode 100644
index 73ad947..0000000
--- a/src/kern/Makefile
+++ /dev/null
@@ -1,109 +0,0 @@
-#
-# Standalone NPF makefile: the kernel component as a library.
-# This file is in the Public Domain.
-#
-
-SYSNAME:=	$(shell uname -s)
-SYSARCH:=	$(shell uname -m)
-
-CFLAGS+=	-std=c99 -O2 -g -Wall -Wextra -Werror
-CFLAGS+=	-D_POSIX_C_SOURCE=200809L
-CFLAGS+=	-D_GNU_SOURCE -D_DEFAULT_SOURCE
-CFLAGS+=	-I stand -D_NPF_STANDALONE -D__RCSID\(x\)=
-CFLAGS+=	-Wno-unused-local-typedefs -Wno-unused-parameter
-
-#
-# Extended warning flags.
-#
-CFLAGS+=	-Wno-unknown-warning-option # gcc vs clang
-CFLAGS+=	-Wstrict-prototypes -Wmissing-prototypes -Wpointer-arith
-CFLAGS+=	-Wmissing-declarations -Wredundant-decls -Wnested-externs
-CFLAGS+=	-Wshadow -Wcast-qual -Wcast-align -Wwrite-strings
-CFLAGS+=	-Wold-style-definition
-CFLAGS+=	-Wsuggest-attribute=noreturn #-Wjump-misses-init
-CFLAGS+=	-Wduplicated-cond -Wmisleading-indentation -Wnull-dereference
-CFLAGS+=	-Wduplicated-branches -Wrestrict
-
-#
-# WARNING: All symbols must be hidden by default to not conflict with
-# the libnpf(3) library.  The debug version would, however, conflict.
-#
-ifeq ($(DEBUG),1)
-CFLAGS+=	-Og -DDEBUG -fno-omit-frame-pointer -D_NPF_TESTING
-ifeq ($(SYSARCH),x86_64)
-ifeq ($(CC),gcc) # XXX clang
-CFLAGS+=	-fsanitize=address -fsanitize=undefined
-LDFLAGS+=	-fsanitize=address -fsanitize=undefined
-endif
-endif
-OBJDIR=		debug
-else
-CFLAGS+=	-fvisibility=hidden
-CFLAGS+=	-DNDEBUG
-OBJDIR=		build
-endif
-
-CFLAGS+=	-pthread
-LDFLAGS+=	-lpthread -lnv -lqsbr -lthmap -llpm -lcdb -lbpfjit
-ifeq ($(SYSNAME),Linux)
-LDFLAGS+=	-ljemalloc
-endif
-
-#
-# Objects to compile
-#
-
-OBJS=		$(shell awk '/^file/ { print $$2 }' files.npf | \
-		    sed 's:\(.*\)net/npf/\(.*\).c:\2.o:g' | \
-		    egrep -v '^(npf_os|npf_ext_log|npf_ifaddr|if_npflog|lpm)')
-
-OBJS+=		stand/npfkern.o stand/bpf_filter.o
-OBJS+=		stand/murmurhash.o stand/tls_pth.o
-OBJS+=		stand/ebr_wrappers.o
-
-#
-# Flags for the library target
-#
-
-LIB=		libnpfkern
-ifeq ($(DEBUG),1)
-LIB=		libnpfkern-dbg
-endif
-
-INCS=		npf.h npfkern.h
-MANS3=		npfkern.3
-MANS7=		npf-params.7
-
-$(LIB).la:	LDFLAGS+=	-rpath $(LIBDIR) -version-info 1:0:0
-install/%.la:	ILIBDIR=	$(DESTDIR)/$(LIBDIR)
-install:	IINCDIR=	$(DESTDIR)/$(INCDIR)
-install:	IMAN3DIR=	$(DESTDIR)/$(MANDIR)/man3/
-install:	IMAN7DIR=	$(DESTDIR)/$(MANDIR)/man7/
-
-#
-# Targets
-#
-
-lib: $(LIB).la
-
-$(OBJDIR)/%.lo: %.c
-	libtool --mode=compile --tag CC $(CC) $(CFLAGS) -c -o $@ $<
-
-$(LIB).la: $(addprefix $(OBJDIR)/,$(shell echo $(OBJS) | sed 's/\.o/\.lo/g'))
-	libtool --mode=link --tag CC $(CC) -o $@ $^ $(LDFLAGS)
-
-install/%.la: %.la
-	mkdir -p $(ILIBDIR)
-	libtool --mode=install install -c $(notdir $@) $(ILIBDIR)/$(notdir $@)
-
-install: $(addprefix install/,$(LIB).la)
-	libtool --mode=finish $(LIBDIR)
-	mkdir -p $(IINCDIR)/net && install -c $(INCS) $(IINCDIR)/net
-	mkdir -p $(IMAN3DIR) && install -c $(MANS3) $(IMAN3DIR)
-	mkdir -p $(IMAN7DIR) && install -c $(MANS7) $(IMAN7DIR)
-
-clean:
-	libtool --mode=clean rm
-	rm -rf .libs $(OBJDIR) $(LIB).la
-
-.PHONY: all lib install clean
diff --git a/src/kern/files.npf b/src/kern/files.npf
deleted file mode 100644
index 00747c8..0000000
--- a/src/kern/files.npf
+++ /dev/null
@@ -1,52 +0,0 @@
-# $NetBSD: files.npf,v 1.22 2019/07/23 00:52:01 rmind Exp $
-#
-# Public Domain.
-#
-
-#
-# NPF pseudo device and modules.
-#
-
-defpseudo	npf:	ifnet, libnv
-
-# Core
-file	net/npf/npf.c				npf
-file	net/npf/npf_conf.c			npf
-file	net/npf/npf_ctl.c			npf
-file	net/npf/npf_handler.c			npf
-file	net/npf/npf_mbuf.c			npf
-file	net/npf/npf_bpf.c			npf
-file	net/npf/npf_params.c			npf
-file	net/npf/npf_ruleset.c			npf
-file	net/npf/npf_rproc.c			npf
-file	net/npf/npf_tableset.c			npf
-file	net/npf/npf_if.c			npf
-file	net/npf/npf_inet.c			npf
-file	net/npf/npf_conn.c			npf
-file	net/npf/npf_connkey.c			npf
-file	net/npf/npf_conndb.c			npf
-file	net/npf/npf_state.c			npf
-file	net/npf/npf_state_tcp.c			npf
-file	net/npf/npf_nat.c			npf
-file	net/npf/npf_portmap.c			npf
-file	net/npf/npf_alg.c			npf
-file	net/npf/npf_sendpkt.c			npf
-file	net/npf/npf_worker.c			npf
-
-file	net/npf/npf_os.c			npf
-file	net/npf/npf_ifaddr.c			npf
-
-# LPM
-file	net/npf/lpm.c				npf
-
-# Built-in extensions.
-file	net/npf/npf_ext_log.c			npf
-file	net/npf/npf_ext_normalize.c		npf
-file	net/npf/npf_ext_rndblock.c		npf
-
-# ALGs
-file	net/npf/npf_alg_icmp.c			npf
-file	net/npf/npf_alg_pptp.c			npf
-
-# Interfaces
-file	net/npf/if_npflog.c			npf
diff --git a/src/kern/if_npflog.c b/src/kern/if_npflog.c
deleted file mode 100644
index 98ffea7..0000000
--- a/src/kern/if_npflog.c
+++ /dev/null
@@ -1,175 +0,0 @@
-/*-
- * Copyright (c) 2010-2012 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * This material is based upon work partially supported by The
- * NetBSD Foundation under a contract with Mindaugas Rasiukevicius.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
- * NPF logging extension.
- */
-
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD: if_npflog.c,v 1.6 2018/09/29 14:41:36 rmind Exp $");
-
-#include <sys/types.h>
-#include <sys/module.h>
-
-#include <sys/conf.h>
-#include <sys/kmem.h>
-#include <sys/mbuf.h>
-#include <sys/mutex.h>
-#include <sys/queue.h>
-#include <sys/sockio.h>
-
-#include <net/if.h>
-#include <net/if_types.h>
-#include <net/bpf.h>
-#endif
-
-#include "npf_impl.h"
-#include "if_npflog.h"
-
-MODULE(MODULE_CLASS_DRIVER, if_npflog, NULL);
-
-typedef struct npflog_softc {
-	LIST_ENTRY(npflog_softc)	sc_entry;
-	kmutex_t			sc_lock;
-	ifnet_t				sc_if;
-	int				sc_unit;
-} npflog_softc_t;
-
-static int	npflog_clone_create(struct if_clone *, int);
-static int	npflog_clone_destroy(ifnet_t *);
-
-static LIST_HEAD(, npflog_softc)	npflog_if_list	__cacheline_aligned;
-static struct if_clone			npflog_cloner =
-    IF_CLONE_INITIALIZER("npflog", npflog_clone_create, npflog_clone_destroy);
-
-static void
-npflogattach(int nunits)
-{
-
-	LIST_INIT(&npflog_if_list);
-	if_clone_attach(&npflog_cloner);
-}
-
-static void
-npflogdetach(void)
-{
-	npflog_softc_t *sc;
-
-	while ((sc = LIST_FIRST(&npflog_if_list)) != NULL) {
-		npflog_clone_destroy(&sc->sc_if);
-	}
-	if_clone_detach(&npflog_cloner);
-}
-
-static int
-npflog_ioctl(ifnet_t *ifp, u_long cmd, void *data)
-{
-	npflog_softc_t *sc = ifp->if_softc;
-	int error = 0;
-
-	mutex_enter(&sc->sc_lock);
-	switch (cmd) {
-	case SIOCINITIFADDR:
-		ifp->if_flags |= (IFF_UP | IFF_RUNNING);
-		break;
-	default:
-		error = ifioctl_common(ifp, cmd, data);
-		break;
-	}
-	mutex_exit(&sc->sc_lock);
-	return error;
-}
-
-static int
-npflog_clone_create(struct if_clone *ifc, int unit)
-{
-	npflog_softc_t *sc;
-	ifnet_t *ifp;
-
-	sc = kmem_zalloc(sizeof(npflog_softc_t), KM_SLEEP);
-	mutex_init(&sc->sc_lock, MUTEX_DEFAULT, IPL_SOFTNET);
-
-	ifp = &sc->sc_if;
-	ifp->if_softc = sc;
-
-	if_initname(ifp, "npflog", unit);
-	ifp->if_type = IFT_OTHER;
-	ifp->if_dlt = DLT_NULL;
-	ifp->if_ioctl = npflog_ioctl;
-
-	KERNEL_LOCK(1, NULL);
-	if_attach(ifp);
-	if_alloc_sadl(ifp);
-	bpf_attach(ifp, DLT_NPFLOG, NPFLOG_HDRLEN);
-	LIST_INSERT_HEAD(&npflog_if_list, sc, sc_entry);
-	KERNEL_UNLOCK_ONE(NULL);
-
-	return 0;
-}
-
-static int
-npflog_clone_destroy(ifnet_t *ifp)
-{
-	npflog_softc_t *sc = ifp->if_softc;
-
-	KERNEL_LOCK(1, NULL);
-	LIST_REMOVE(sc, sc_entry);
-	bpf_detach(ifp);
-	if_detach(ifp);
-	KERNEL_UNLOCK_ONE(NULL);
-
-	mutex_destroy(&sc->sc_lock);
-	kmem_free(sc, sizeof(npflog_softc_t));
-	return 0;
-}
-
-/*
- * Module interface.
- */
-static int
-if_npflog_modcmd(modcmd_t cmd, void *arg)
-{
-	switch (cmd) {
-	case MODULE_CMD_INIT:
-		npflogattach(1);
-		break;
-
-	case MODULE_CMD_FINI:
-		npflogdetach();
-		break;
-
-	case MODULE_CMD_AUTOUNLOAD:
-		return EBUSY;
-
-	default:
-		return ENOTTY;
-	}
-	return 0;
-}
diff --git a/src/kern/if_npflog.h b/src/kern/if_npflog.h
deleted file mode 100644
index a13bc37..0000000
--- a/src/kern/if_npflog.h
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Copyright 2001 Niels Provos <provos@citi.umich.edu>
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-#ifndef _NET_NPF_IF_NPFLOG_H_
-#define _NET_NPF_IF_NPFLOG_H_
-
-#ifndef _KERNEL
-#error "not supposed to be exposed to userland"
-#endif
-
-#define NPFLOG_RULESET_NAME_SIZE	16
-
-/*
- * For now, we use a header compatible with pflog.
- * This will be improved in the future.
- */
-
-struct npfloghdr {
-	uint8_t		length;
-	sa_family_t	af;
-	uint8_t		action;
-	uint8_t		reason;
-	char		ifname[IFNAMSIZ];
-	char		ruleset[NPFLOG_RULESET_NAME_SIZE];
-	uint32_t	rulenr;
-	uint32_t	subrulenr;
-	uint32_t	uid;
-	uint32_t	pid;
-	uint32_t	rule_uid;
-	uint32_t	rule_pid;
-	uint8_t		dir;
-	uint8_t		pad[3];
-};
-
-#define DLT_NPFLOG	DLT_PFLOG
-
-#define NPFLOG_HDRLEN		sizeof(struct npfloghdr)
-#define NPFLOG_REAL_HDRLEN	offsetof(struct npfloghdr, pad)
-
-#endif /* _NET_NPF_IF_NPFLOG_H_ */
diff --git a/src/kern/npf-params.7 b/src/kern/npf-params.7
deleted file mode 100644
index 9211b76..0000000
--- a/src/kern/npf-params.7
+++ /dev/null
@@ -1,184 +0,0 @@
-.\" $NetBSD$
-.\"
-.\" Copyright (c) 2019 Mindaugas Rasiukevicius <rmind at netbsd org>
-.\" All rights reserved.
-.\"
-.\" Redistribution and use in source and binary forms, with or without
-.\" modification, are permitted provided that the following conditions
-.\" are met:
-.\" 1. Redistributions of source code must retain the above copyright
-.\"    notice, this list of conditions and the following disclaimer.
-.\" 2. Redistributions in binary form must reproduce the above copyright
-.\"    notice, this list of conditions and the following disclaimer in the
-.\"    documentation and/or other materials provided with the distribution.
-.\"
-.\" THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
-.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
-.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
-.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
-.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
-.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
-.\" SUCH DAMAGE.
-.\"
-.Dd August 6, 2020
-.Dt NPF-PARAMS 7
-.Os
-.Sh NAME
-.Nm npf-params
-.Nd tunable NPF parameters
-.Sh DESCRIPTION
-NPF supports a set of dynamically tunable parameters.
-.Pp
-All parameter values are integers and should generally be between
-zero and
-.Dv INT_MAX ,
-unless specified otherwise.
-Some parameters values can be negative; such values would typically
-have a special meaning.
-Enable/disable switches should be represented as boolean values 0 ("off")
-or 1 ("on").
-.Sh PARAMETERS
-.Bl -tag -width "123456"
-.\" ---
-.Bl -tag -width "123456"
-.It Li bpf.jit
-BPF just-in-time compilation: enables or disables
-.Xr bpfjit 4
-support.
-Some machine architectures are not presently supported by
-.Xr bpfjit 4 .
-Setting this parameter to off stops NPF from trying to enable this
-functionality, and generating a warning if it is unable to do so.
-Default: 1.
-.El
-.\" ---
-.Bl -tag -width "123456"
-.It Li ip4.reassembly
-Perform IPv4 reassembly before inspecting the packet.
-Fragmentation is considered very harmful, so most networks are expected
-to prevent it; therefore, reassembly is disabled by default.
-However, while the packet should generally be reassembled at the receiver,
-reassembly by the packet filter might be necessary in order to perform state
-tracking.
-Default: 0.
-.It Li ip4.drop_options
-Drop IPv4 packets that contain options.
-Default: 0.
-.It Li ip6.reassembly
-Perform IPv6 reassembly before inspecting the packet.
-Discouraged in general but not prohibited by RFC 8200.
-Default: 0.
-.It Li ip6.drop_options
-Drop IPv6 packets that contain options.
-Default: 0.
-.El
-.\" ---
-.Bl -tag -width "123456"
-.It Li gc.step
-Number of connection state items to process in one garbage collection
-(G/C) cycle.
-Must be positive number.
-Default: 256.
-.It Li gc.interval_min
-The lower bound for the sleep time of the G/C worker.
-The worker is self-tuning and will wake up more frequently if there are
-connections to expire; it will wake up less frequently, diverging towards
-the upper bound, if it does not encounter expired connections.
-Default: 50 (in milliseconds).
-.It Li gc.interval_min
-The upper bound for the sleep time of the G/C worker.
-Default: 5000 (in milliseconds).
-.El
-.\" ---
-.It Li state.key
-The connection state is uniquely identified by an n-tuple.
-The state behavior can be controlled by including (excluding)
-some of the information in (from) the keys.
-.Bl -tag -width "123456"
-.It Li interface
-Include interface identifier into the keys, making the connection
-state strictly per-interface.
-Default: 1.
-.It Li direction
-Include packet direction into the keys.
-Default: 1.
-.El
-.\" ---
-.It Li state.generic
-Generic state tracking parameters for non-TCP flows.
-All timeouts are in seconds and must be zero or positive.
-.Bl -tag -width "123456"
-.It Li timeout.new
-Timeout for new ("unsynchronized") state.
-Default: 30.
-.It Li timeout.established
-Timeout for established ("synchronized") state.
-Default: 60.
-.It Li timeout.closed
-Timeout for closed state.
-Default: 0.
-.El
-.\" ---
-.It Li state.tcp
-State tracking parameters for TCP connections.
-All timeout values are in seconds.
-.Bl -tag -width "123456"
-.It Li max_ack_win
-Maximum allowed ACK window.
-Default: 66000.
-.It Li strict_order_rst
-Enforce strict order RST.
-Default: 1.
-.\" -
-.It Li timeout.new
-Timeout for a new connection in "unsynchronized" state.
-Default: 30.
-.It Li timeout.established
-Timeout for an established connection ("synchronized" state).
-Default: 86400.
-.It Li timeout.half_close
-Timeout for the half-close TCP states.
-Default: 3600.
-.It Li timeout.close
-Timeout for the full close TCP states.
-Default: 10.
-.It Li timeout.time_wait
-Timeout for the TCP time-wait state.
-Default: 240.
-.El
-.\" ---
-.It Li portmap.min_port
-Lower bound of the port range used when selecting the port
-for dynamic NAT with port translation enabled.
-Default: 1024 (inclusive; also the lowest allowed value).
-.It Li portmap.max_port
-Upper bound of the port range as described above.
-Default: 49151 (inclusive; 65535 is the highest allowed value).
-.\" ---
-.El
-.\" -----
-.Sh EXAMPLES
-An example line in the
-.Xr npf.conf 5
-configuration file:
-.Bd -literal -offset indent
-set state.tcp.strict_order_rst on       # "on" can be used instead of 1
-set state.tcp.timeout.time_wait 0       # destroy the state immediately
-.Ed
-.\" -----
-.Sh SEE ALSO
-.Xr libnpf 3 ,
-.Xr npfkern 3 ,
-.Xr bpfjit 4 ,
-.Xr npf.conf 5 ,
-.Xr pcap-filter 7 ,
-.Xr npfctl 8
-.\" -----
-.Sh AUTHORS
-NPF
-was designed and implemented by
-.An Mindaugas Rasiukevicius .
diff --git a/src/kern/npf.c b/src/kern/npf.c
deleted file mode 100644
index 0d5a84c..0000000
--- a/src/kern/npf.c
+++ /dev/null
@@ -1,238 +0,0 @@
-/*-
- * Copyright (c) 2009-2013 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * This material is based upon work partially supported by The
- * NetBSD Foundation under a contract with Mindaugas Rasiukevicius.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
- * NPF main: dynamic load/initialisation and unload routines.
- */
-
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD$");
-
-#include <sys/param.h>
-#include <sys/types.h>
-
-#include <sys/conf.h>
-#include <sys/kmem.h>
-#include <sys/percpu.h>
-#include <sys/xcall.h>
-#endif
-
-#include "npf_impl.h"
-#include "npf_conn.h"
-
-static __read_mostly npf_t *	npf_kernel_ctx = NULL;
-
-__dso_public int
-npfk_sysinit(unsigned nworkers)
-{
-	npf_bpf_sysinit();
-	npf_tableset_sysinit();
-	npf_nat_sysinit();
-	return npf_worker_sysinit(nworkers);
-}
-
-__dso_public void
-npfk_sysfini(void)
-{
-	npf_worker_sysfini();
-	npf_nat_sysfini();
-	npf_tableset_sysfini();
-	npf_bpf_sysfini();
-}
-
-__dso_public npf_t *
-npfk_create(int flags, const npf_mbufops_t *mbufops,
-    const npf_ifops_t *ifops, void *arg)
-{
-	npf_t *npf;
-
-	npf = kmem_zalloc(sizeof(npf_t), KM_SLEEP);
-	npf->ebr = npf_ebr_create();
-	npf->stats_percpu = percpu_alloc(NPF_STATS_SIZE);
-	npf->mbufops = mbufops;
-	npf->arg = arg;
-
-	npf_param_init(npf);
-	npf_state_sysinit(npf);
-	npf_ifmap_init(npf, ifops);
-	npf_conn_init(npf);
-	npf_portmap_init(npf);
-	npf_alg_init(npf);
-	npf_ext_init(npf);
-
-	/* Load an empty configuration. */
-	npf_config_init(npf);
-
-	if ((flags & NPF_NO_GC) == 0) {
-		npf_worker_enlist(npf);
-	}
-	return npf;
-}
-
-__dso_public void
-npfk_destroy(npf_t *npf)
-{
-	npf_worker_discharge(npf);
-
-	/*
-	 * Destroy the current configuration.  Note: at this point all
-	 * handlers must be deactivated; we will drain any processing.
-	 */
-	npf_config_fini(npf);
-
-	/* Finally, safe to destroy the subsystems. */
-	npf_ext_fini(npf);
-	npf_alg_fini(npf);
-	npf_portmap_fini(npf);
-	npf_conn_fini(npf);
-	npf_ifmap_fini(npf);
-	npf_state_sysfini(npf);
-	npf_param_fini(npf);
-
-	npf_ebr_destroy(npf->ebr);
-	percpu_free(npf->stats_percpu, NPF_STATS_SIZE);
-	kmem_free(npf, sizeof(npf_t));
-}
-
-
-/*
- * npfk_load: (re)load the configuration.
- *
- * => Will not modify the configuration reference.
- */
-__dso_public int
-npfk_load(npf_t *npf, const void *config_ref, npf_error_t *err)
-{
-	const nvlist_t *req = (const nvlist_t *)config_ref;
-	nvlist_t *resp;
-	int error;
-
-	resp = nvlist_create(0);
-	error = npfctl_run_op(npf, IOC_NPF_LOAD, req, resp);
-	nvlist_destroy(resp);
-
-	return error;
-}
-
-__dso_public void
-npfk_gc(npf_t *npf)
-{
-	npf_conn_worker(npf);
-}
-
-__dso_public void
-npfk_thread_register(npf_t *npf)
-{
-	npf_ebr_register(npf->ebr);
-}
-
-__dso_public void
-npfk_thread_unregister(npf_t *npf)
-{
-	npf_ebr_full_sync(npf->ebr);
-	npf_ebr_unregister(npf->ebr);
-}
-
-__dso_public void *
-npfk_getarg(npf_t *npf)
-{
-	return npf->arg;
-}
-
-void
-npf_setkernctx(npf_t *npf)
-{
-	npf_kernel_ctx = npf;
-}
-
-npf_t *
-npf_getkernctx(void)
-{
-	return npf_kernel_ctx;
-}
-
-/*
- * NPF statistics interface.
- */
-
-void
-npf_stats_inc(npf_t *npf, npf_stats_t st)
-{
-	uint64_t *stats = percpu_getref(npf->stats_percpu);
-	stats[st]++;
-	percpu_putref(npf->stats_percpu);
-}
-
-void
-npf_stats_dec(npf_t *npf, npf_stats_t st)
-{
-	uint64_t *stats = percpu_getref(npf->stats_percpu);
-	stats[st]--;
-	percpu_putref(npf->stats_percpu);
-}
-
-static void
-npf_stats_collect(void *mem, void *arg, struct cpu_info *ci)
-{
-	uint64_t *percpu_stats = mem, *full_stats = arg;
-
-	for (unsigned i = 0; i < NPF_STATS_COUNT; i++) {
-		full_stats[i] += percpu_stats[i];
-	}
-}
-
-static void
-npf_stats_clear_cb(void *mem, void *arg, struct cpu_info *ci)
-{
-	uint64_t *percpu_stats = mem;
-
-	for (unsigned i = 0; i < NPF_STATS_COUNT; i++) {
-		percpu_stats[i] = 0;
-	}
-}
-
-/*
- * npf_stats: export collected statistics.
- */
-
-__dso_public void
-npfk_stats(npf_t *npf, uint64_t *buf)
-{
-	memset(buf, 0, NPF_STATS_SIZE);
-	percpu_foreach_xcall(npf->stats_percpu, XC_HIGHPRI_IPL(IPL_SOFTNET),
-	    npf_stats_collect, buf);
-}
-
-__dso_public void
-npfk_stats_clear(npf_t *npf)
-{
-	percpu_foreach_xcall(npf->stats_percpu, XC_HIGHPRI_IPL(IPL_SOFTNET),
-	    npf_stats_clear_cb, NULL);
-}
diff --git a/src/kern/npf.h b/src/kern/npf.h
index 8d4bf47..5d66fb6 100644
--- a/src/kern/npf.h
+++ b/src/kern/npf.h
@@ -42,7 +42,7 @@
 #if defined(_NPF_STANDALONE)
 #include "npf_stand.h"
 #else
-#include <sys/ioctl.h>
+//#include <sys/ioctl.h>
 #include <netinet/in_systm.h>
 #include <netinet/in.h>
 #endif
@@ -80,7 +80,7 @@ typedef uint8_t			npf_netmask_t;
  * In-kernel declarations and definitions.
  */
 
-#if defined(_KERNEL) || defined(_NPF_STANDALONE)
+#if defined(_NPF_STANDALONE)
 
 #define	NPF_DECISION_BLOCK	0
 #define	NPF_DECISION_PASS	1
@@ -199,7 +199,7 @@ npf_iscached(const npf_cache_t *npc, const int inf)
 
 bool		npf_autounload_p(void);
 
-#endif	/* _KERNEL */
+#endif	/* _NPF_STANDALONE */
 
 #define	NPF_SRC		0
 #define	NPF_DST		1
@@ -322,6 +322,9 @@ typedef struct npf_ioctl_table {
 #define	IOC_NPF_CONN_LOOKUP	_IOWR('N', 108, nvlist_ref_t)
 #define	IOC_NPF_TABLE_REPLACE	_IOWR('N', 109, nvlist_ref_t)
 
+// bstgw
+#define IOC_BSTGW_QUERY_NETIFS  _IOR('N', 120, nvlist_ret_t)
+
 /*
  * NPF error report.
  */
diff --git a/src/kern/npf_alg.c b/src/kern/npf_alg.c
deleted file mode 100644
index 03e1e9c..0000000
--- a/src/kern/npf_alg.c
+++ /dev/null
@@ -1,355 +0,0 @@
-/*-
- * Copyright (c) 2010-2019 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * This material is based upon work partially supported by The
- * NetBSD Foundation under a contract with Mindaugas Rasiukevicius.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
- * NPF interface for the Application Level Gateways (ALGs).
- */
-
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD$");
-
-#include <sys/param.h>
-#include <sys/types.h>
-
-#include <sys/kmem.h>
-#include <sys/module.h>
-#endif
-
-#include "npf_impl.h"
-
-/*
- * NAT ALG description structure.  For more compact use of cache,
- * the functions are separated in their own arrays.  The number of
- * ALGs is expected to be very small.
- */
-
-struct npf_alg {
-	const char *	na_name;
-	unsigned	na_slot;
-};
-
-struct npf_algset {
-	/* List of ALGs and the count. */
-	npf_alg_t	alg_list[NPF_MAX_ALGS];
-	unsigned	alg_count;
-
-	/* Matching, inspection and translation functions. */
-	npfa_funcs_t	alg_funcs[NPF_MAX_ALGS];
-};
-
-#define	NPF_ALG_PREF	"npf_alg_"
-#define	NPF_ALG_PREFLEN	(sizeof(NPF_ALG_PREF) - 1)
-
-void
-npf_alg_init(npf_t *npf)
-{
-	npf_algset_t *aset;
-
-	aset = kmem_zalloc(sizeof(npf_algset_t), KM_SLEEP);
-	npf->algset = aset;
-}
-
-void
-npf_alg_fini(npf_t *npf)
-{
-	npf_algset_t *aset = npf->algset;
-
-	kmem_free(aset, sizeof(npf_algset_t));
-}
-
-static npf_alg_t *
-npf_alg_lookup(npf_t *npf, const char *name)
-{
-	npf_algset_t *aset = npf->algset;
-
-	KASSERT(npf_config_locked_p(npf));
-
-	for (unsigned i = 0; i < aset->alg_count; i++) {
-		npf_alg_t *alg = &aset->alg_list[i];
-		const char *aname = alg->na_name;
-
-		if (aname && strcmp(aname, name) == 0)
-			return alg;
-	}
-	return NULL;
-}
-
-npf_alg_t *
-npf_alg_construct(npf_t *npf, const char *name)
-{
-	npf_alg_t *alg;
-
-	npf_config_enter(npf);
-	if ((alg = npf_alg_lookup(npf, name)) == NULL) {
-		char modname[NPF_ALG_PREFLEN + 64];
-
-		snprintf(modname, sizeof(modname), "%s%s", NPF_ALG_PREF, name);
-		npf_config_exit(npf);
-
-		if (module_autoload(modname, MODULE_CLASS_MISC) != 0) {
-			return NULL;
-		}
-		npf_config_enter(npf);
-		alg = npf_alg_lookup(npf, name);
-	}
-	npf_config_exit(npf);
-	return alg;
-}
-
-/*
- * npf_alg_register: register application-level gateway.
- */
-npf_alg_t *
-npf_alg_register(npf_t *npf, const char *name, const npfa_funcs_t *funcs)
-{
-	npf_algset_t *aset = npf->algset;
-	npfa_funcs_t *afuncs;
-	npf_alg_t *alg;
-	unsigned i;
-
-	npf_config_enter(npf);
-	if (npf_alg_lookup(npf, name) != NULL) {
-		npf_config_exit(npf);
-		return NULL;
-	}
-
-	/* Find a spare slot. */
-	for (i = 0; i < NPF_MAX_ALGS; i++) {
-		alg = &aset->alg_list[i];
-		if (alg->na_name == NULL) {
-			break;
-		}
-	}
-	if (i == NPF_MAX_ALGS) {
-		npf_config_exit(npf);
-		return NULL;
-	}
-
-	/* Register the ALG. */
-	alg->na_name = name;
-	alg->na_slot = i;
-
-	/*
-	 * Assign the functions.  Make sure the 'destroy' gets visible first.
-	 */
-	afuncs = &aset->alg_funcs[i];
-	atomic_store_relaxed(&afuncs->destroy, funcs->destroy);
-	membar_producer();
-	atomic_store_relaxed(&afuncs->translate, funcs->translate);
-	atomic_store_relaxed(&afuncs->inspect, funcs->inspect);
-	atomic_store_relaxed(&afuncs->match, funcs->match);
-	membar_producer();
-
-	atomic_store_relaxed(&aset->alg_count, MAX(aset->alg_count, i + 1));
-	npf_config_exit(npf);
-
-	return alg;
-}
-
-/*
- * npf_alg_unregister: unregister application-level gateway.
- */
-int
-npf_alg_unregister(npf_t *npf, npf_alg_t *alg)
-{
-	npf_algset_t *aset = npf->algset;
-	unsigned i = alg->na_slot;
-	npfa_funcs_t *afuncs;
-
-	/* Deactivate the functions first. */
-	npf_config_enter(npf);
-	afuncs = &aset->alg_funcs[i];
-	atomic_store_relaxed(&afuncs->match, NULL);
-	atomic_store_relaxed(&afuncs->translate, NULL);
-	atomic_store_relaxed(&afuncs->inspect, NULL);
-	npf_config_sync(npf);
-
-	/*
-	 * Finally, unregister the ALG.  We leave the 'destroy' callback
-	 * as the following will invoke it for the relevant connections.
-	 */
-	npf_ruleset_freealg(npf_config_natset(npf), alg);
-	atomic_store_relaxed(&afuncs->destroy, NULL);
-	alg->na_name = NULL;
-	npf_config_exit(npf);
-
-	return 0;
-}
-
-/*
- * npf_alg_match: call the ALG matching inspectors.
- *
- *	The purpose of the "matching" inspector function in the ALG API
- *	is to determine whether this connection matches the ALG criteria
- *	i.e. is concerning the ALG.  If yes, ALG can associate itself with
- *	the given NAT state structure and set/save an arbitrary parameter.
- *	This is done using the using the npf_nat_setalg() function.
- *
- *	=> This is called when the packet matches the dynamic NAT policy
- *	   and the NAT state entry is being created for it [NAT-ESTABLISH].
- */
-bool
-npf_alg_match(npf_cache_t *npc, npf_nat_t *nt, int di)
-{
-	npf_t *npf = npc->npc_ctx;
-	npf_algset_t *aset = npf->algset;
-	bool match = false;
-	unsigned count;
-	int s;
-
-	KASSERTMSG(npf_iscached(npc, NPC_IP46), "expecting protocol number");
-
-	s = npf_config_read_enter(npf);
-	count = atomic_load_relaxed(&aset->alg_count);
-	for (unsigned i = 0; i < count; i++) {
-		const npfa_funcs_t *f = &aset->alg_funcs[i];
-		bool (*match_func)(npf_cache_t *, npf_nat_t *, int);
-
-		match_func = atomic_load_relaxed(&f->match);
-		if (match_func && match_func(npc, nt, di)) {
-			match = true;
-			break;
-		}
-	}
-	npf_config_read_exit(npf, s);
-	return match;
-}
-
-/*
- * npf_alg_exec: execute the ALG translation processors.
- *
- *	The ALG function would perform any additional packet translation
- *	or manipulation here.
- *
- *	=> This is called when the packet is being translated according
- *	   to the dynamic NAT logic [NAT-TRANSLATE].
- */
-void
-npf_alg_exec(npf_cache_t *npc, npf_nat_t *nt, const npf_flow_t flow)
-{
-	npf_t *npf = npc->npc_ctx;
-	npf_algset_t *aset = npf->algset;
-	unsigned count;
-	int s;
-
-	s = npf_config_read_enter(npf);
-	count = atomic_load_relaxed(&aset->alg_count);
-	for (unsigned i = 0; i < count; i++) {
-		const npfa_funcs_t *f = &aset->alg_funcs[i];
-		bool (*translate_func)(npf_cache_t *, npf_nat_t *, npf_flow_t);
-
-		translate_func = atomic_load_relaxed(&f->translate);
-		if (translate_func) {
-			translate_func(npc, nt, flow);
-		}
-	}
-	npf_config_read_exit(npf, s);
-}
-
-/*
- * npf_alg_conn: query ALGs which may perform a custom state lookup.
- *
- *	The purpose of ALG connection inspection function is to provide
- *	ALGs with a mechanism to override the regular connection state
- *	lookup, if they need to.  For example, some ALGs may want to
- *	extract and use a different n-tuple to perform a lookup.
- *
- *	=> This is called at the beginning of the connection state lookup
- *	   function [CONN-LOOKUP].
- *
- *	=> Must use the npf_conn_lookup() function to perform the custom
- *	   connection state lookup and return the result.
- *
- *	=> Returning NULL will result in NPF performing a regular state
- *	   lookup for the packet.
- */
-npf_conn_t *
-npf_alg_conn(npf_cache_t *npc, int di)
-{
-	npf_t *npf = npc->npc_ctx;
-	npf_algset_t *aset = npf->algset;
-	npf_conn_t *con = NULL;
-	unsigned count;
-	int s;
-
-	s = npf_config_read_enter(npf);
-	count = atomic_load_relaxed(&aset->alg_count);
-	for (unsigned i = 0; i < count; i++) {
-		const npfa_funcs_t *f = &aset->alg_funcs[i];
-		npf_conn_t *(*inspect_func)(npf_cache_t *, int);
-
-		inspect_func = atomic_load_relaxed(&f->inspect);
-		if (inspect_func && (con = inspect_func(npc, di)) != NULL) {
-			break;
-		}
-	}
-	npf_config_read_exit(npf, s);
-	return con;
-}
-
-/*
- * npf_alg_destroy: free the ALG structure associated with the NAT entry.
- */
-void
-npf_alg_destroy(npf_t *npf, npf_alg_t *alg, npf_nat_t *nat, npf_conn_t *con)
-{
-	npf_algset_t *aset = npf->algset;
-	const npfa_funcs_t *f = &aset->alg_funcs[alg->na_slot];
-	void (*destroy_func)(npf_t *, npf_nat_t *, npf_conn_t *);
-
-	if ((destroy_func = atomic_load_relaxed(&f->destroy)) != NULL) {
-		destroy_func(npf, nat, con);
-	}
-}
-
-/*
- * npf_alg_export: serialise the configuration of ALGs.
- */
-int
-npf_alg_export(npf_t *npf, nvlist_t *nvl)
-{
-	npf_algset_t *aset = npf->algset;
-
-	KASSERT(npf_config_locked_p(npf));
-
-	for (unsigned i = 0; i < aset->alg_count; i++) {
-		const npf_alg_t *alg = &aset->alg_list[i];
-		nvlist_t *algdict;
-
-		if (alg->na_name == NULL) {
-			continue;
-		}
-		algdict = nvlist_create(0);
-		nvlist_add_string(algdict, "name", alg->na_name);
-		nvlist_append_nvlist_array(nvl, "algs", algdict);
-		nvlist_destroy(algdict);
-	}
-	return 0;
-}
diff --git a/src/kern/npf_alg_icmp.c b/src/kern/npf_alg_icmp.c
deleted file mode 100644
index 54923ab..0000000
--- a/src/kern/npf_alg_icmp.c
+++ /dev/null
@@ -1,494 +0,0 @@
-/*-
- * Copyright (c) 2010 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * This material is based upon work partially supported by The
- * NetBSD Foundation under a contract with Mindaugas Rasiukevicius.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
- * NPF ALG for ICMP and traceroute translations.
- */
-
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD$");
-
-#include <sys/param.h>
-#include <sys/module.h>
-
-#include <netinet/in_systm.h>
-#include <netinet/in.h>
-#include <netinet/ip.h>
-#include <netinet/tcp.h>
-#include <netinet/udp.h>
-#include <netinet/ip_icmp.h>
-#include <netinet/icmp6.h>
-#include <net/pfil.h>
-#endif
-
-#include "npf_impl.h"
-#include "npf_conn.h"
-
-MODULE(MODULE_CLASS_MISC, npf_alg_icmp, "npf");
-
-/*
- * Traceroute criteria.
- *
- * IANA assigned base port: 33434.  However, common practice is to increase
- * the port, thus monitor [33434-33484] range.  Additional filter is low TTL.
- */
-
-#define	TR_BASE_PORT	33434
-#define	TR_PORT_RANGE	33484
-#define	TR_MAX_TTL	48
-
-static npf_alg_t *	alg_icmp	__read_mostly;
-
-/*
- * npfa_icmp_match: matching inspector determines ALG case and associates
- * our ALG with the NAT entry.
- */
-static bool
-npfa_icmp_match(npf_cache_t *npc, npf_nat_t *nt, int di)
-{
-	const int proto = npc->npc_proto;
-	const struct ip *ip = npc->npc_ip.v4;
-	in_port_t dport;
-
-	KASSERT(npf_iscached(npc, NPC_IP46));
-	KASSERT(npf_iscached(npc, NPC_LAYER4));
-
-	/* Check for low TTL.  Also, we support outbound NAT only. */
-	if (ip->ip_ttl > TR_MAX_TTL || di != PFIL_OUT) {
-		return false;
-	}
-
-	switch (proto) {
-	case IPPROTO_TCP: {
-		const struct tcphdr *th = npc->npc_l4.tcp;
-		dport = ntohs(th->th_dport);
-		break;
-	}
-	case IPPROTO_UDP: {
-		const struct udphdr *uh = npc->npc_l4.udp;
-		dport = ntohs(uh->uh_dport);
-		break;
-	}
-	case IPPROTO_ICMP:
-	case IPPROTO_ICMPV6:
-		/* Just to pass the test below. */
-		dport = TR_BASE_PORT;
-		break;
-	default:
-		return false;
-	}
-
-	/* Handle TCP/UDP traceroute - check for port range. */
-	if (dport < TR_BASE_PORT || dport > TR_PORT_RANGE) {
-		return false;
-	}
-
-	/* Associate ALG with translation entry. */
-	npf_nat_setalg(nt, alg_icmp, 0);
-	return true;
-}
-
-/*
- * npfa_icmp{4,6}_inspect: retrieve unique identifiers - either ICMP query
- * ID or TCP/UDP ports of the original packet, which is embedded.
- *
- * => Sets hasqid=true if the packet has a Query Id. In this case neither
- *    the nbuf nor npc is touched.
- */
-
-static bool
-npfa_icmp4_inspect(const int type, npf_cache_t *npc, bool *hasqid)
-{
-	nbuf_t *nbuf = npc->npc_nbuf;
-
-	/* Per RFC 792. */
-	switch (type) {
-	case ICMP_UNREACH:
-	case ICMP_SOURCEQUENCH:
-	case ICMP_REDIRECT:
-	case ICMP_TIMXCEED:
-	case ICMP_PARAMPROB:
-		/* Should contain original IP header. */
-		if (!nbuf_advance(nbuf, offsetof(struct icmp, icmp_ip), 0)) {
-			return false;
-		}
-		return (npf_cache_all(npc) & NPC_LAYER4) != 0;
-
-	case ICMP_ECHOREPLY:
-	case ICMP_ECHO:
-	case ICMP_TSTAMP:
-	case ICMP_TSTAMPREPLY:
-	case ICMP_IREQ:
-	case ICMP_IREQREPLY:
-		/* Contains ICMP query ID. */
-		*hasqid = true;
-		return true;
-	default:
-		break;
-	}
-	return false;
-}
-
-static bool
-npfa_icmp6_inspect(const int type, npf_cache_t *npc, bool *hasqid)
-{
-	nbuf_t *nbuf = npc->npc_nbuf;
-
-	/* Per RFC 4443. */
-	switch (type) {
-	case ICMP6_DST_UNREACH:
-	case ICMP6_PACKET_TOO_BIG:
-	case ICMP6_TIME_EXCEEDED:
-	case ICMP6_PARAM_PROB:
-		/* Should contain original IP header. */
-		if (!nbuf_advance(nbuf, sizeof(struct icmp6_hdr), 0)) {
-			return false;
-		}
-		return (npf_cache_all(npc) & NPC_LAYER4) != 0;
-
-	case ICMP6_ECHO_REQUEST:
-	case ICMP6_ECHO_REPLY:
-		/* Contains ICMP query ID. */
-		*hasqid = true;
-		return true;
-	default:
-		break;
-	}
-	return false;
-}
-
-/*
- * npfa_icmp_inspect: ALG ICMP inspector.
- *
- * => Returns false if there is a problem with the format.
- */
-static bool
-npfa_icmp_inspect(npf_cache_t *npc, npf_cache_t *enpc)
-{
-	nbuf_t *nbuf = npc->npc_nbuf;
-	bool ret, hasqid = false;
-
-	KASSERT(npf_iscached(npc, NPC_IP46));
-	KASSERT(npf_iscached(npc, NPC_ICMP));
-
-	/* Advance to ICMP header. */
-	nbuf_reset(nbuf);
-	if (!nbuf_advance(nbuf, npc->npc_hlen, 0)) {
-		return false;
-	}
-	memset(enpc, 0, sizeof(npf_cache_t));
-	enpc->npc_ctx = npc->npc_ctx;
-	enpc->npc_nbuf = nbuf;
-
-	/*
-	 * Inspect the ICMP packet.  The relevant data might be in the
-	 * embedded packet.  Fill the "enpc" cache, if so.
-	 */
-	if (npf_iscached(npc, NPC_IP4) &&
-	    npc->npc_proto == IPPROTO_ICMP) {
-		const struct icmp *ic = npc->npc_l4.icmp;
-		ret = npfa_icmp4_inspect(ic->icmp_type, enpc, &hasqid);
-	} else if (npf_iscached(npc, NPC_IP6) &&
-	    npc->npc_proto == IPPROTO_ICMPV6) {
-		const struct icmp6_hdr *ic6 = npc->npc_l4.icmp6;
-		ret = npfa_icmp6_inspect(ic6->icmp6_type, enpc, &hasqid);
-	} else {
-		ret = false;
-	}
-	if (!ret) {
-		return false;
-	}
-
-	/* ICMP ID is the original packet, just indicate it. */
-	if (hasqid) {
-		npc->npc_info |= NPC_ICMP_ID;
-	}
-
-	return true;
-}
-
-static npf_conn_t *
-npfa_icmp_conn(npf_cache_t *npc, int di)
-{
-	npf_conn_t *conn = NULL;
-	npf_cache_t enpc;
-	bool hasqid = false;
-
-	/* Inspect ICMP packet for an embedded packet. */
-	if (!npf_iscached(npc, NPC_ICMP))
-		return NULL;
-	if (!npfa_icmp_inspect(npc, &enpc))
-		goto out;
-
-	/*
-	 * If the ICMP packet had a Query Id, leave now. The packet didn't get
-	 * modified, so no need to recache npc.
-	 */
-	if (npf_iscached(npc, NPC_ICMP_ID)) {
-		KASSERT(!nbuf_flag_p(npc->npc_nbuf, NBUF_DATAREF_RESET));
-		return NULL;
-	}
-
-	/*
-	 * Invert the identifiers of the embedded packet.
-	 * If it is ICMP, then ensure ICMP ID.
-	 */
-	union l4 {
-		struct tcphdr th;
-		struct udphdr uh;
-	} l4;
-	npf_flow_t flow;
-	bool ret;
-
-	#define	SWAP(type, x, y) { type tmp = x; x = y; y = tmp; }
-	SWAP(npf_addr_t *, enpc.npc_ips[NPF_SRC], enpc.npc_ips[NPF_DST]);
-
-	switch (enpc.npc_proto) {
-	case IPPROTO_TCP:
-		l4.th.th_sport = enpc.npc_l4.tcp->th_dport;
-		l4.th.th_dport = enpc.npc_l4.tcp->th_sport;
-		enpc.npc_l4.tcp = &l4.th;
-		break;
-	case IPPROTO_UDP:
-		l4.uh.uh_sport = enpc.npc_l4.udp->uh_dport;
-		l4.uh.uh_dport = enpc.npc_l4.udp->uh_sport;
-		enpc.npc_l4.udp = &l4.uh;
-		break;
-	case IPPROTO_ICMP: {
-		const struct icmp *ic = enpc.npc_l4.icmp;
-		ret = npfa_icmp4_inspect(ic->icmp_type, &enpc, &hasqid);
-		if (!ret || !hasqid)
-			goto out;
-		enpc.npc_info |= NPC_ICMP_ID;
-		break;
-	}
-	case IPPROTO_ICMPV6: {
-		const struct icmp6_hdr *ic6 = enpc.npc_l4.icmp6;
-		ret = npfa_icmp6_inspect(ic6->icmp6_type, &enpc, &hasqid);
-		if (!ret || !hasqid)
-			goto out;
-		enpc.npc_info |= NPC_ICMP_ID;
-		break;
-	}
-	default:
-		goto out;
-	}
-
-	/* Lookup a connection using the embedded packet. */
-	conn = npf_conn_lookup(&enpc, di, &flow);
-out:
-	/*
-	 * Recache npc. The nbuf may have been updated as a result of
-	 * caching enpc.
-	 */
-	npf_recache(npc);
-	return conn;
-}
-
-/*
- * npfa_icmp_nat: ALG translator - rewrites IP address in the IP header
- * which is embedded in ICMP packet.  Note: backwards stream only.
- */
-static bool
-npfa_icmp_nat(npf_cache_t *npc, npf_nat_t *nt, npf_flow_t flow)
-{
-	const unsigned which = NPF_SRC;
-	npf_cache_t enpc;
-	struct icmp *ic;
-	uint16_t cksum;
-
-	if (flow == NPF_FLOW_FORW || !npf_iscached(npc, NPC_ICMP))
-		return false;
-
-	/*
-	 * ICMP: fetch the current checksum we are going to fixup.
-	 */
-	ic = npc->npc_l4.icmp;
-	cksum = ic->icmp_cksum;
-
-	if (!npfa_icmp_inspect(npc, &enpc))
-		goto err;
-
-	/*
-	 * If the ICMP packet had a Query Id, leave now. The packet didn't get
-	 * modified, so no need to recache npc.
-	 */
-	if (npf_iscached(npc, NPC_ICMP_ID)) {
-		KASSERT(!nbuf_flag_p(npc->npc_nbuf, NBUF_DATAREF_RESET));
-		return false;
-	}
-
-	KASSERT(npf_iscached(&enpc, NPC_IP46));
-	KASSERT(npf_iscached(&enpc, NPC_LAYER4));
-
-	CTASSERT(offsetof(struct icmp, icmp_cksum) ==
-	    offsetof(struct icmp6_hdr, icmp6_cksum));
-
-	/*
-	 * Fetch the IP and port in the _embedded_ packet.  Also, fetch
-	 * the IPv4 and TCP/UDP checksums before they are rewritten.
-	 */
-	const int proto = enpc.npc_proto;
-	uint16_t ipcksum = 0, l4cksum = 0;
-	in_port_t old_port = 0;
-
-	if (npf_iscached(&enpc, NPC_IP4)) {
-		const struct ip *eip = enpc.npc_ip.v4;
-		ipcksum = eip->ip_sum;
-	}
-	switch (proto) {
-	case IPPROTO_TCP: {
-		const struct tcphdr *th = enpc.npc_l4.tcp;
-		old_port = th->th_sport;
-		l4cksum = th->th_sum;
-		break;
-	}
-	case IPPROTO_UDP: {
-		const struct udphdr *uh = enpc.npc_l4.udp;
-		old_port = uh->uh_sport;
-		l4cksum = uh->uh_sum;
-		break;
-	}
-	case IPPROTO_ICMP:
-	case IPPROTO_ICMPV6:
-		break;
-	default:
-		goto err;
-	}
-
-	/*
-	 * Get the original IP address and port.
-	 * Calculate the part of the ICMP checksum fixup.
-	 */
-	npf_addr_t *addr;
-	in_port_t port;
-
-	npf_nat_getorig(nt, &addr, &port);
-
-	cksum = npf_addr_cksum(cksum, enpc.npc_alen, enpc.npc_ips[which], addr);
-	if (port) {
-		cksum = npf_fixup16_cksum(cksum, old_port, port);
-	}
-
-	/*
-	 * Translate the embedded packet.  The following changes will
-	 * be performed by npf_napt_rwr():
-	 *
-	 *	1) Rewrite the IP address and, if not ICMP, port.
-	 *	2) Rewrite the TCP/UDP checksum (if not ICMP).
-	 *	3) Rewrite the IPv4 checksum for (1) and (2).
-	 *
-	 * XXX: Assumes NPF_NATOUT (source address/port).  Currently,
-	 * npfa_icmp_match() matches only for the PFIL_OUT traffic.
-	 */
-	if (npf_napt_rwr(&enpc, which, addr, port)) {
-		goto err;
-	}
-
-	/*
-	 * Finally, finish the ICMP checksum fixup: include the checksum
-	 * changes in the embedded packet.
-	 */
-	if (npf_iscached(&enpc, NPC_IP4)) {
-		const struct ip *eip = enpc.npc_ip.v4;
-		cksum = npf_fixup16_cksum(cksum, ipcksum, eip->ip_sum);
-	}
-	switch (proto) {
-	case IPPROTO_TCP: {
-		const struct tcphdr *th = enpc.npc_l4.tcp;
-		cksum = npf_fixup16_cksum(cksum, l4cksum, th->th_sum);
-		break;
-	}
-	case IPPROTO_UDP:
-		if (l4cksum) {
-			const struct udphdr *uh = enpc.npc_l4.udp;
-			cksum = npf_fixup16_cksum(cksum, l4cksum, uh->uh_sum);
-		}
-		break;
-	}
-	npf_recache(npc);
-	KASSERT(npf_iscached(npc, NPC_ICMP));
-	ic = npc->npc_l4.icmp;
-	ic->icmp_cksum = cksum;
-	return true;
-
-err:
-	/*
-	 * Recache npc. The nbuf may have been updated as a result of
-	 * caching enpc.
-	 */
-	npf_recache(npc);
-	return false;
-}
-
-/*
- * npf_alg_icmp_{init,fini,modcmd}: ICMP ALG initialization, destruction
- * and module interface.
- */
-
-__dso_public int
-npf_alg_icmp_init(npf_t *npf)
-{
-	static const npfa_funcs_t icmp = {
-		.match		= npfa_icmp_match,
-		.translate	= npfa_icmp_nat,
-		.inspect	= npfa_icmp_conn,
-		.destroy	= NULL,
-	};
-	alg_icmp = npf_alg_register(npf, "icmp", &icmp);
-	return alg_icmp ? 0 : ENOMEM;
-}
-
-__dso_public int
-npf_alg_icmp_fini(npf_t *npf)
-{
-	KASSERT(alg_icmp != NULL);
-	return npf_alg_unregister(npf, alg_icmp);
-}
-
-#ifdef _KERNEL
-static int
-npf_alg_icmp_modcmd(modcmd_t cmd, void *arg)
-{
-	npf_t *npf = npf_getkernctx();
-
-	switch (cmd) {
-	case MODULE_CMD_INIT:
-		return npf_alg_icmp_init(npf);
-	case MODULE_CMD_FINI:
-		return npf_alg_icmp_fini(npf);
-	case MODULE_CMD_AUTOUNLOAD:
-		return EBUSY;
-	default:
-		return ENOTTY;
-	}
-	return 0;
-}
-#endif
diff --git a/src/kern/npf_alg_pptp.c b/src/kern/npf_alg_pptp.c
deleted file mode 100644
index ff16f87..0000000
--- a/src/kern/npf_alg_pptp.c
+++ /dev/null
@@ -1,836 +0,0 @@
-/*-
- * Copyright (c) 2019 Alex Kiselev <alex at therouter net>
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-/*
- * NPF ALG for PPTP translations.
- */
-
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD$");
-
-#include <sys/param.h>
-#include <sys/module.h>
-
-#include <netinet/in_systm.h>
-#include <netinet/in.h>
-#include <netinet/ip.h>
-#include <netinet/tcp.h>
-#include <net/pfil.h>
-#endif
-
-#include "npf_impl.h"
-#include "npf_conn.h"
-
-MODULE(MODULE_CLASS_MISC, npf_alg_pptp, "npf");
-
-typedef struct {
-	npf_alg_t *		tcp;
-	npf_alg_t *		gre;
-	npf_portmap_t *		pm;
-} npf_pptp_alg_t;
-
-static npf_pptp_alg_t		pptp_alg	__cacheline_aligned;
-
-#define	PPTP_SERVER_PORT		htons(1723)
-
-#define	PPTP_OUTGOING_CALL_MIN_LEN	32
-
-#define	PPTP_MAGIC_COOKIE		0x1a2b3c4d
-
-/*
- * GRE headers: standard and PPTP ("enhanced").
- */
-
-#define	GRE_VER_FLD_MASK		0x7
-#define	GRE_STANDARD_HDR_VER		0
-#define	GRE_ENHANCED_HDR_VER		1
-
-typedef struct {
-	uint16_t	flags_ver;
-	uint16_t	proto;
-	/* enhanced header: */
-	uint16_t	payload_len;
-	uint16_t	call_id;
-	/* optional fields */
-} __packed pptp_gre_hdr_t;
-
-/*
- * PPTP TCP messages.
- */
-
-/* PPTP messages types. */
-#define	PPTP_CTRL_MSG			1
-
-/* PPTP control message types. */
-#define	PPTP_OUTGOING_CALL_REQUEST	7
-#define	PPTP_OUTGOING_CALL_REPLY	8
-#define	PPTP_CALL_CLEAR_REQUEST		12
-#define	PPTP_CALL_DISCONNECT_NOTIFY	13
-#define	PPTP_WAN_ERROR_NOTIFY		14
-
-typedef struct {
-	uint16_t	len;
-	uint16_t	pptp_msg_type;
-	uint32_t	magic_cookie;
-	uint16_t	ctrl_msg_type;
-	uint16_t	rsvd0;
-	uint16_t	call_id;
-} __packed pptp_msg_hdr_t;
-
-typedef struct {
-	pptp_msg_hdr_t	hdr;
-	uint16_t	call_serial_nb;
-	uint32_t	min_bps;
-	uint32_t	max_bps;
-	uint32_t	bearer_type;
-	uint16_t	framing_type;
-	/* ... */
-} __packed pptp_outgoing_call_req_t;
-
-typedef struct {
-	pptp_msg_hdr_t	hdr;
-	uint16_t	peer_call_id;
-	uint8_t		result_code;
-	uint8_t		err_code;
-	uint16_t	cause_code;
-	/* ... */
-} __packed pptp_outgoing_call_reply_t;
-
-#define PPTP_MIN_MSG_SIZE (MIN(\
-	sizeof(pptp_outgoing_call_req_t) - sizeof(pptp_msg_hdr_t), \
-	sizeof(pptp_outgoing_call_reply_t) - sizeof(pptp_msg_hdr_t)))
-
-/*
- * PPTP GRE connection state.
- */
-
-#define	CLIENT_CALL_ID			0
-#define	SERVER_CALL_ID			1
-#define	CALL_ID_COUNT			2
-
-#define	GRE_STATE_USED			0x1
-#define	GRE_STATE_ESTABLISHED		0x2
-#define	GRE_STATE_SERVER_CALL_ID	0x4
-
-typedef struct {
-	/*
-	 * - Client and server call IDs.
-	 * - Original client call ID.
-	 * - State flags.
-	 *
-	 * Note: call ID values are in the network byte order.
-	 */
-	uint16_t	call_id[CALL_ID_COUNT];
-	uint16_t	orig_client_call_id;
-	uint16_t	flags;
-} pptp_gre_state_t;
-
-/*
- * Maximum number of the GRE connections a host can establish
- * to the same server.
- */
-#define	PPTP_MAX_GRE_PER_CLIENT		4
-
-/*
- * ALG context associated with the PPTP TCP control connection.
- */
-typedef struct {
-	kmutex_t		lock;
-	pptp_gre_state_t	gre_conns[PPTP_MAX_GRE_PER_CLIENT];
-} pptp_tcp_ctx_t;
-
-static pptp_tcp_ctx_t *	pptp_tcp_ctx_alloc(npf_nat_t *);
-static void		pptp_tcp_ctx_free(pptp_tcp_ctx_t *);
-
-///////////////////////////////////////////////////////////////////////////
-
-static inline uint16_t
-pptp_call_id_get(const npf_addr_t *ip)
-{
-	return npf_portmap_get(pptp_alg.pm, sizeof(uint32_t), ip);
-}
-
-static inline void
-pptp_call_id_put(const npf_addr_t *ip, uint16_t call_id)
-{
-	npf_portmap_put(pptp_alg.pm, sizeof(uint32_t), ip, call_id);
-}
-
-///////////////////////////////////////////////////////////////////////////
-
-static void
-pptp_gre_prepare_state(const npf_cache_t *npc, npf_nat_t *nt,
-    const pptp_gre_state_t *gre_state, npf_cache_t *gre_npc,
-    npf_connkey_t *ckey)
-{
-	uint16_t gre_id[2];
-	npf_addr_t *o_addr;
-	in_port_t o_port;
-
-	/*
-	 * Create PPTP GRE context cache.  Needed for:
-	 *
-	 * => npf_conn_establish() to pick up a different protocol.
-	 * => npf_nat_share_policy() to obtain the IP addresses.
-	 */
-	memcpy(gre_npc, npc, sizeof(npf_cache_t));
-	gre_npc->npc_proto = IPPROTO_GRE;
-	gre_npc->npc_info = NPC_IP46 | NPC_LAYER4;
-
-	/*
-	 * Setup the IP addresses and call IDs.
-	 *
-	 * PPTP client -> PPTP server (and vice versa, if NPF_FLOW_FORW).
-	 */
-	npf_nat_getorig(nt, &o_addr, &o_port);
-	gre_npc->npc_ips[NPF_SRC] = o_addr;
-	gre_npc->npc_ips[NPF_DST] = npc->npc_ips[NPF_SRC];
-	gre_id[NPF_SRC] = gre_state->call_id[SERVER_CALL_ID];
-	gre_id[NPF_DST] = 0; /* not used */
-
-	/*
-	 * Additionally, set the custom key for npf_conn_establish().
-	 * We need bypass key construction as this is a custom protocol,
-	 * i.e. "enhanced PPTP" is unknown to npf_conn_conkey().
-	 */
-	npf_connkey_setkey(ckey, npc->npc_alen, IPPROTO_GRE,
-	    gre_npc->npc_ips, gre_id, NPF_FLOW_FORW);
-	gre_npc->npc_ckey = &ckey;
-}
-
-static int
-pptp_gre_establish_state(npf_cache_t *npc, const int di,
-    pptp_gre_state_t *gre_state, npf_nat_t *pptp_tcp_nt)
-{
-	npf_cache_t gre_npc;
-	npf_connkey_t ckey;
-	npf_conn_t *con = NULL;
-	npf_nat_t *nt;
-
-	pptp_gre_prepare_state(npc, pptp_tcp_nt, gre_state, &gre_npc, &ckey);
-
-	/* Establish a state for the GRE connection. */
-	con = npf_conn_establish(&gre_npc, di, true);
-	if (con == NULL)
-		return ENOMEM;
-
-	/*
-	 * Create a new nat entry for created GRE connection.  Use the
-	 * same NAT policy as the parent PPTP TCP control connection uses.
-	 * Associate the created NAT entry with the GRE connection.
-	 */
-	nt = npf_nat_share_policy(&gre_npc, con, pptp_tcp_nt);
-	if (nt == NULL) {
-		npf_conn_expire(con);
-		npf_conn_release(con);
-		return ENOMEM;
-	}
-	gre_state->flags |= GRE_STATE_ESTABLISHED;
-
-	/* Associate GRE ALG with the GRE connection. */
-	npf_nat_setalg(nt, pptp_alg.gre, (uintptr_t)(const void *)gre_state);
-
-	/* Make GRE connection state active and passing. */
-	npf_conn_setpass(con, NULL, NULL);
-	npf_conn_release(con);
-	return 0;
-}
-
-/*
- * pptp_gre_destroy_state: destroy the ALG GRE state and expire the
- * associated GRE tunnel connection state.
- */
-static void
-pptp_gre_destroy_state(npf_t *npf, pptp_gre_state_t *gre_state, npf_addr_t **ips)
-{
-	npf_conn_t *con;
-	uint16_t ids[2];
-
-	/* Expire the GRE connection state. */
-	if (gre_state->flags & GRE_STATE_ESTABLISHED) {
-		npf_connkey_t key;
-		npf_flow_t flow;
-
-		/* Initialize the forward GRE connection key. */
-		ids[NPF_SRC] = gre_state->call_id[SERVER_CALL_ID];
-		ids[NPF_DST] = 0;
-		npf_connkey_setkey((void *)&key, sizeof(uint32_t),
-		    IPPROTO_GRE, ips, ids, NPF_FLOW_FORW);
-
-		/* Lookup the associated PPTP GRE connection state. */
-		con = npf_conndb_lookup(npf, &key, &flow);
-		if (con != NULL) {
-			/*
-			 * Mark the GRE connection as expired.
-			 *
-			 * Note: translated call ID will be put back to the
-			 * portmap by the GRE connection state destructor.
-			 */
-			npf_conn_expire(con);
-			npf_conn_release(con);
-		}
-		gre_state->flags &= ~GRE_STATE_ESTABLISHED;
-
-	} else if (gre_state->call_id[CLIENT_CALL_ID] != 0) {
-		/*
-		 * Return translated call ID value back to the portmap.
-		 */
-		pptp_call_id_put(ips[NPF_DST], gre_state->call_id[CLIENT_CALL_ID]);
-	}
-
-	/* Mark the entry as unused. */
-	gre_state->flags &= ~GRE_STATE_USED;
-}
-
-/*
- * pptp_gre_get_state: find a free GRE state entry or reuse one with
- * the same orig_client_call_id.  Note: there can be only one entry
- * with the same orig_client_call_id.
- *
- * => Returns NULL if there are no empty entries (or an entry to re-use);
- * => Otherwise, return a reference to a entry marked as used and where
- *    the client call ID and translated client call ID valued are stored.
- */
-static pptp_gre_state_t *
-pptp_gre_get_state(npf_cache_t *npc, pptp_tcp_ctx_t *tcp_ctx,
-    uint16_t client_call_id, uint16_t trans_client_call_id)
-{
-	pptp_gre_state_t *gre_state = NULL;
-
-	/*
-	 * Scan all state entries to check if the given call ID is used.
-	 */
-	mutex_enter(&tcp_ctx->lock);
-	for (unsigned i = 0; i < PPTP_MAX_GRE_PER_CLIENT; i++) {
-		pptp_gre_state_t *gre_state_iter = &tcp_ctx->gre_conns[i];
-
-		if ((gre_state_iter->flags & GRE_STATE_USED) == 0) {
-			/* Unused state entry; remember it. */
-			gre_state = gre_state_iter;
-			continue;
-		}
-
-		/*
-		 * If call ID is already in use, then expire the associated
-		 * GRE connection and re-use this GRE state entry.
-		 */
-		if (gre_state_iter->orig_client_call_id == client_call_id) {
-			pptp_gre_destroy_state(npc->npc_ctx,
-			    gre_state_iter, npc->npc_ips);
-			KASSERT((gre_state_iter->flags & GRE_STATE_USED) == 0);
-			gre_state = gre_state_iter;
-			break;
-		}
-	}
-	if (gre_state) {
-		gre_state->orig_client_call_id = client_call_id;
-		gre_state->call_id[CLIENT_CALL_ID] = trans_client_call_id;
-		gre_state->flags = GRE_STATE_USED;
-	}
-	mutex_exit(&tcp_ctx->lock);
-	return gre_state;
-}
-
-/*
- * pptp_gre_lookup_state: lookup for a GRE state with the given call ID.
- */
-static pptp_gre_state_t *
-pptp_gre_lookup_state(pptp_tcp_ctx_t *tcp_ctx, unsigned which, uint16_t call_id)
-{
-	KASSERT(which == CLIENT_CALL_ID || which == SERVER_CALL_ID);
-	KASSERT(mutex_owned(&tcp_ctx->lock));
-
-	for (unsigned i = 0; i < PPTP_MAX_GRE_PER_CLIENT; i++) {
-		pptp_gre_state_t *gre_state = &tcp_ctx->gre_conns[i];
-
-		if ((gre_state->flags & GRE_STATE_USED) == 0)
-			continue;
-		if (gre_state->call_id[which] != call_id)
-			continue;
-		if ((gre_state->flags & GRE_STATE_SERVER_CALL_ID) != 0 ||
-		    (which == CLIENT_CALL_ID)) {
-			return gre_state;
-		}
-	}
-	return NULL;
-}
-
-static pptp_tcp_ctx_t *
-pptp_tcp_ctx_alloc(npf_nat_t *nt)
-{
-	pptp_tcp_ctx_t *ctx;
-
-	ctx = kmem_intr_zalloc(sizeof(pptp_tcp_ctx_t), KM_NOSLEEP);
-	if (ctx == NULL) {
-		return NULL;
-	}
-	mutex_init(&ctx->lock, MUTEX_DEFAULT, IPL_SOFTNET);
-	return ctx;
-}
-
-static void
-pptp_tcp_ctx_free(pptp_tcp_ctx_t *ctx)
-{
-	mutex_destroy(&ctx->lock);
-	kmem_intr_free(ctx, sizeof(pptp_tcp_ctx_t));
-}
-
-///////////////////////////////////////////////////////////////////////////
-
-/*
- * pptp_tcp_match: detects the PPTP TCP connection which controls the
- * PPTP GRE tunnel connection and associates it with the relevant ALG.
- */
-static bool
-pptp_tcp_match(npf_cache_t *npc, npf_nat_t *nt, const int di)
-{
-	pptp_tcp_ctx_t *tcp_ctx;
-
-	KASSERT(npf_iscached(npc, NPC_IP46));
-
-	/* Note: only the outbound NAT is supported */
-	if (di != PFIL_OUT || !npf_iscached(npc, NPC_TCP) ||
-	    npc->npc_l4.tcp->th_dport != PPTP_SERVER_PORT)
-		return false;
-
-	/* Associate with the PPTP TCP ALG. */
-	if ((tcp_ctx = pptp_tcp_ctx_alloc(nt)) == NULL) {
-		return false;
-	}
-	npf_nat_setalg(nt, pptp_alg.tcp, (uintptr_t)(void *)tcp_ctx);
-	return true;
-}
-
-/*
- * pptp_tcp_translate: PPTP TCP control connection ALG translator.
- *
- * This rewrites Call ID in the Outgoing-Call-Request message and
- * Peer Call ID in the Outgoing-Call-Reply message.
- */
-static bool
-pptp_tcp_translate(npf_cache_t *npc, npf_nat_t *nt, npf_flow_t flow)
-{
-	nbuf_t *nbuf = npc->npc_nbuf;
-	struct tcphdr *th = npc->npc_l4.tcp;
-	pptp_tcp_ctx_t *tcp_ctx;
-	pptp_msg_hdr_t *pptp;
-	pptp_gre_state_t *gre_state;
-	uint16_t old_call_id, trans_client_call_id, orig_client_call_id;
-	pptp_outgoing_call_reply_t *pptp_call_reply;
-	npf_addr_t *ip, *ips[2];
-	in_port_t o_port;
-
-	/*
-	 * Note: if ALG is associated, then the checks have been already
-	 * performed in pptp_tcp_match().
-	 */
-	if (!npf_nat_getalg(nt)) {
-		return false;
-	}
-	if (th->th_dport != PPTP_SERVER_PORT &&
-	    th->th_sport != PPTP_SERVER_PORT) {
-		return false;
-	}
-
-	nbuf_reset(nbuf);
-	pptp = nbuf_advance(nbuf, npc->npc_hlen + ((unsigned)th->th_off << 2),
-	    sizeof(pptp_msg_hdr_t) + PPTP_MIN_MSG_SIZE);
-	if (pptp == NULL)
-		return false;
-
-	/* Note: re-fetch the L4 pointer. */
-	npf_recache(npc);
-	th = npc->npc_l4.tcp;
-
-	if (pptp->pptp_msg_type != htons(PPTP_CTRL_MSG) ||
-	    pptp->len < htons(PPTP_OUTGOING_CALL_MIN_LEN) ||
-	    pptp->magic_cookie != htonl(PPTP_MAGIC_COOKIE))
-		return false;
-
-	/* Get or allocate GRE connection context for the ALG. */
-	tcp_ctx = (pptp_tcp_ctx_t *)npf_nat_getalgarg(nt);
-	KASSERT(tcp_ctx != NULL);
-
-	switch (ntohs(pptp->ctrl_msg_type)) {
-	case PPTP_OUTGOING_CALL_REQUEST:
-		if (pptp->len < sizeof(pptp_outgoing_call_req_t))
-			return false;
-
-		/*
-		 * Get the translated call ID value.
-		 *
-		 * It should be a unique value within the scope of all PPTP
-		 * connections destined to the same server.
-		 *
-		 * Note: it is better to use the source address scope, but
-		 * the translated source IP address is not known at this
-		 * point, since alg->translate() executed before the normal
-		 * NAT translation.
-		 */
-		ip = npc->npc_ips[NPF_DST]; /* PPTP server IP */
-		trans_client_call_id = pptp_call_id_get(ip);
-		if (trans_client_call_id == 0)
-			return false;
-
-		/*
-		 * Lookup for an empty GRE state entry or reuse one with
-		 * the same original call ID.
-		 */
-		gre_state = pptp_gre_get_state(npc, tcp_ctx,
-		    pptp->call_id, trans_client_call_id);
-		if (gre_state == NULL) {
-			/* all entries are in use */
-			pptp_call_id_put(ip, trans_client_call_id);
-			return false;
-		}
-
-		/* Rewrite client call ID. */
-		old_call_id = pptp->call_id;
-		pptp->call_id = trans_client_call_id;
-		th->th_sum = npf_fixup16_cksum(th->th_sum, old_call_id,
-		    trans_client_call_id);
-		break;
-
-	case PPTP_OUTGOING_CALL_REPLY:
-		if (pptp->len < sizeof(pptp_outgoing_call_reply_t)) {
-			return false;
-		}
-		CTASSERT(sizeof(pptp_outgoing_call_reply_t) <=
-		    sizeof(pptp_msg_hdr_t) + PPTP_MIN_MSG_SIZE);
-		pptp_call_reply = (pptp_outgoing_call_reply_t *)pptp;
-
-		/* Lookup the GRE connection context. */
-		mutex_enter(&tcp_ctx->lock);
-		gre_state = pptp_gre_lookup_state(tcp_ctx,
-		    CLIENT_CALL_ID, pptp_call_reply->peer_call_id);
-
-		if (gre_state == NULL ||
-		    (gre_state->flags & GRE_STATE_SERVER_CALL_ID) != 0) {
-			/*
-			 * State entry not found or call reply message
-			 * has been already received.
-			 */
-			mutex_exit(&tcp_ctx->lock);
-			return false;
-		}
-
-		/* Save the server call ID. */
-		gre_state->call_id[SERVER_CALL_ID]= pptp_call_reply->hdr.call_id;
-		gre_state->flags |= GRE_STATE_SERVER_CALL_ID;
-
-		/*
-		 * Client and server call IDs have been seen.  Create a new
-		 * GRE connection state entry and share the NAT entry with
-		 * the TCP state.
-		 */
-		if (pptp_gre_establish_state(npc, PFIL_OUT, gre_state, nt)) {
-			gre_state->flags &= ~GRE_STATE_SERVER_CALL_ID;
-			mutex_exit(&tcp_ctx->lock);
-			return false;
-		}
-		orig_client_call_id = gre_state->orig_client_call_id;
-		mutex_exit(&tcp_ctx->lock);
-
-		/* Rewrite the peer all ID. */
-		old_call_id = pptp_call_reply->peer_call_id;
-		pptp_call_reply->peer_call_id = orig_client_call_id;
-		th->th_sum = npf_fixup16_cksum(th->th_sum, old_call_id,
-		    orig_client_call_id);
-		break;
-
-	case PPTP_CALL_DISCONNECT_NOTIFY:
-		if (pptp->len < sizeof(pptp_msg_hdr_t))
-			return false;
-
-		/* Lookup the GRE connection state. */
-		mutex_enter(&tcp_ctx->lock);
-		gre_state = pptp_gre_lookup_state(tcp_ctx,
-		    SERVER_CALL_ID, pptp->call_id);
-		if (gre_state == NULL) {
-			mutex_exit(&tcp_ctx->lock);
-			return false;
-		}
-		npf_nat_getorig(nt, &ips[NPF_SRC], &o_port);
-		ips[NPF_DST] = npc->npc_ips[NPF_SRC];
-		pptp_gre_destroy_state(npc->npc_ctx, gre_state, ips);
-		mutex_exit(&tcp_ctx->lock);
-		break;
-
-	case PPTP_WAN_ERROR_NOTIFY:
-		if (pptp->len < sizeof(pptp_msg_hdr_t))
-			return false;
-
-		mutex_enter(&tcp_ctx->lock);
-		gre_state = pptp_gre_lookup_state(tcp_ctx,
-		    CLIENT_CALL_ID, pptp->call_id);
-		if (gre_state == NULL) {
-			mutex_exit(&tcp_ctx->lock);
-			return false;
-		}
-		orig_client_call_id = gre_state->orig_client_call_id;
-		mutex_exit(&tcp_ctx->lock);
-
-		/* Translate the call ID. */
-		old_call_id = pptp->call_id;
-		pptp->call_id = orig_client_call_id;
-		th->th_sum = npf_fixup16_cksum(th->th_sum, old_call_id,
-		    orig_client_call_id);
-		break;
-
-	default:
-		return false;
-	}
-
-	return true;
-}
-
-/*
- * pptp_tcp_destroy: free the structures associated with PPTP TCP connection.
- * It will expire all associated GRE connection states.
- */
-static void
-pptp_tcp_destroy(npf_t *npf, npf_nat_t *nt, npf_conn_t *con)
-{
-	npf_connkey_t *fw;
-	pptp_tcp_ctx_t *tcp_ctx;
-	npf_addr_t ips[2], *ipv[2];
-	unsigned alen, proto;
-	uint16_t ids[2];
-
-	tcp_ctx = (pptp_tcp_ctx_t *)npf_nat_getalgarg(nt);
-	if (tcp_ctx == NULL) {
-		return;
-	}
-
-	ipv[NPF_SRC] = &ips[NPF_SRC];
-	ipv[NPF_DST] = &ips[NPF_DST];
-
-	/* Note: only IPv4 is supported. */
-	fw = npf_conn_getforwkey(con);
-	KASSERT(NPF_CONNKEY_ALEN(fw) == sizeof(uint32_t));
-	npf_connkey_getkey(fw, &alen, &proto, ips, ids);
-
-	for (unsigned i = 0; i < PPTP_MAX_GRE_PER_CLIENT; i++) {
-		pptp_gre_state_t *gre_state = &tcp_ctx->gre_conns[i];
-
-		if (gre_state->flags & GRE_STATE_USED) {
-			pptp_gre_destroy_state(npf, gre_state, ipv);
-		}
-	}
-	pptp_tcp_ctx_free(tcp_ctx);
-}
-
-///////////////////////////////////////////////////////////////////////////
-
-
-/*
- * pptp_gre_inspect: lookup a custom PPTP GRE connection state.
- */
-static npf_conn_t *
-pptp_gre_inspect(npf_cache_t *npc, int di)
-{
-	nbuf_t *nbuf = npc->npc_nbuf;
-	pptp_gre_hdr_t *gre_hdr;
-	npf_connkey_t ckey;
-	uint16_t gre_id[2];
-	npf_conn_t *con;
-	npf_flow_t flow;
-	unsigned ver;
-
-	if (npc->npc_proto != IPPROTO_GRE) {
-		return NULL;
-	}
-	gre_hdr = nbuf_advance(nbuf, npc->npc_hlen, sizeof(pptp_gre_hdr_t));
-	if (gre_hdr == NULL) {
-		return NULL;
-	}
-	ver = ntohs(gre_hdr->flags_ver) & GRE_VER_FLD_MASK;
-	if (ver != GRE_ENHANCED_HDR_VER) {
-		return NULL;
-	}
-
-	/*
-	 * Prepare the GRE connection key.
-	 */
-	gre_id[NPF_SRC] = gre_hdr->call_id;
-	gre_id[NPF_DST] = 0; /* not used */
-	npf_connkey_setkey(&ckey, npc->npc_alen, IPPROTO_GRE,
-	    npc->npc_ips, gre_id, NPF_FLOW_FORW);
-
-	/* Lookup using the custom key. */
-	npc->npc_ckey = &ckey;
-	con = npf_conn_lookup(npc, di, &flow);
-	npc->npc_ckey = NULL;
-
-	return con;
-}
-
-/*
- * pptp_gre_translate: translate the PPTP GRE connection.
- */
-static bool
-pptp_gre_translate(npf_cache_t *npc, npf_nat_t *nt, npf_flow_t flow)
-{
-	nbuf_t *nbuf = npc->npc_nbuf;
-	const pptp_gre_state_t *gre_state;
-	pptp_gre_hdr_t *gre_hdr;
-	unsigned ver;
-
-	if (flow == NPF_FLOW_FORW || !npf_iscached(npc, NPC_IP4)) {
-		return false;
-	}
-	if (!npf_nat_getalg(nt)) {
-		return false;
-	}
-
-	/*
-	 * Note: since pptp_gre_inspect() cannot pass an arbitrary ALG
-	 * information right now, we need to re-check the header.
-	 */
-	nbuf_reset(nbuf);
-	gre_hdr = nbuf_advance(nbuf, npc->npc_hlen, sizeof(pptp_gre_hdr_t));
-	if (gre_hdr == NULL) {
-		return false;
-	}
-	ver = ntohs(gre_hdr->flags_ver) & GRE_VER_FLD_MASK;
-	if (ver != GRE_ENHANCED_HDR_VER) {
-		return false;
-	}
-
-	gre_state = (const void *)npf_nat_getalgarg(nt);
-	KASSERT(gre_hdr->call_id == gre_state->call_id[CLIENT_CALL_ID]);
-	gre_hdr->call_id = gre_state->orig_client_call_id;
-
-	// FIXME: IP checksum?
-
-	return true;
-}
-
-/*
- * Destroy the GRE connection context.
- *
- * => Puts the translated call ID back to the portmap.
- */
-static void
-pptp_gre_destroy(npf_t *npf, npf_nat_t *nt, npf_conn_t *con)
-{
-	const pptp_gre_state_t *gre_state;
-	uint16_t call_id;
-
-	gre_state = (const void *)npf_nat_getalgarg(nt);
-	if ((call_id = gre_state->call_id[CLIENT_CALL_ID]) != 0) {
-		const npf_connkey_t *fw;
-		unsigned alen, proto;
-		npf_addr_t ips[2];
-		uint16_t ids[2];
-
-		/* Note: only IPv4 is supported. */
-		fw = npf_conn_getforwkey(con);
-		KASSERT(NPF_CONNKEY_ALEN(fw) == sizeof(uint32_t));
-		npf_connkey_getkey(fw, &alen, &proto, ips, ids);
-
-		pptp_call_id_put(&ips[NPF_DST], call_id);
-	}
-}
-
-///////////////////////////////////////////////////////////////////////////
-
-/*
- * npf_alg_pptp_{init,fini,modcmd}: PPTP ALG initialization, destruction
- * and module interface.
- */
-__dso_public int
-npf_alg_pptp_init(npf_t *npf)
-{
-	static const npfa_funcs_t pptp_tcp = {
-		.match		= pptp_tcp_match,
-		.translate	= pptp_tcp_translate,
-		.inspect	= NULL,
-		.destroy	= pptp_tcp_destroy,
-	};
-	static const npfa_funcs_t pptp_gre = {
-		.match		= NULL,
-		.translate	= pptp_gre_translate,
-		.inspect	= pptp_gre_inspect,
-		.destroy	= pptp_gre_destroy,
-	};
-
-	/* Portmap for the PPTP call ID range. */
-	pptp_alg.pm = npf_portmap_create(1, UINT16_MAX);
-	if (pptp_alg.pm == NULL) {
-		return ENOMEM;
-	}
-	pptp_alg.tcp = npf_alg_register(npf, "pptp_tcp", &pptp_tcp);
-	if (pptp_alg.tcp == NULL) {
-		npf_alg_pptp_fini(npf);
-		return ENOMEM;
-	}
-	pptp_alg.gre = npf_alg_register(npf, "pptp_gre", &pptp_gre);
-	if (pptp_alg.gre == NULL) {
-		npf_alg_pptp_fini(npf);
-		return ENOMEM;
-	}
-	return 0;
-}
-
-__dso_public int
-npf_alg_pptp_fini(npf_t *npf)
-{
-	if (pptp_alg.tcp) {
-		npf_alg_unregister(npf, pptp_alg.tcp);
-		pptp_alg.tcp = NULL;
-	}
-	if (pptp_alg.gre) {
-		npf_alg_unregister(npf, pptp_alg.gre);
-		pptp_alg.gre = NULL;
-	}
-	if (pptp_alg.pm) {
-		npf_portmap_destroy(pptp_alg.pm);
-		pptp_alg.pm = NULL;
-	}
-	return 0;
-}
-
-#ifdef _KERNEL
-static int
-npf_alg_pptp_modcmd(modcmd_t cmd, void *arg)
-{
-	npf_t *npf = npf_getkernctx();
-
-	switch (cmd) {
-	case MODULE_CMD_INIT:
-		return npf_alg_pptp_init(npf);
-	case MODULE_CMD_FINI:
-		return npf_alg_pptp_fini(npf);
-	case MODULE_CMD_AUTOUNLOAD:
-		return EBUSY;
-	default:
-		return ENOTTY;
-	}
-	return 0;
-}
-#endif
diff --git a/src/kern/npf_bpf.c b/src/kern/npf_bpf.c
deleted file mode 100644
index 41363ac..0000000
--- a/src/kern/npf_bpf.c
+++ /dev/null
@@ -1,191 +0,0 @@
-/*-
- * Copyright (c) 2009-2013 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * This material is based upon work partially supported by The
- * NetBSD Foundation under a contract with Mindaugas Rasiukevicius.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
- * NPF byte-code processing.
- */
-
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD: npf_bpf.c,v 1.14 2018/09/29 14:41:36 rmind Exp $");
-
-#include <sys/types.h>
-#include <sys/param.h>
-
-#include <sys/bitops.h>
-#include <sys/mbuf.h>
-#include <net/bpf.h>
-#endif
-
-#define NPF_BPFCOP
-#include "npf_impl.h"
-
-#if defined(_NPF_STANDALONE)
-#define	m_length(m)		(nbuf)->nb_mops->getchainlen(m)
-#endif
-
-/*
- * BPF context and the coprocessor.
- */
-
-static bpf_ctx_t *npf_bpfctx __read_mostly;
-
-static uint32_t	npf_cop_l3(const bpf_ctx_t *, bpf_args_t *, uint32_t);
-static uint32_t	npf_cop_table(const bpf_ctx_t *, bpf_args_t *, uint32_t);
-
-static const bpf_copfunc_t npf_bpfcop[] = {
-	[NPF_COP_L3]	= npf_cop_l3,
-	[NPF_COP_TABLE]	= npf_cop_table,
-};
-
-#define	BPF_MW_ALLMASK \
-    ((1U << BPF_MW_IPVER) | (1U << BPF_MW_L4OFF) | (1U << BPF_MW_L4PROTO))
-
-void
-npf_bpf_sysinit(void)
-{
-	npf_bpfctx = bpf_create();
-	bpf_set_cop(npf_bpfctx, npf_bpfcop, __arraycount(npf_bpfcop));
-	bpf_set_extmem(npf_bpfctx, NPF_BPF_NWORDS, BPF_MW_ALLMASK);
-}
-
-void
-npf_bpf_sysfini(void)
-{
-	bpf_destroy(npf_bpfctx);
-}
-
-void
-npf_bpf_prepare(npf_cache_t *npc, bpf_args_t *args, uint32_t *M)
-{
-	nbuf_t *nbuf = npc->npc_nbuf;
-	const struct mbuf *mbuf = nbuf_head_mbuf(nbuf);
-	const size_t pktlen = m_length(mbuf);
-
-	/* Prepare the arguments for the BPF programs. */
-#ifdef _NPF_STANDALONE
-	args->pkt = (const uint8_t *)nbuf_dataptr(nbuf);
-	args->wirelen = args->buflen = pktlen;
-#else
-	args->pkt = (const uint8_t *)mbuf;
-	args->wirelen = pktlen;
-	args->buflen = 0;
-#endif
-	args->mem = M;
-	args->arg = npc;
-
-	/*
-	 * Convert address length to IP version.  Just mask out
-	 * number 4 or set 6 if higher bits set, such that:
-	 *
-	 *	0	=>	0
-	 *	4	=>	4 (IPVERSION)
-	 *	16	=>	6 (IPV6_VERSION >> 4)
-	 */
-	const u_int alen = npc->npc_alen;
-	const uint32_t ver = (alen & 4) | ((alen >> 4) * 6);
-
-	/*
-	 * Output words in the memory store:
-	 *	BPF_MW_IPVER	IP version (4 or 6).
-	 *	BPF_MW_L4OFF	L4 header offset.
-	 *	BPF_MW_L4PROTO	L4 protocol.
-	 */
-	M[BPF_MW_IPVER] = ver;
-	M[BPF_MW_L4OFF] = npc->npc_hlen;
-	M[BPF_MW_L4PROTO] = npc->npc_proto;
-}
-
-int
-npf_bpf_filter(bpf_args_t *args, const void *code, bpfjit_func_t jcode)
-{
-	/* Execute JIT-compiled code. */
-	if (__predict_true(jcode)) {
-		return jcode(npf_bpfctx, args);
-	}
-
-	/* Execute BPF byte-code. */
-	return bpf_filter_ext(npf_bpfctx, code, args);
-}
-
-void *
-npf_bpf_compile(void *code, size_t size)
-{
-	return bpf_jit_generate(npf_bpfctx, code, size);
-}
-
-bool
-npf_bpf_validate(const void *code, size_t len)
-{
-	const size_t icount = len / sizeof(struct bpf_insn);
-	return bpf_validate_ext(npf_bpfctx, code, icount) != 0;
-}
-
-/*
- * NPF_COP_L3: fetches layer 3 information.
- */
-static uint32_t
-npf_cop_l3(const bpf_ctx_t *bc, bpf_args_t *args, uint32_t A)
-{
-	const npf_cache_t * const npc = (const npf_cache_t *)args->arg;
-	const uint32_t ver = (npc->npc_alen & 4) | ((npc->npc_alen >> 4) * 6);
-	uint32_t * const M = args->mem;
-
-	M[BPF_MW_IPVER] = ver;
-	M[BPF_MW_L4OFF] = npc->npc_hlen;
-	M[BPF_MW_L4PROTO] = npc->npc_proto;
-	return ver; /* A <- IP version */
-}
-
-#define	SRC_FLAG_BIT	(1U << 31)
-
-/*
- * NPF_COP_TABLE: perform NPF table lookup.
- *
- *	A <- non-zero (true) if found and zero (false) otherwise
- */
-static uint32_t
-npf_cop_table(const bpf_ctx_t *bc, bpf_args_t *args, uint32_t A)
-{
-	const npf_cache_t * const npc = (const npf_cache_t *)args->arg;
-	npf_tableset_t *tblset = npf_config_tableset(npc->npc_ctx);
-	const uint32_t tid = A & (SRC_FLAG_BIT - 1);
-	const npf_addr_t *addr;
-	npf_table_t *t;
-
-	if (!npf_iscached(npc, NPC_IP46)) {
-		return 0;
-	}
-	t = npf_tableset_getbyid(tblset, tid);
-	if (__predict_false(!t)) {
-		return 0;
-	}
-	addr = npc->npc_ips[(A & SRC_FLAG_BIT) ? NPF_SRC : NPF_DST];
-	return npf_table_lookup(t, npc->npc_alen, addr) == 0;
-}
diff --git a/src/kern/npf_conf.c b/src/kern/npf_conf.c
deleted file mode 100644
index d7b1ad4..0000000
--- a/src/kern/npf_conf.c
+++ /dev/null
@@ -1,277 +0,0 @@
-/*-
- * Copyright (c) 2013-2020 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * This material is based upon work partially supported by The
- * NetBSD Foundation under a contract with Mindaugas Rasiukevicius.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
- * NPF configuration loading mechanism.
- *
- * The main operations on the configuration are the following:
- * 1) Read access, primarily from the npf_packet_handler() function.
- * 2) Write access on a particular set, mainly rule or table updates.
- * 3) Deletion of the configuration after the reload operation.
- *
- * Synchronization
- *
- *	For the (1) case, EBR is used to allow concurrent access to
- *	the configuration set (ruleset, etc).  It guarantees that the
- *	configuration will not be destroyed while accessing it.
- *
- *	For the cases (2) and (3), mutual exclusion (npf_t::config_lock)
- *	is used with, when necessary, the writer-side barrier of EBR.
- */
-
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD$");
-
-#include <sys/param.h>
-#include <sys/types.h>
-
-#include <sys/atomic.h>
-#include <sys/kmem.h>
-#include <sys/mutex.h>
-#endif
-
-#include "npf_impl.h"
-#include "npf_conn.h"
-
-void
-npf_config_init(npf_t *npf)
-{
-	npf_config_t *nc;
-
-	mutex_init(&npf->config_lock, MUTEX_DEFAULT, IPL_SOFTNET);
-	nc = npf_config_create();
-
-	/*
-	 * Load an empty configuration.
-	 */
-	nc->ruleset = npf_ruleset_create(0);
-	nc->nat_ruleset = npf_ruleset_create(0);
-	nc->rule_procs = npf_rprocset_create();
-	nc->tableset = npf_tableset_create(0);
-	nc->default_pass = true;
-
-	npf_config_load(npf, nc, NULL, true);
-	KASSERT(npf->config != NULL);
-}
-
-npf_config_t *
-npf_config_create(void)
-{
-	return kmem_zalloc(sizeof(npf_config_t), KM_SLEEP);
-}
-
-void
-npf_config_destroy(npf_config_t *nc)
-{
-	/*
-	 * Note: the rulesets must be destroyed first, in order to drop
-	 * any references to the tableset.
-	 */
-	if (nc->ruleset) {
-		npf_ruleset_destroy(nc->ruleset);
-	}
-	if (nc->nat_ruleset) {
-		npf_ruleset_destroy(nc->nat_ruleset);
-	}
-	if (nc->rule_procs) {
-		npf_rprocset_destroy(nc->rule_procs);
-	}
-	if (nc->tableset) {
-		npf_tableset_destroy(nc->tableset);
-	}
-	kmem_free(nc, sizeof(npf_config_t));
-}
-
-void
-npf_config_fini(npf_t *npf)
-{
-	npf_conndb_t *cd = npf_conndb_create();
-
-	/* Flush the connections. */
-	mutex_enter(&npf->config_lock);
-	npf_conn_tracking(npf, false);
-	npf_ebr_full_sync(npf->ebr);
-	npf_conn_load(npf, cd, false);
-	npf_ifmap_flush(npf);
-	mutex_exit(&npf->config_lock);
-
-	npf_config_destroy(npf->config);
-	mutex_destroy(&npf->config_lock);
-}
-
-/*
- * npf_config_load: the main routine performing configuration load.
- * Performs the necessary synchronization and destroys the old config.
- */
-void
-npf_config_load(npf_t *npf, npf_config_t *nc, npf_conndb_t *conns, bool flush)
-{
-	const bool load = conns != NULL;
-	npf_config_t *onc;
-
-	nc->default_pass = flush;
-
-	/*
-	 * Acquire the lock and perform the first phase:
-	 * - Scan and use existing dynamic tables, reload only static.
-	 * - Scan and use matching NAT policies to preserve the connections.
-	 */
-	mutex_enter(&npf->config_lock);
-	if ((onc = atomic_load_relaxed(&npf->config)) != NULL) {
-		npf_ruleset_reload(npf, nc->ruleset, onc->ruleset, load);
-		npf_tableset_reload(npf, nc->tableset, onc->tableset);
-		npf_ruleset_reload(npf, nc->nat_ruleset, onc->nat_ruleset, load);
-	}
-
-	/*
-	 * Set the new config and release the lock.
-	 */
-	membar_sync();
-	atomic_store_relaxed(&npf->config, nc);
-	if (onc == NULL) {
-		/* Initial load, done. */
-		npf_ifmap_flush(npf);
-		npf_conn_load(npf, conns, !flush);
-		mutex_exit(&npf->config_lock);
-		goto done;
-	}
-
-	/*
-	 * If we are going to flush the connections or load the new ones,
-	 * then disable the connection tracking for the grace period.
-	 */
-	if (flush || conns) {
-		npf_conn_tracking(npf, false);
-	}
-
-	/* Synchronise: drain all references. */
-	npf_ebr_full_sync(npf->ebr);
-	if (flush) {
-		npf_portmap_flush(npf->portmap);
-		npf_ifmap_flush(npf);
-	}
-
-	/*
-	 * G/C the existing connections and, if passed, load the new ones.
-	 * If not flushing - enable the connection tracking.
-	 */
-	npf_conn_load(npf, conns, !flush);
-	mutex_exit(&npf->config_lock);
-
-	/* Finally, it is safe to destroy the old config. */
-	npf_config_destroy(onc);
-done:
-	/* Sync all interface address tables (can be done asynchronously). */
-	npf_ifaddr_syncall(npf);
-}
-
-/*
- * Writer-side exclusive locking.
- */
-
-npf_config_t *
-npf_config_enter(npf_t *npf)
-{
-	mutex_enter(&npf->config_lock);
-	return npf->config;
-}
-
-void
-npf_config_exit(npf_t *npf)
-{
-	mutex_exit(&npf->config_lock);
-}
-
-bool
-npf_config_locked_p(npf_t *npf)
-{
-	return mutex_owned(&npf->config_lock);
-}
-
-void
-npf_config_sync(npf_t *npf)
-{
-	KASSERT(npf_config_locked_p(npf));
-	npf_ebr_full_sync(npf->ebr);
-}
-
-/*
- * Reader-side synchronization routines.
- */
-
-int
-npf_config_read_enter(npf_t *npf)
-{
-	/* Note: issues an acquire fence. */
-	return npf_ebr_enter(npf->ebr);
-}
-
-void
-npf_config_read_exit(npf_t *npf, int s)
-{
-	/* Note: issues a release fence. */
-	npf_ebr_exit(npf->ebr, s);
-}
-
-/*
- * Accessors.
- */
-
-npf_ruleset_t *
-npf_config_ruleset(npf_t *npf)
-{
-	npf_config_t *config = atomic_load_relaxed(&npf->config);
-	KASSERT(npf_config_locked_p(npf) || npf_ebr_incrit_p(npf->ebr));
-	return config->ruleset;
-}
-
-npf_ruleset_t *
-npf_config_natset(npf_t *npf)
-{
-	npf_config_t *config = atomic_load_relaxed(&npf->config);
-	KASSERT(npf_config_locked_p(npf) || npf_ebr_incrit_p(npf->ebr));
-	return config->nat_ruleset;
-}
-
-npf_tableset_t *
-npf_config_tableset(npf_t *npf)
-{
-	npf_config_t *config = atomic_load_relaxed(&npf->config);
-	KASSERT(npf_config_locked_p(npf) || npf_ebr_incrit_p(npf->ebr));
-	return config->tableset;
-}
-
-bool
-npf_default_pass(npf_t *npf)
-{
-	npf_config_t *config = atomic_load_relaxed(&npf->config);
-	KASSERT(npf_config_locked_p(npf) || npf_ebr_incrit_p(npf->ebr));
-	return config->default_pass;
-}
diff --git a/src/kern/npf_conn.c b/src/kern/npf_conn.c
deleted file mode 100644
index ec6b147..0000000
--- a/src/kern/npf_conn.c
+++ /dev/null
@@ -1,992 +0,0 @@
-/*-
- * Copyright (c) 2014-2020 Mindaugas Rasiukevicius <rmind at noxt eu>
- * Copyright (c) 2010-2014 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * This material is based upon work partially supported by The
- * NetBSD Foundation under a contract with Mindaugas Rasiukevicius.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
- * NPF connection tracking for stateful filtering and translation.
- *
- * Overview
- *
- *	Packets can be incoming or outgoing with respect to an interface.
- *	Connection direction is identified by the direction of its first
- *	packet.  The meaning of incoming/outgoing packet in the context of
- *	connection direction can be confusing.  Therefore, we will use the
- *	terms "forwards stream" and "backwards stream", where packets in
- *	the forwards stream mean the packets travelling in the direction
- *	as the connection direction.
- *
- *	All connections have two keys and thus two entries:
- *
- *	- npf_conn_getforwkey(con)        -- for the forwards stream;
- *	- npf_conn_getbackkey(con, alen)  -- for the backwards stream.
- *
- *	Note: the keys are stored in npf_conn_t::c_keys[], which is used
- *	to allocate variable-length npf_conn_t structures based on whether
- *	the IPv4 or IPv6 addresses are used.
- *
- *	The key is an n-tuple used to identify the connection flow: see the
- *	npf_connkey.c source file for the description of the key layouts.
- *	The key may be formed using translated values in a case of NAT.
- *
- *	Connections can serve two purposes: for the implicit passing and/or
- *	to accommodate the dynamic NAT.  Connections for the former purpose
- *	are created by the rules with "stateful" attribute and are used for
- *	stateful filtering.  Such connections indicate that the packet of
- *	the backwards stream should be passed without inspection of the
- *	ruleset.  The other purpose is to associate a dynamic NAT mechanism
- *	with a connection.  Such connections are created by the NAT policies
- *	and they have a relationship with NAT translation structure via
- *	npf_conn_t::c_nat.  A single connection can serve both purposes,
- *	which is a common case.
- *
- * Connection life-cycle
- *
- *	Connections are established when a packet matches said rule or
- *	NAT policy.  Both keys of the established connection are inserted
- *	into the connection database.  A garbage collection thread
- *	periodically scans all connections and depending on connection
- *	properties (e.g. last activity time, protocol) removes connection
- *	entries and expires the actual connections.
- *
- *	Each connection has a reference count.  The reference is acquired
- *	on lookup and should be released by the caller.  It guarantees that
- *	the connection will not be destroyed, although it may be expired.
- *
- * Synchronization
- *
- *	Connection database is accessed in a lock-free manner by the main
- *	routines: npf_conn_inspect() and npf_conn_establish().  Since they
- *	are always called from a software interrupt, the database is
- *	protected using EBR.  The main place which can destroy a connection
- *	is npf_conn_worker().  The database itself can be replaced and
- *	destroyed in npf_conn_reload().
- *
- * ALG support
- *
- *	Application-level gateways (ALGs) can override generic connection
- *	inspection (npf_alg_conn() call in npf_conn_inspect() function) by
- *	performing their own lookup using different key.  Recursive call
- *	to npf_conn_inspect() is not allowed.  The ALGs ought to use the
- *	npf_conn_lookup() function for this purpose.
- *
- * Lock order
- *
- *	npf_config_lock ->
- *		conn_lock ->
- *			npf_conn_t::c_lock
- */
-
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD$");
-
-#include <sys/param.h>
-#include <sys/types.h>
-
-#include <netinet/in.h>
-#include <netinet/tcp.h>
-
-#include <sys/atomic.h>
-#include <sys/kmem.h>
-#include <sys/mutex.h>
-#include <net/pfil.h>
-#include <sys/pool.h>
-#include <sys/queue.h>
-#include <sys/systm.h>
-#endif
-
-#define __NPF_CONN_PRIVATE
-#include "npf_conn.h"
-#include "npf_impl.h"
-
-/* A helper to select the IPv4 or IPv6 connection cache. */
-#define	NPF_CONNCACHE(alen)	(((alen) >> 4) & 0x1)
-
-/*
- * Connection flags: PFIL_IN and PFIL_OUT values are reserved for direction.
- */
-CTASSERT(PFIL_ALL == (0x001 | 0x002));
-#define	CONN_ACTIVE	0x004	/* visible on inspection */
-#define	CONN_PASS	0x008	/* perform implicit passing */
-#define	CONN_EXPIRE	0x010	/* explicitly expire */
-#define	CONN_REMOVED	0x020	/* "forw/back" entries removed */
-
-enum { CONN_TRACKING_OFF, CONN_TRACKING_ON };
-
-static int	npf_conn_export(npf_t *, npf_conn_t *, nvlist_t *);
-
-/*
- * npf_conn_sys{init,fini}: initialize/destroy connection tracking.
- */
-
-void
-npf_conn_init(npf_t *npf)
-{
-	npf_conn_params_t *params = npf_param_allocgroup(npf,
-	    NPF_PARAMS_CONN, sizeof(npf_conn_params_t));
-	npf_param_t param_map[] = {
-		{
-			"state.key.interface",
-			&params->connkey_interface,
-			.default_val = 1, // true
-			.min = 0, .max = 1
-		},
-		{
-			"state.key.direction",
-			&params->connkey_direction,
-			.default_val = 1, // true
-			.min = 0, .max = 1
-		},
-	};
-	npf_param_register(npf, param_map, __arraycount(param_map));
-
-	npf->conn_cache[0] = pool_cache_init(
-	    offsetof(npf_conn_t, c_keys[NPF_CONNKEY_V4WORDS * 2]),
-	    0, 0, 0, "npfcn4pl", NULL, IPL_NET, NULL, NULL, NULL);
-	npf->conn_cache[1] = pool_cache_init(
-	    offsetof(npf_conn_t, c_keys[NPF_CONNKEY_V6WORDS * 2]),
-	    0, 0, 0, "npfcn6pl", NULL, IPL_NET, NULL, NULL, NULL);
-
-	mutex_init(&npf->conn_lock, MUTEX_DEFAULT, IPL_NONE);
-	atomic_store_relaxed(&npf->conn_tracking, CONN_TRACKING_OFF);
-	npf->conn_db = npf_conndb_create();
-	npf_conndb_sysinit(npf);
-
-	npf_worker_addfunc(npf, npf_conn_worker);
-}
-
-void
-npf_conn_fini(npf_t *npf)
-{
-	const size_t len = sizeof(npf_conn_params_t);
-
-	/* Note: the caller should have flushed the connections. */
-	KASSERT(atomic_load_relaxed(&npf->conn_tracking) == CONN_TRACKING_OFF);
-
-	npf_conndb_destroy(npf->conn_db);
-	pool_cache_destroy(npf->conn_cache[0]);
-	pool_cache_destroy(npf->conn_cache[1]);
-	mutex_destroy(&npf->conn_lock);
-
-	npf_param_freegroup(npf, NPF_PARAMS_CONN, len);
-	npf_conndb_sysfini(npf);
-}
-
-/*
- * npf_conn_load: perform the load by flushing the current connection
- * database and replacing it with the new one or just destroying.
- *
- * => The caller must disable the connection tracking and ensure that
- *    there are no connection database lookups or references in-flight.
- */
-void
-npf_conn_load(npf_t *npf, npf_conndb_t *ndb, bool track)
-{
-	npf_conndb_t *odb = NULL;
-
-	KASSERT(npf_config_locked_p(npf));
-
-	/*
-	 * The connection database is in the quiescent state.
-	 * Prevent G/C thread from running and install a new database.
-	 */
-	mutex_enter(&npf->conn_lock);
-	if (ndb) {
-		KASSERT(atomic_load_relaxed(&npf->conn_tracking)
-		    == CONN_TRACKING_OFF);
-		odb = atomic_load_relaxed(&npf->conn_db);
-		membar_sync();
-		atomic_store_relaxed(&npf->conn_db, ndb);
-	}
-	if (track) {
-		/* After this point lookups start flying in. */
-		membar_producer();
-		atomic_store_relaxed(&npf->conn_tracking, CONN_TRACKING_ON);
-	}
-	mutex_exit(&npf->conn_lock);
-
-	if (odb) {
-		/*
-		 * Flush all, no sync since the caller did it for us.
-		 * Also, release the pool cache memory.
-		 */
-		npf_conndb_gc(npf, odb, true, false);
-		npf_conndb_destroy(odb);
-		pool_cache_invalidate(npf->conn_cache[0]);
-		pool_cache_invalidate(npf->conn_cache[1]);
-	}
-}
-
-/*
- * npf_conn_tracking: enable/disable connection tracking.
- */
-void
-npf_conn_tracking(npf_t *npf, bool track)
-{
-	KASSERT(npf_config_locked_p(npf));
-	atomic_store_relaxed(&npf->conn_tracking,
-	    track ? CONN_TRACKING_ON : CONN_TRACKING_OFF);
-}
-
-static inline bool
-npf_conn_trackable_p(const npf_cache_t *npc)
-{
-	const npf_t *npf = npc->npc_ctx;
-
-	/*
-	 * Check if connection tracking is on.  Also, if layer 3 and 4 are
-	 * not cached - protocol is not supported or packet is invalid.
-	 */
-	if (atomic_load_relaxed(&npf->conn_tracking) != CONN_TRACKING_ON) {
-		return false;
-	}
-	if (!npf_iscached(npc, NPC_IP46) || !npf_iscached(npc, NPC_LAYER4)) {
-		return false;
-	}
-	return true;
-}
-
-static inline void
-conn_update_atime(npf_conn_t *con)
-{
-	struct timespec tsnow;
-
-	getnanouptime(&tsnow);
-	atomic_store_relaxed(&con->c_atime, tsnow.tv_sec);
-}
-
-/*
- * npf_conn_check: check that:
- *
- *	- the connection is active;
- *
- *	- the packet is travelling in the right direction with the respect
- *	  to the connection direction (if interface-id is not zero);
- *
- *	- the packet is travelling on the same interface as the
- *	  connection interface (if interface-id is not zero).
- */
-static bool
-npf_conn_check(const npf_conn_t *con, const nbuf_t *nbuf,
-    const unsigned di, const npf_flow_t flow)
-{
-	const uint32_t flags = atomic_load_relaxed(&con->c_flags);
-	const unsigned ifid = atomic_load_relaxed(&con->c_ifid);
-	bool active;
-
-	active = (flags & (CONN_ACTIVE | CONN_EXPIRE)) == CONN_ACTIVE;
-	if (__predict_false(!active)) {
-		return false;
-	}
-	if (ifid && nbuf) {
-		const bool match = (flags & PFIL_ALL) == di;
-		npf_flow_t pflow = match ? NPF_FLOW_FORW : NPF_FLOW_BACK;
-
-		if (__predict_false(flow != pflow)) {
-			return false;
-		}
-		if (__predict_false(ifid != nbuf->nb_ifid)) {
-			return false;
-		}
-	}
-	return true;
-}
-
-/*
- * npf_conn_lookup: lookup if there is an established connection.
- *
- * => If found, we will hold a reference for the caller.
- */
-npf_conn_t *
-npf_conn_lookup(const npf_cache_t *npc, const unsigned di, npf_flow_t *flow)
-{
-	npf_t *npf = npc->npc_ctx;
-	const nbuf_t *nbuf = npc->npc_nbuf;
-	npf_conn_t *con;
-	npf_connkey_t key;
-
-	/* Construct a key and lookup for a connection in the store. */
-	if (!npf_conn_conkey(npc, &key, di, NPF_FLOW_FORW)) {
-		return NULL;
-	}
-	con = npf_conndb_lookup(npf, &key, flow);
-	if (con == NULL) {
-		return NULL;
-	}
-	KASSERT(npc->npc_proto == atomic_load_relaxed(&con->c_proto));
-
-	/* Extra checks for the connection and packet. */
-	if (!npf_conn_check(con, nbuf, di, *flow)) {
-		atomic_dec_uint(&con->c_refcnt);
-		return NULL;
-	}
-
-	/* Update the last activity time. */
-	conn_update_atime(con);
-	return con;
-}
-
-/*
- * npf_conn_inspect: lookup a connection and inspecting the protocol data.
- *
- * => If found, we will hold a reference for the caller.
- */
-npf_conn_t *
-npf_conn_inspect(npf_cache_t *npc, const unsigned di, int *error)
-{
-	nbuf_t *nbuf = npc->npc_nbuf;
-	npf_flow_t flow;
-	npf_conn_t *con;
-	bool ok;
-
-	KASSERT(!nbuf_flag_p(nbuf, NBUF_DATAREF_RESET));
-	if (!npf_conn_trackable_p(npc)) {
-		return NULL;
-	}
-
-	/* Query ALG which may lookup connection for us. */
-	if ((con = npf_alg_conn(npc, di)) != NULL) {
-		/* Note: reference is held. */
-		return con;
-	}
-	if (nbuf_head_mbuf(nbuf) == NULL) {
-		*error = ENOMEM;
-		return NULL;
-	}
-	KASSERT(!nbuf_flag_p(nbuf, NBUF_DATAREF_RESET));
-
-	/* The main lookup of the connection (acquires a reference). */
-	if ((con = npf_conn_lookup(npc, di, &flow)) == NULL) {
-		return NULL;
-	}
-
-	/* Inspect the protocol data and handle state changes. */
-	mutex_enter(&con->c_lock);
-	ok = npf_state_inspect(npc, &con->c_state, flow);
-	mutex_exit(&con->c_lock);
-
-	/* If invalid state: let the rules deal with it. */
-	if (__predict_false(!ok)) {
-		npf_conn_release(con);
-		npf_stats_inc(npc->npc_ctx, NPF_STAT_INVALID_STATE);
-		return NULL;
-	}
-#if 0
-	/*
-	 * TODO -- determine when this might be wanted/used.
-	 *
-	 * Note: skipping the connection lookup and ruleset inspection
-	 * on other interfaces will also bypass dynamic NAT.
-	 */
-	if (atomic_load_relaxed(&con->c_flags) & CONN_GPASS) {
-		/*
-		 * Note: if tagging fails, then give this packet a chance
-		 * to go through a regular ruleset.
-		 */
-		(void)nbuf_add_tag(nbuf, NPF_NTAG_PASS);
-	}
-#endif
-	return con;
-}
-
-/*
- * npf_conn_establish: create a new connection, insert into the global list.
- *
- * => Connection is created with the reference held for the caller.
- * => Connection will be activated on the first reference release.
- */
-npf_conn_t *
-npf_conn_establish(npf_cache_t *npc, const unsigned di, bool global)
-{
-	npf_t *npf = npc->npc_ctx;
-	const unsigned alen = npc->npc_alen;
-	const unsigned idx = NPF_CONNCACHE(alen);
-	const nbuf_t *nbuf = npc->npc_nbuf;
-	npf_connkey_t *fw, *bk;
-	npf_conndb_t *conn_db;
-	npf_conn_t *con;
-	int error = 0;
-
-	KASSERT(!nbuf_flag_p(nbuf, NBUF_DATAREF_RESET));
-
-	if (!npf_conn_trackable_p(npc)) {
-		return NULL;
-	}
-
-	/* Allocate and initialize the new connection. */
-	con = pool_cache_get(npf->conn_cache[idx], PR_NOWAIT);
-	if (__predict_false(!con)) {
-		npf_worker_signal(npf);
-		return NULL;
-	}
-	NPF_PRINTF(("NPF: create conn %p\n", con));
-	npf_stats_inc(npf, NPF_STAT_CONN_CREATE);
-
-	mutex_init(&con->c_lock, MUTEX_DEFAULT, IPL_SOFTNET);
-	atomic_store_relaxed(&con->c_flags, di & PFIL_ALL);
-	atomic_store_relaxed(&con->c_refcnt, 0);
-	con->c_rproc = NULL;
-	con->c_nat = NULL;
-
-	con->c_proto = npc->npc_proto;
-	CTASSERT(sizeof(con->c_proto) >= sizeof(npc->npc_proto));
-	con->c_alen = alen;
-
-	/* Initialize the protocol state. */
-	if (!npf_state_init(npc, &con->c_state)) {
-		npf_conn_destroy(npf, con);
-		return NULL;
-	}
-	KASSERT(npf_iscached(npc, NPC_IP46));
-
-	fw = npf_conn_getforwkey(con);
-	bk = npf_conn_getbackkey(con, alen);
-
-	/*
-	 * Construct "forwards" and "backwards" keys.  Also, set the
-	 * interface ID for this connection (unless it is global).
-	 */
-	if (!npf_conn_conkey(npc, fw, di, NPF_FLOW_FORW) ||
-	    !npf_conn_conkey(npc, bk, di ^ PFIL_ALL, NPF_FLOW_BACK)) {
-		npf_conn_destroy(npf, con);
-		return NULL;
-	}
-	con->c_ifid = global ? nbuf->nb_ifid : 0;
-
-	/*
-	 * Set last activity time for a new connection and acquire
-	 * a reference for the caller before we make it visible.
-	 */
-	conn_update_atime(con);
-	atomic_store_relaxed(&con->c_refcnt, 1);
-
-	/*
-	 * Insert both keys (entries representing directions) of the
-	 * connection.  At this point it becomes visible, but we activate
-	 * the connection later.
-	 */
-	mutex_enter(&con->c_lock);
-	conn_db = atomic_load_relaxed(&npf->conn_db);
-	if (!npf_conndb_insert(conn_db, fw, con, NPF_FLOW_FORW)) {
-		error = EISCONN;
-		goto err;
-	}
-	if (!npf_conndb_insert(conn_db, bk, con, NPF_FLOW_BACK)) {
-		npf_conn_t *ret __diagused;
-		ret = npf_conndb_remove(conn_db, fw);
-		KASSERT(ret == con);
-		error = EISCONN;
-		goto err;
-	}
-err:
-	/*
-	 * If we have hit the duplicate: mark the connection as expired
-	 * and let the G/C thread to take care of it.  We cannot do it
-	 * here since there might be references acquired already.
-	 */
-	if (error) {
-		atomic_or_uint(&con->c_flags, CONN_REMOVED | CONN_EXPIRE);
-		atomic_dec_uint(&con->c_refcnt);
-		npf_stats_inc(npf, NPF_STAT_RACE_CONN);
-	} else {
-		NPF_PRINTF(("NPF: establish conn %p\n", con));
-	}
-
-	/* Finally, insert into the connection list. */
-	npf_conndb_enqueue(conn_db, con);
-	mutex_exit(&con->c_lock);
-
-	return error ? NULL : con;
-}
-
-void
-npf_conn_destroy(npf_t *npf, npf_conn_t *con)
-{
-	const unsigned idx __unused = NPF_CONNCACHE(con->c_alen);
-
-	KASSERT(atomic_load_relaxed(&con->c_refcnt) == 0);
-
-	if (con->c_nat) {
-		/* Release any NAT structures. */
-		npf_nat_destroy(con, con->c_nat);
-	}
-	if (con->c_rproc) {
-		/* Release the rule procedure. */
-		npf_rproc_release(con->c_rproc);
-	}
-
-	/* Destroy the state. */
-	npf_state_destroy(&con->c_state);
-	mutex_destroy(&con->c_lock);
-
-	/* Free the structure, increase the counter. */
-	pool_cache_put(npf->conn_cache[idx], con);
-	npf_stats_inc(npf, NPF_STAT_CONN_DESTROY);
-	NPF_PRINTF(("NPF: conn %p destroyed\n", con));
-}
-
-/*
- * npf_conn_setnat: associate NAT entry with the connection, update and
- * re-insert connection entry using the translation values.
- *
- * => The caller must be holding a reference.
- */
-int
-npf_conn_setnat(const npf_cache_t *npc, npf_conn_t *con,
-    npf_nat_t *nt, unsigned ntype)
-{
-	static const unsigned nat_type_which[] = {
-		/* See the description in npf_nat_which(). */
-		[NPF_NATOUT] = NPF_DST,
-		[NPF_NATIN] = NPF_SRC,
-	};
-	npf_t *npf = npc->npc_ctx;
-	npf_conn_t *ret __diagused;
-	npf_conndb_t *conn_db;
-	npf_connkey_t *bk;
-	npf_addr_t *taddr;
-	in_port_t tport;
-	uint32_t flags;
-
-	KASSERT(atomic_load_relaxed(&con->c_refcnt) > 0);
-
-	npf_nat_gettrans(nt, &taddr, &tport);
-	KASSERT(ntype == NPF_NATOUT || ntype == NPF_NATIN);
-
-	/* Acquire the lock and check for the races. */
-	mutex_enter(&con->c_lock);
-	flags = atomic_load_relaxed(&con->c_flags);
-	if (__predict_false(flags & CONN_EXPIRE)) {
-		/* The connection got expired. */
-		mutex_exit(&con->c_lock);
-		return EINVAL;
-	}
-	KASSERT((flags & CONN_REMOVED) == 0);
-
-	if (__predict_false(con->c_nat != NULL)) {
-		/* Race with a duplicate packet. */
-		mutex_exit(&con->c_lock);
-		npf_stats_inc(npc->npc_ctx, NPF_STAT_RACE_NAT);
-		return EISCONN;
-	}
-
-	/* Remove the "backwards" key. */
-	conn_db = atomic_load_relaxed(&npf->conn_db);
-	bk = npf_conn_getbackkey(con, con->c_alen);
-	ret = npf_conndb_remove(conn_db, bk);
-	KASSERT(ret == con);
-
-	/* Set the source/destination IDs to the translation values. */
-	npf_conn_adjkey(bk, taddr, tport, nat_type_which[ntype]);
-
-	/* Finally, re-insert the "backwards" key. */
-	if (!npf_conndb_insert(conn_db, bk, con, NPF_FLOW_BACK)) {
-		/*
-		 * Race: we have hit the duplicate, remove the "forwards"
-		 * key and expire our connection; it is no longer valid.
-		 */
-		npf_connkey_t *fw = npf_conn_getforwkey(con);
-		ret = npf_conndb_remove(conn_db, fw);
-		KASSERT(ret == con);
-
-		atomic_or_uint(&con->c_flags, CONN_REMOVED | CONN_EXPIRE);
-		mutex_exit(&con->c_lock);
-
-		npf_stats_inc(npc->npc_ctx, NPF_STAT_RACE_NAT);
-		return EISCONN;
-	}
-
-	/* Associate the NAT entry and release the lock. */
-	con->c_nat = nt;
-	mutex_exit(&con->c_lock);
-	return 0;
-}
-
-/*
- * npf_conn_expire: explicitly mark connection as expired.
- *
- * => Must be called with: a) reference held  b) the relevant lock held.
- *    The relevant lock should prevent from connection destruction, e.g.
- *    npf_t::conn_lock or npf_natpolicy_t::n_lock.
- */
-void
-npf_conn_expire(npf_conn_t *con)
-{
-	atomic_or_uint(&con->c_flags, CONN_EXPIRE);
-}
-
-/*
- * npf_conn_pass: return true if connection is "pass" one, otherwise false.
- */
-bool
-npf_conn_pass(const npf_conn_t *con, npf_match_info_t *mi, npf_rproc_t **rp)
-{
-	KASSERT(atomic_load_relaxed(&con->c_refcnt) > 0);
-	if (__predict_true(atomic_load_relaxed(&con->c_flags) & CONN_PASS)) {
-		mi->mi_retfl = atomic_load_relaxed(&con->c_retfl);
-		mi->mi_rid = con->c_rid;
-		*rp = con->c_rproc;
-		return true;
-	}
-	return false;
-}
-
-/*
- * npf_conn_setpass: mark connection as a "pass" one and associate the
- * rule procedure with it.
- */
-void
-npf_conn_setpass(npf_conn_t *con, const npf_match_info_t *mi, npf_rproc_t *rp)
-{
-	KASSERT((atomic_load_relaxed(&con->c_flags) & CONN_ACTIVE) == 0);
-	KASSERT(atomic_load_relaxed(&con->c_refcnt) > 0);
-	KASSERT(con->c_rproc == NULL);
-
-	/*
-	 * No need for atomic since the connection is not yet active.
-	 * If rproc is set, the caller transfers its reference to us,
-	 * which will be released on npf_conn_destroy().
-	 */
-	atomic_or_uint(&con->c_flags, CONN_PASS);
-	con->c_rproc = rp;
-	if (rp) {
-		con->c_rid = mi->mi_rid;
-		con->c_retfl = mi->mi_retfl;
-	}
-}
-
-/*
- * npf_conn_release: release a reference, which might allow G/C thread
- * to destroy this connection.
- */
-void
-npf_conn_release(npf_conn_t *con)
-{
-	const unsigned flags = atomic_load_relaxed(&con->c_flags);
-
-	if ((flags & (CONN_ACTIVE | CONN_EXPIRE)) == 0) {
-		/* Activate: after this, connection is globally visible. */
-		atomic_or_uint(&con->c_flags, CONN_ACTIVE);
-	}
-	KASSERT(atomic_load_relaxed(&con->c_refcnt) > 0);
-	atomic_dec_uint(&con->c_refcnt);
-}
-
-/*
- * npf_conn_getnat: return the associated NAT entry, if any.
- */
-npf_nat_t *
-npf_conn_getnat(const npf_conn_t *con)
-{
-	return con->c_nat;
-}
-
-/*
- * npf_conn_expired: criterion to check if connection is expired.
- */
-bool
-npf_conn_expired(npf_t *npf, const npf_conn_t *con, uint64_t tsnow)
-{
-	const unsigned flags = atomic_load_relaxed(&con->c_flags);
-	const int etime = npf_state_etime(npf, &con->c_state, con->c_proto);
-	int elapsed;
-
-	if (__predict_false(flags & CONN_EXPIRE)) {
-		/* Explicitly marked to be expired. */
-		return true;
-	}
-
-	/*
-	 * Note: another thread may update 'atime' and it might
-	 * become greater than 'now'.
-	 */
-	elapsed = (int64_t)tsnow - atomic_load_relaxed(&con->c_atime);
-	return elapsed > etime;
-}
-
-/*
- * npf_conn_remove: unlink the connection and mark as expired.
- */
-void
-npf_conn_remove(npf_conndb_t *cd, npf_conn_t *con)
-{
-	/* Remove both entries of the connection. */
-	mutex_enter(&con->c_lock);
-	if ((atomic_load_relaxed(&con->c_flags) & CONN_REMOVED) == 0) {
-		npf_connkey_t *fw, *bk;
-		npf_conn_t *ret __diagused;
-
-		fw = npf_conn_getforwkey(con);
-		ret = npf_conndb_remove(cd, fw);
-		KASSERT(ret == con);
-
-		bk = npf_conn_getbackkey(con, NPF_CONNKEY_ALEN(fw));
-		ret = npf_conndb_remove(cd, bk);
-		KASSERT(ret == con);
-	}
-
-	/* Flag the removal and expiration. */
-	atomic_or_uint(&con->c_flags, CONN_REMOVED | CONN_EXPIRE);
-	mutex_exit(&con->c_lock);
-}
-
-/*
- * npf_conn_worker: G/C to run from a worker thread or via npfk_gc().
- */
-void
-npf_conn_worker(npf_t *npf)
-{
-	npf_conndb_t *conn_db = atomic_load_relaxed(&npf->conn_db);
-	npf_conndb_gc(npf, conn_db, false, true);
-}
-
-/*
- * npf_conndb_export: construct a list of connections prepared for saving.
- * Note: this is expected to be an expensive operation.
- */
-int
-npf_conndb_export(npf_t *npf, nvlist_t *nvl)
-{
-	npf_conn_t *head, *con;
-	npf_conndb_t *conn_db;
-
-	/*
-	 * Note: acquire conn_lock to prevent from the database
-	 * destruction and G/C thread.
-	 */
-	mutex_enter(&npf->conn_lock);
-	if (atomic_load_relaxed(&npf->conn_tracking) != CONN_TRACKING_ON) {
-		mutex_exit(&npf->conn_lock);
-		return 0;
-	}
-	conn_db = atomic_load_relaxed(&npf->conn_db);
-	head = npf_conndb_getlist(conn_db);
-	con = head;
-	while (con) {
-		nvlist_t *con_nvl;
-
-		con_nvl = nvlist_create(0);
-		if (npf_conn_export(npf, con, con_nvl) == 0) {
-			nvlist_append_nvlist_array(nvl, "conn-list", con_nvl);
-		}
-		nvlist_destroy(con_nvl);
-
-		if ((con = npf_conndb_getnext(conn_db, con)) == head) {
-			break;
-		}
-	}
-	mutex_exit(&npf->conn_lock);
-	return 0;
-}
-
-/*
- * npf_conn_export: serialize a single connection.
- */
-static int
-npf_conn_export(npf_t *npf, npf_conn_t *con, nvlist_t *nvl)
-{
-	nvlist_t *knvl;
-	npf_connkey_t *fw, *bk;
-	unsigned flags, alen;
-
-	flags = atomic_load_relaxed(&con->c_flags);
-	if ((flags & (CONN_ACTIVE|CONN_EXPIRE)) != CONN_ACTIVE) {
-		return ESRCH;
-	}
-	nvlist_add_number(nvl, "flags", flags);
-	nvlist_add_number(nvl, "proto", con->c_proto);
-	if (con->c_ifid) {
-		char ifname[IFNAMSIZ];
-		npf_ifmap_copyname(npf, con->c_ifid, ifname, sizeof(ifname));
-		nvlist_add_string(nvl, "ifname", ifname);
-	}
-	nvlist_add_binary(nvl, "state", &con->c_state, sizeof(npf_state_t));
-
-	fw = npf_conn_getforwkey(con);
-	alen = NPF_CONNKEY_ALEN(fw);
-	KASSERT(alen == con->c_alen);
-	bk = npf_conn_getbackkey(con, alen);
-
-	knvl = npf_connkey_export(npf, fw);
-	nvlist_move_nvlist(nvl, "forw-key", knvl);
-
-	knvl = npf_connkey_export(npf, bk);
-	nvlist_move_nvlist(nvl, "back-key", knvl);
-
-	/* Let the address length be based on on first key. */
-	nvlist_add_number(nvl, "alen", alen);
-
-	if (con->c_nat) {
-		npf_nat_export(npf, con->c_nat, nvl);
-	}
-	return 0;
-}
-
-/*
- * npf_conn_import: fully reconstruct a single connection from a
- * nvlist and insert into the given database.
- */
-int
-npf_conn_import(npf_t *npf, npf_conndb_t *cd, const nvlist_t *cdict,
-    npf_ruleset_t *natlist)
-{
-	npf_conn_t *con;
-	npf_connkey_t *fw, *bk;
-	const nvlist_t *nat, *conkey;
-	unsigned flags, alen, idx;
-	const char *ifname;
-	const void *state;
-	size_t len;
-
-	/*
-	 * To determine the length of the connection, which depends
-	 * on the address length in the connection keys.
-	 */
-	alen = dnvlist_get_number(cdict, "alen", 0);
-	idx = NPF_CONNCACHE(alen);
-
-	/* Allocate a connection and initialize it (clear first). */
-	con = pool_cache_get(npf->conn_cache[idx], PR_WAITOK);
-	memset(con, 0, sizeof(npf_conn_t));
-	mutex_init(&con->c_lock, MUTEX_DEFAULT, IPL_SOFTNET);
-	npf_stats_inc(npf, NPF_STAT_CONN_CREATE);
-
-	con->c_proto = dnvlist_get_number(cdict, "proto", 0);
-	flags = dnvlist_get_number(cdict, "flags", 0);
-	flags &= PFIL_ALL | CONN_ACTIVE | CONN_PASS;
-	atomic_store_relaxed(&con->c_flags, flags);
-	conn_update_atime(con);
-
-	ifname = dnvlist_get_string(cdict, "ifname", NULL);
-	if (ifname && (con->c_ifid = npf_ifmap_register(npf, ifname)) == 0) {
-		goto err;
-	}
-
-	state = dnvlist_get_binary(cdict, "state", &len, NULL, 0);
-	if (!state || len != sizeof(npf_state_t)) {
-		goto err;
-	}
-	memcpy(&con->c_state, state, sizeof(npf_state_t));
-
-	/* Reconstruct NAT association, if any. */
-	if ((nat = dnvlist_get_nvlist(cdict, "nat", NULL)) != NULL &&
-	    (con->c_nat = npf_nat_import(npf, nat, natlist, con)) == NULL) {
-		goto err;
-	}
-
-	/*
-	 * Fetch and copy the keys for each direction.
-	 */
-	fw = npf_conn_getforwkey(con);
-	conkey = dnvlist_get_nvlist(cdict, "forw-key", NULL);
-	if (conkey == NULL || !npf_connkey_import(npf, conkey, fw)) {
-		goto err;
-	}
-	bk = npf_conn_getbackkey(con, NPF_CONNKEY_ALEN(fw));
-	conkey = dnvlist_get_nvlist(cdict, "back-key", NULL);
-	if (conkey == NULL || !npf_connkey_import(npf, conkey, bk)) {
-		goto err;
-	}
-
-	/* Guard against the contradicting address lengths. */
-	if (NPF_CONNKEY_ALEN(fw) != alen || NPF_CONNKEY_ALEN(bk) != alen) {
-		goto err;
-	}
-
-	/* Insert the entries and the connection itself. */
-	if (!npf_conndb_insert(cd, fw, con, NPF_FLOW_FORW)) {
-		goto err;
-	}
-	if (!npf_conndb_insert(cd, bk, con, NPF_FLOW_BACK)) {
-		npf_conndb_remove(cd, fw);
-		goto err;
-	}
-
-	NPF_PRINTF(("NPF: imported conn %p\n", con));
-	npf_conndb_enqueue(cd, con);
-	return 0;
-err:
-	npf_conn_destroy(npf, con);
-	return EINVAL;
-}
-
-/*
- * npf_conn_find: lookup a connection in the list of connections
- */
-int
-npf_conn_find(npf_t *npf, const nvlist_t *req, nvlist_t *resp)
-{
-	const nvlist_t *key_nv;
-	npf_conn_t *con;
-	npf_connkey_t key;
-	npf_flow_t flow;
-	int error;
-
-	key_nv = dnvlist_get_nvlist(req, "key", NULL);
-	if (!key_nv || !npf_connkey_import(npf, key_nv, &key)) {
-		return EINVAL;
-	}
-	con = npf_conndb_lookup(npf, &key, &flow);
-	if (con == NULL) {
-		return ESRCH;
-	}
-	if (!npf_conn_check(con, NULL, 0, NPF_FLOW_FORW)) {
-		atomic_dec_uint(&con->c_refcnt);
-		return ESRCH;
-	}
-	error = npf_conn_export(npf, con, resp);
-	nvlist_add_number(resp, "flow", flow);
-	atomic_dec_uint(&con->c_refcnt);
-	return error;
-}
-
-#if defined(DDB) || defined(_NPF_TESTING)
-
-void
-npf_conn_print(npf_conn_t *con)
-{
-	const npf_connkey_t *fw = npf_conn_getforwkey(con);
-	const npf_connkey_t *bk = npf_conn_getbackkey(con, NPF_CONNKEY_ALEN(fw));
-	const unsigned flags = atomic_load_relaxed(&con->c_flags);
-	const unsigned proto = con->c_proto;
-	struct timespec tspnow;
-
-	getnanouptime(&tspnow);
-	printf("%p:\n\tproto %d flags 0x%x tsdiff %ld etime %d\n", con,
-	    proto, flags, (long)(tspnow.tv_sec - con->c_atime),
-	    npf_state_etime(npf_getkernctx(), &con->c_state, proto));
-	npf_connkey_print(fw);
-	npf_connkey_print(bk);
-	npf_state_dump(&con->c_state);
-	if (con->c_nat) {
-		npf_nat_dump(con->c_nat);
-	}
-}
-
-#endif
diff --git a/src/kern/npf_conn.h b/src/kern/npf_conn.h
deleted file mode 100644
index 0e0bc5d..0000000
--- a/src/kern/npf_conn.h
+++ /dev/null
@@ -1,180 +0,0 @@
-/*-
- * Copyright (c) 2009-2020 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * This material is based upon work partially supported by The
- * NetBSD Foundation under a contract with Mindaugas Rasiukevicius.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef _NPF_CONN_H_
-#define _NPF_CONN_H_
-
-#if !defined(_KERNEL) && !defined(_NPF_STANDALONE)
-#error "kernel-level header only"
-#endif
-
-#include <sys/types.h>
-
-#include "npf_impl.h"
-
-#if defined(__NPF_CONN_PRIVATE)
-
-/*
- * The main connection tracking structure.
- */
-struct npf_conn {
-	/*
-	 * Protocol, address length, the interface ID (if zero,
-	 * then the state is global) and connection flags.
-	 */
-	uint16_t		c_proto;
-	uint16_t		c_alen;
-	unsigned		c_ifid;
-	unsigned		c_flags;
-
-	/* Matching rule flags and ID. */
-	unsigned		c_retfl;
-	uint64_t		c_rid;
-
-	/*
-	 * Entry in the connection database/list.  The entry is
-	 * protected by npf_t::conn_lock.
-	 */
-	union {
-		npf_conn_t *		c_next;
-		LIST_ENTRY(npf_conn)	c_entry;
-	};
-
-	/* Associated rule procedure or NAT (if any). */
-	npf_rproc_t *		c_rproc;
-	npf_nat_t *		c_nat;
-
-	/*
-	 * The Reference count and the last activity time (used to
-	 * calculate expiration time).  Note: *unsigned* 32-bit integer
-	 * as a timestamp is sufficient for us.
-	 */
-	unsigned		c_refcnt;
-	uint32_t		c_atime;
-
-	/* The protocol state and lock. */
-	kmutex_t		c_lock;
-	npf_state_t		c_state;
-
-	/*
-	 * Connection "forwards" and "backwards" keys.  They are accessed
-	 * as npf_connkey_t, see below and npf_conn_getkey().
-	 */
-	uint32_t		c_keys[];
-};
-
-typedef struct {
-	int	connkey_interface;
-	int	connkey_direction;
-} npf_conn_params_t;
-
-#endif
-
-/*
- * Connection key interface.
- *
- * See the key layout description in the npf_connkey.c source file.
- */
-
-#define	NPF_CONNKEY_V4WORDS	(2 + ((sizeof(struct in_addr) * 2) >> 2))
-#define	NPF_CONNKEY_V6WORDS	(2 + ((sizeof(struct in6_addr) * 2) >> 2))
-#define	NPF_CONNKEY_MAXWORDS	(NPF_CONNKEY_V6WORDS)
-
-#define	NPF_CONNKEY_ALEN(key)	(((key)->ck_key[0] >> 28) << 2)
-#define	NPF_CONNKEY_LEN(key)	(8 + (NPF_CONNKEY_ALEN(key) * 2))
-
-typedef struct npf_connkey {
-	/* Warning: ck_key has a variable length -- see above. */
-	uint32_t		ck_key[NPF_CONNKEY_MAXWORDS];
-} npf_connkey_t;
-
-unsigned	npf_conn_conkey(const npf_cache_t *, npf_connkey_t *,
-		    const unsigned, const npf_flow_t);
-npf_connkey_t *	npf_conn_getforwkey(npf_conn_t *);
-npf_connkey_t *	npf_conn_getbackkey(npf_conn_t *, unsigned);
-void		npf_conn_adjkey(npf_connkey_t *, const npf_addr_t *,
-		    const uint16_t, const unsigned);
-unsigned	npf_connkey_setkey(npf_connkey_t *, unsigned, unsigned,
-		    const void *, const uint16_t *, const npf_flow_t);
-void		npf_connkey_getkey(const npf_connkey_t *, unsigned *,
-		    unsigned *, npf_addr_t *, uint16_t *);
-unsigned	npf_connkey_import(npf_t *, const nvlist_t *, npf_connkey_t *);
-nvlist_t *	npf_connkey_export(npf_t *, const npf_connkey_t *);
-void		npf_connkey_print(const npf_connkey_t *);
-
-/*
- * Connection tracking interface.
- */
-void		npf_conn_init(npf_t *);
-void		npf_conn_fini(npf_t *);
-void		npf_conn_tracking(npf_t *, bool);
-void		npf_conn_load(npf_t *, npf_conndb_t *, bool);
-
-npf_conn_t *	npf_conn_lookup(const npf_cache_t *, const unsigned, npf_flow_t *);
-npf_conn_t *	npf_conn_inspect(npf_cache_t *, const unsigned, int *);
-npf_conn_t *	npf_conn_establish(npf_cache_t *, const unsigned, bool);
-void		npf_conn_release(npf_conn_t *);
-void		npf_conn_destroy(npf_t *, npf_conn_t *);
-void		npf_conn_expire(npf_conn_t *);
-bool		npf_conn_pass(const npf_conn_t *, npf_match_info_t *,
-		    npf_rproc_t **);
-void		npf_conn_setpass(npf_conn_t *, const npf_match_info_t *,
-		    npf_rproc_t *);
-int		npf_conn_setnat(const npf_cache_t *, npf_conn_t *,
-		    npf_nat_t *, unsigned);
-npf_nat_t *	npf_conn_getnat(const npf_conn_t *);
-bool		npf_conn_expired(npf_t *, const npf_conn_t *, uint64_t);
-void		npf_conn_remove(npf_conndb_t *, npf_conn_t *);
-void		npf_conn_worker(npf_t *);
-int		npf_conn_import(npf_t *, npf_conndb_t *, const nvlist_t *,
-		    npf_ruleset_t *);
-int		npf_conn_find(npf_t *, const nvlist_t *, nvlist_t *);
-void		npf_conn_print(npf_conn_t *);
-
-/*
- * Connection database (aka state table) interface.
- */
-void		npf_conndb_sysinit(npf_t *);
-void		npf_conndb_sysfini(npf_t *);
-
-npf_conndb_t *	npf_conndb_create(void);
-void		npf_conndb_destroy(npf_conndb_t *);
-
-npf_conn_t *	npf_conndb_lookup(npf_t *, const npf_connkey_t *, npf_flow_t *);
-bool		npf_conndb_insert(npf_conndb_t *, const npf_connkey_t *,
-		    npf_conn_t *, npf_flow_t);
-npf_conn_t *	npf_conndb_remove(npf_conndb_t *, npf_connkey_t *);
-
-void		npf_conndb_enqueue(npf_conndb_t *, npf_conn_t *);
-npf_conn_t *	npf_conndb_getlist(npf_conndb_t *);
-npf_conn_t *	npf_conndb_getnext(npf_conndb_t *, npf_conn_t *);
-int		npf_conndb_export(npf_t *, nvlist_t *);
-void		npf_conndb_gc(npf_t *, npf_conndb_t *, bool, bool);
-
-#endif	/* _NPF_CONN_H_ */
diff --git a/src/kern/npf_conndb.c b/src/kern/npf_conndb.c
deleted file mode 100644
index 324114e..0000000
--- a/src/kern/npf_conndb.c
+++ /dev/null
@@ -1,455 +0,0 @@
-/*-
- * Copyright (c) 2010-2020 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * This material is based upon work partially supported by The
- * NetBSD Foundation under a contract with Mindaugas Rasiukevicius.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
- * NPF connection storage.
- *
- * Lock-free connection lookups are protected by EBR with an atomic
- * reference acquisition before exiting the critical path.  The caller
- * is responsible for re-checking the connection state.
- *
- * Warning (not applicable for the userspace npfkern):
- *
- *	thmap is partially lock-free data structure that uses its own
- *	spin-locks on the writer side (insert/delete operations).
- *
- *	The relevant interrupt priority level (IPL) must be set and the
- *	kernel preemption disabled across the critical paths to prevent
- *	deadlocks and priority inversion problems.  These are essentially
- *	the same guarantees as a spinning mutex(9) would provide.
- *
- *	This is achieved with SPL routines splsoftnet() and splx() around
- *	the thmap_del() and thmap_put() calls.  Note: we assume that the
- *	network stack invokes NPF at IPL_SOFTNET or lower, but not higher.
- */
-
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD$");
-
-#include <sys/param.h>
-#include <sys/types.h>
-
-#include <sys/atomic.h>
-#include <sys/kmem.h>
-#include <sys/thmap.h>
-#endif
-
-#define __NPF_CONN_PRIVATE
-#include "npf_conn.h"
-#include "npf_impl.h"
-
-struct npf_conndb {
-	thmap_t *		cd_map;
-
-	/*
-	 * There are three lists for connections: new, all and G/C.
-	 *
-	 * New connections are atomically inserted into the "new-list".
-	 * The G/C worker will move them to the doubly-linked list of all
-	 * active connections.
-	 */
-	npf_conn_t *		cd_new;
-	LIST_HEAD(, npf_conn)	cd_list;
-	LIST_HEAD(, npf_conn)	cd_gclist;
-
-	/* The last inspected connection (for circular iteration). */
-	npf_conn_t *		cd_marker;
-};
-
-typedef struct {
-	int		step;
-	int		interval_min;
-	int		interval_max;
-} npf_conndb_params_t;
-
-/*
- * Pointer tag for connection keys which represent the "forwards" entry.
- */
-#define	CONNDB_FORW_BIT		((uintptr_t)0x1)
-#define	CONNDB_ISFORW_P(p)	(((uintptr_t)(p) & CONNDB_FORW_BIT) != 0)
-#define	CONNDB_GET_PTR(p)	((void *)((uintptr_t)(p) & ~CONNDB_FORW_BIT))
-
-void
-npf_conndb_sysinit(npf_t *npf)
-{
-	npf_conndb_params_t *params = npf_param_allocgroup(npf,
-	    NPF_PARAMS_CONNDB, sizeof(npf_conndb_params_t));
-	npf_param_t param_map[] = {
-		{
-			"gc.step",
-			&params->step,
-			.default_val = 256,
-			.min = 1, .max = INT_MAX
-		},
-		{
-			"gc.interval_min",
-			&params->interval_min,
-			.default_val = 50, // ms
-			.min = 10, .max = 10000
-		},
-		{
-			"gc.interval_max",
-			&params->interval_max,
-			.default_val = 5000, // ms
-			.min = 10, .max = 10000
-		},
-	};
-	npf_param_register(npf, param_map, __arraycount(param_map));
-}
-
-void
-npf_conndb_sysfini(npf_t *npf)
-{
-	const size_t len = sizeof(npf_conndb_params_t);
-	npf_param_freegroup(npf, NPF_PARAMS_CONNDB, len);
-}
-
-npf_conndb_t *
-npf_conndb_create(void)
-{
-	npf_conndb_t *cd;
-
-	cd = kmem_zalloc(sizeof(npf_conndb_t), KM_SLEEP);
-	cd->cd_map = thmap_create(0, NULL, THMAP_NOCOPY);
-	KASSERT(cd->cd_map != NULL);
-
-	LIST_INIT(&cd->cd_list);
-	LIST_INIT(&cd->cd_gclist);
-	return cd;
-}
-
-void
-npf_conndb_destroy(npf_conndb_t *cd)
-{
-	KASSERT(cd->cd_new == NULL);
-	KASSERT(cd->cd_marker == NULL);
-	KASSERT(LIST_EMPTY(&cd->cd_list));
-	KASSERT(LIST_EMPTY(&cd->cd_gclist));
-
-	thmap_destroy(cd->cd_map);
-	kmem_free(cd, sizeof(npf_conndb_t));
-}
-
-/*
- * npf_conndb_lookup: find a connection given the key.
- */
-npf_conn_t *
-npf_conndb_lookup(npf_t *npf, const npf_connkey_t *ck, npf_flow_t *flow)
-{
-	npf_conndb_t *cd = atomic_load_relaxed(&npf->conn_db);
-	const unsigned keylen = NPF_CONNKEY_LEN(ck);
-	npf_conn_t *con;
-	void *val;
-
-	/*
-	 * Lookup the connection key in the key-value map.
-	 */
-	int s = npf_config_read_enter(npf);
-	val = thmap_get(cd->cd_map, ck->ck_key, keylen);
-	if (!val) {
-		npf_config_read_exit(npf, s);
-		return NULL;
-	}
-
-	/*
-	 * Determine whether this is the "forwards" or "backwards" key
-	 * and clear the pointer tag.
-	 */
-	*flow = CONNDB_ISFORW_P(val) ? NPF_FLOW_FORW : NPF_FLOW_BACK;
-	con = CONNDB_GET_PTR(val);
-	KASSERT(con != NULL);
-
-	/*
-	 * Acquire a reference and return the connection.
-	 */
-	atomic_inc_uint(&con->c_refcnt);
-	npf_config_read_exit(npf, s);
-	return con;
-}
-
-/*
- * npf_conndb_insert: insert the key representing the connection.
- *
- * => Returns true on success and false on failure.
- */
-bool
-npf_conndb_insert(npf_conndb_t *cd, const npf_connkey_t *ck,
-    npf_conn_t *con, npf_flow_t flow)
-{
-	const unsigned keylen = NPF_CONNKEY_LEN(ck);
-	const uintptr_t tag = (CONNDB_FORW_BIT * !flow);
-	void *val;
-	bool ok;
-
-	/*
-	 * Tag the connection pointer if this is the "forwards" key.
-	 */
-	KASSERT(!CONNDB_ISFORW_P(con));
-	val = (void *)((uintptr_t)(void *)con | tag);
-
-	int s = splsoftnet();
-	ok = thmap_put(cd->cd_map, ck->ck_key, keylen, val) == val;
-	splx(s);
-
-	return ok;
-}
-
-/*
- * npf_conndb_remove: find and delete connection key, returning the
- * connection it represents.
- */
-npf_conn_t *
-npf_conndb_remove(npf_conndb_t *cd, npf_connkey_t *ck)
-{
-	const unsigned keylen = NPF_CONNKEY_LEN(ck);
-	void *val;
-
-	int s = splsoftnet();
-	val = thmap_del(cd->cd_map, ck->ck_key, keylen);
-	splx(s);
-
-	return CONNDB_GET_PTR(val);
-}
-
-/*
- * npf_conndb_enqueue: atomically insert the connection into the
- * singly-linked list of the "new" connections.
- */
-void
-npf_conndb_enqueue(npf_conndb_t *cd, npf_conn_t *con)
-{
-	npf_conn_t *head;
-
-	do {
-		head = atomic_load_relaxed(&cd->cd_new);
-		atomic_store_relaxed(&con->c_next, head);
-	} while (atomic_cas_ptr(&cd->cd_new, head, con) != head);
-}
-
-/*
- * npf_conndb_update: migrate all new connections to the list of all
- * connections; this must also be performed on npf_conndb_getlist()
- * to provide a complete list of connections.
- */
-static void
-npf_conndb_update(npf_conndb_t *cd)
-{
-	npf_conn_t *con;
-
-	con = atomic_swap_ptr(&cd->cd_new, NULL);
-	while (con) {
-		npf_conn_t *next = atomic_load_relaxed(&con->c_next); // union
-		LIST_INSERT_HEAD(&cd->cd_list, con, c_entry);
-		con = next;
-	}
-}
-
-/*
- * npf_conndb_getlist: return the list of all connections.
- */
-npf_conn_t *
-npf_conndb_getlist(npf_conndb_t *cd)
-{
-	npf_conndb_update(cd);
-	return LIST_FIRST(&cd->cd_list);
-}
-
-/*
- * npf_conndb_getnext: return the next connection, implementing
- * the circular iteration.
- */
-npf_conn_t *
-npf_conndb_getnext(npf_conndb_t *cd, npf_conn_t *con)
-{
-	/* Next.. */
-	if (con == NULL || (con = LIST_NEXT(con, c_entry)) == NULL) {
-		con = LIST_FIRST(&cd->cd_list);
-	}
-	return con;
-}
-
-/*
- * npf_conndb_gc_incr: incremental G/C of the expired connections.
- */
-static unsigned
-npf_conndb_gc_incr(npf_t *npf, npf_conndb_t *cd, const time_t now)
-{
-	const npf_conndb_params_t *params = npf->params[NPF_PARAMS_CONNDB];
-	unsigned target = params->step;
-	unsigned gc_conns = 0;
-	npf_conn_t *con;
-
-	KASSERT(mutex_owned(&npf->conn_lock));
-
-	/*
-	 * Second, start from the "last" (marker) connection.
-	 * We must initialise the marker if it is not set yet.
-	 */
-	if ((con = cd->cd_marker) == NULL) {
-		con = npf_conndb_getnext(cd, NULL);
-		cd->cd_marker = con;
-	}
-
-	/*
-	 * Scan the connections:
-	 * - Limit the scan to the G/C step size.
-	 * - Stop if we scanned all of them.
-	 * - Update the marker connection.
-	 */
-	while (con && target--) {
-		npf_conn_t *next = npf_conndb_getnext(cd, con);
-
-		/*
-		 * Can we G/C this connection?
-		 */
-		if (npf_conn_expired(npf, con, now)) {
-			/* Yes: move to the G/C list. */
-			LIST_REMOVE(con, c_entry);
-			LIST_INSERT_HEAD(&cd->cd_gclist, con, c_entry);
-			npf_conn_remove(cd, con);
-			gc_conns++;
-
-			/* This connection cannot be a new marker anymore. */
-			if (con == next) {
-				next = NULL;
-			}
-			if (con == cd->cd_marker) {
-				cd->cd_marker = next;
-				con = next;
-				continue;
-			}
-		}
-		con = next;
-
-		/*
-		 * Circular iteration: if we returned back to the
-		 * marker connection, then stop.
-		 */
-		if (con == cd->cd_marker) {
-			break;
-		}
-	}
-	cd->cd_marker = con;
-	return gc_conns;
-}
-
-/*
- * gc_freq_tune: G/C frequency self-tuning.
- *
- * If there is something to G/C, then exponentially increase the wake
- * up frequency.  Otherwise, reduce the frequency.  Enforce the lower
- * and upper bounds.
- *
- * => Returns the number milliseconds until next G/C.
- */
-static unsigned
-gc_freq_tune(const npf_t *npf, const npf_conndb_t *cd, const unsigned n)
-{
-	const npf_conndb_params_t *params = npf->params[NPF_PARAMS_CONNDB];
-	int wtime = npf->worker_wait_time;
-	wtime = n ? (wtime >> 1) : (wtime << 1);
-	return MAX(MIN(wtime, params->interval_max), params->interval_min);
-}
-
-/*
- * npf_conndb_gc: garbage collect the expired connections.
- *
- * => Must run in a single-threaded manner.
- * => If 'flush' is true, then destroy all connections.
- * => If 'sync' is true, then perform passive serialisation.
- */
-void
-npf_conndb_gc(npf_t *npf, npf_conndb_t *cd, bool flush, bool sync)
-{
-	struct timespec tsnow;
-	unsigned gc_conns = 0;
-	npf_conn_t *con;
-	void *gcref;
-
-	getnanouptime(&tsnow);
-
-	/* First, migrate all new connections. */
-	mutex_enter(&npf->conn_lock);
-	npf_conndb_update(cd);
-	if (flush) {
-		/* Just unlink and move all connections to the G/C list. */
-		while ((con = LIST_FIRST(&cd->cd_list)) != NULL) {
-			LIST_REMOVE(con, c_entry);
-			LIST_INSERT_HEAD(&cd->cd_gclist, con, c_entry);
-			npf_conn_remove(cd, con);
-		}
-		cd->cd_marker = NULL;
-	} else {
-		/* Incremental G/C of the expired connections. */
-		gc_conns = npf_conndb_gc_incr(npf, cd, tsnow.tv_sec);
-	}
-	mutex_exit(&npf->conn_lock);
-
-	/*
-	 * Ensure it is safe to destroy the connections.
-	 * Note: drop the conn_lock (see the lock order).
-	 */
-	gcref = thmap_stage_gc(cd->cd_map);
-	if (sync && (gcref || !LIST_EMPTY(&cd->cd_gclist))) {
-		npf_config_enter(npf);
-		npf_config_sync(npf);
-		npf_config_exit(npf);
-	}
-	thmap_gc(cd->cd_map, gcref);
-
-	/* Self-tune the G/C frequency. */
-	npf->worker_wait_time = gc_freq_tune(npf, cd, gc_conns);
-
-	if (LIST_EMPTY(&cd->cd_gclist)) {
-		return;
-	}
-
-	/*
-	 * Garbage collect all expired connections.
-	 * May need to wait for the references to drain.
-	 */
-	while ((con = LIST_FIRST(&cd->cd_gclist)) != NULL) {
-		/*
-		 * Destroy only if removed and no references.  Otherwise,
-		 * just do it next time, unless we are destroying all.
-		 */
-		const unsigned refcnt = atomic_load_relaxed(&con->c_refcnt);
-
-		if (__predict_false(refcnt)) {
-			if (flush) {
-				kpause("npfcongc", false, 1, NULL);
-				continue;
-			}
-			break; // exit the loop
-		}
-		LIST_REMOVE(con, c_entry);
-		npf_conn_destroy(npf, con);
-	}
-}
diff --git a/src/kern/npf_connkey.c b/src/kern/npf_connkey.c
deleted file mode 100644
index e2ba32b..0000000
--- a/src/kern/npf_connkey.c
+++ /dev/null
@@ -1,394 +0,0 @@
-/*-
- * Copyright (c) 2014-2020 Mindaugas Rasiukevicius <rmind at netbsd org>
- * Copyright (c) 2010-2014 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * This material is based upon work partially supported by The
- * NetBSD Foundation under a contract with Mindaugas Rasiukevicius.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
- * Connection key -- is an n-tuple structure encoding the address length,
- * layer 3 protocol, source and destination addresses and ports (or other
- * protocol IDs) and some configurable elements (see below).
- *
- * Key layout
- *
- *	The single key is formed out of 32-bit integers.  The layout is
- *	as follows (first row -- fields, second row -- number of bits):
- *
- *	| alen | proto |  ckey  | src-id | dst-id | src-addr | dst-addr |
- *	+------+-------+--------+--------+--------+----------+----------+
- *	|   4  |   8   |   20   |   16   |   16   |  32-128  |  32-128  |
- *
- *	The source and destination are inverted if the key is for the
- *	backwards stream (NPF_FLOW_BACK).  The address length depends on
- *	the 'alen' field.  The length is in words and is either 1 or 4,
- *	meaning 4 or 16 in bytes.
- *
- *	The 20-bit configurable key area ('ckey') is for the optional
- *	elements which may be included or excluded by the user.  It has
- *	the following layout:
- *
- *	| direction | interface-id |
- *	+-----------+--------------+
- *	|     2     |      18      |
- *
- *	Note: neither direction nor interface ID cannot be zero; we rely
- *	on this by reserving the zero 'ckey' value to for the case when
- *	these checks are not applicable.
- *
- * Embedding in the connection structure (npf_conn_t)
- *
- *	Two keys are stored in the npf_conn_t::c_keys[] array, which is
- *	variable-length, depending on whether the keys store IPv4 or IPv6
- *	addresses.  The length of the first key determines the position
- *	of the second key.
- *
- * WARNING: the keys must be immutable while they are in conndb.
- */
-
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD$");
-
-#include <sys/param.h>
-#include <sys/types.h>
-#endif
-
-#define __NPF_CONN_PRIVATE
-#include "npf_conn.h"
-#include "npf_impl.h"
-
-unsigned
-npf_connkey_setkey(npf_connkey_t *key, unsigned alen, unsigned proto,
-    const void *ipv, const uint16_t *id, const npf_flow_t flow)
-{
-	const npf_addr_t * const *ips = ipv;
-	uint32_t *k = key->ck_key;
-	unsigned isrc, idst;
-
-	if (__predict_true(flow == NPF_FLOW_FORW)) {
-		isrc = NPF_SRC, idst = NPF_DST;
-	} else {
-		isrc = NPF_DST, idst = NPF_SRC;
-	}
-
-	/*
-	 * See the key layout explanation above.
-	 */
-	KASSERT((alen >> 2) <= 0xf && proto <= 0xff);
-	k[0] = ((uint32_t)(alen >> 2) << 28) | (proto << 20);
-	k[1] = ((uint32_t)id[isrc] << 16) | id[idst];
-
-	if (__predict_true(alen == sizeof(in_addr_t))) {
-		k[2] = ips[isrc]->word32[0];
-		k[3] = ips[idst]->word32[0];
-		return 4 * sizeof(uint32_t);
-	} else {
-		const unsigned nwords = alen >> 2;
-		memcpy(&k[2], ips[isrc], alen);
-		memcpy(&k[2 + nwords], ips[idst], alen);
-		return (2 + (nwords * 2)) * sizeof(uint32_t);
-	}
-}
-
-void
-npf_connkey_getkey(const npf_connkey_t *key, unsigned *alen, unsigned *proto,
-    npf_addr_t *ips, uint16_t *id)
-{
-	const uint32_t *k = key->ck_key;
-
-	/*
-	 * See the key layout explanation above.
-	 */
-
-	*alen = (k[0] >> 28) << 2;
-	*proto = (k[0] >> 16) & 0xff;
-	id[NPF_SRC] = k[1] >> 16;
-	id[NPF_DST] = k[1] & 0xffff;
-
-	switch (*alen) {
-	case sizeof(struct in6_addr):
-	case sizeof(struct in_addr):
-		memcpy(&ips[NPF_SRC], &k[2], *alen);
-		memcpy(&ips[NPF_DST], &k[2 + ((unsigned)*alen >> 2)], *alen);
-		return;
-	default:
-		KASSERT(0);
-	}
-}
-
-static inline void
-npf_connkey_setckey(npf_connkey_t *key, unsigned ifid, unsigned di)
-{
-	if (ifid) {
-		/*
-		 * Interface ID: the lower 18 bits of the 20-bit 'ckey'.
-		 * Note: the interface ID cannot be zero.
-		 */
-		CTASSERT(NPF_MAX_IFMAP < (1U << 18));
-		key->ck_key[0] |= ifid;
-	}
-	if (di) {
-		/*
-		 * Direction: The highest 2 bits of the 20-bit 'ckey'.
-		 * Note: we rely on PFIL_IN and PFIL_OUT definitions.
-		 */
-		CTASSERT(PFIL_IN == 0x1 || PFIL_OUT == 0x2);
-		KASSERT((di & ~PFIL_ALL) == 0);
-		key->ck_key[0] |= ((uint32_t)di << 18);
-	}
-}
-
-static void
-npf_connkey_getckey(const npf_connkey_t *key, unsigned *ifid, unsigned *di)
-{
-	const uint32_t * const k = key->ck_key;
-
-	*ifid = k[0] & ((1U << 20) - 1);
-	*di = (k[0] >> 18) & PFIL_ALL;
-}
-
-/*
- * npf_conn_adjkey: adjust the connection key by setting the address/port.
- *
- * => The 'which' must either be NPF_SRC or NPF_DST.
- */
-void
-npf_conn_adjkey(npf_connkey_t *key, const npf_addr_t *naddr,
-    const uint16_t id, const unsigned which)
-{
-	const unsigned alen = NPF_CONNKEY_ALEN(key);
-	uint32_t * const k = key->ck_key;
-	uint32_t *addr = &k[2 + ((alen >> 2) * which)];
-
-	KASSERT(which == NPF_SRC || which == NPF_DST);
-	KASSERT(alen > 0);
-	memcpy(addr, naddr, alen);
-
-	if (id) {
-		const uint32_t oid = k[1];
-		const unsigned shift = 16 * !which;
-		const uint32_t mask = 0xffff0000 >> shift;
-		k[1] = ((uint32_t)id << shift) | (oid & mask);
-	}
-}
-
-static unsigned
-npf_connkey_copy(const npf_connkey_t *skey, npf_connkey_t *dkey, bool invert)
-{
-	const unsigned klen = NPF_CONNKEY_LEN(skey);
-	const uint32_t *sk = skey->ck_key;
-	uint32_t *dk = dkey->ck_key;
-
-	if (invert) {
-		const unsigned alen = NPF_CONNKEY_ALEN(skey);
-		const unsigned nwords = alen >> 2;
-
-		dk[0] = sk[1];
-		dk[1] = (sk[1] >> 16) | (sk[1] << 16);
-		memcpy(&dk[2], &sk[2 + nwords], alen);
-		memcpy(&dk[2 + nwords], &sk[2], alen);
-	} else {
-		memcpy(dk, sk, klen);
-	}
-	return klen;
-}
-
-/*
- * npf_conn_conkey: construct a key for the connection lookup.
- *
- * => Returns the key length in bytes or zero on failure.
- */
-unsigned
-npf_conn_conkey(const npf_cache_t *npc, npf_connkey_t *key,
-    const unsigned di, const npf_flow_t flow)
-{
-	const npf_conn_params_t *params = npc->npc_ctx->params[NPF_PARAMS_CONN];
-	const nbuf_t *nbuf = npc->npc_nbuf;
-	const unsigned proto = npc->npc_proto;
-	const unsigned alen = npc->npc_alen;
-	const struct tcphdr *th;
-	const struct udphdr *uh;
-	uint16_t id[2] = { 0, 0 };
-	unsigned ret;
-
-	if (npc->npc_ckey) {
-		/*
-		 * Request to override the connection key.
-		 */
-		const bool invert = flow != NPF_FLOW_FORW;
-		return npf_connkey_copy(npc->npc_ckey, key, invert);
-	}
-
-	switch (proto) {
-	case IPPROTO_TCP:
-		KASSERT(npf_iscached(npc, NPC_TCP));
-		th = npc->npc_l4.tcp;
-		id[NPF_SRC] = th->th_sport;
-		id[NPF_DST] = th->th_dport;
-		break;
-	case IPPROTO_UDP:
-		KASSERT(npf_iscached(npc, NPC_UDP));
-		uh = npc->npc_l4.udp;
-		id[NPF_SRC] = uh->uh_sport;
-		id[NPF_DST] = uh->uh_dport;
-		break;
-	case IPPROTO_ICMP:
-		if (npf_iscached(npc, NPC_ICMP_ID)) {
-			const struct icmp *ic = npc->npc_l4.icmp;
-			id[NPF_SRC] = ic->icmp_id;
-			id[NPF_DST] = ic->icmp_id;
-			break;
-		}
-		return 0;
-	case IPPROTO_ICMPV6:
-		if (npf_iscached(npc, NPC_ICMP_ID)) {
-			const struct icmp6_hdr *ic6 = npc->npc_l4.icmp6;
-			id[NPF_SRC] = ic6->icmp6_id;
-			id[NPF_DST] = ic6->icmp6_id;
-			break;
-		}
-		return 0;
-	default:
-		/* Unsupported protocol. */
-		return 0;
-	}
-
-	ret = npf_connkey_setkey(key, alen, proto, npc->npc_ips, id, flow);
-	npf_connkey_setckey(key,
-	    params->connkey_interface ? nbuf->nb_ifid : 0,
-	    params->connkey_direction ? (di & PFIL_ALL) : 0);
-	return ret;
-}
-
-/*
- * npf_conn_getforwkey: get the address to the "forwards" key.
- */
-npf_connkey_t *
-npf_conn_getforwkey(npf_conn_t *conn)
-{
-	return (void *)&conn->c_keys[0];
-}
-
-/*
- * npf_conn_getbackkey: get the address to the "backwards" key.
- *
- * => It depends on the address length.
- */
-npf_connkey_t *
-npf_conn_getbackkey(npf_conn_t *conn, unsigned alen)
-{
-	const unsigned off = 2 + ((alen * 2) >> 2);
-	KASSERT(off == NPF_CONNKEY_V4WORDS || off == NPF_CONNKEY_V6WORDS);
-	return (void *)&conn->c_keys[off];
-}
-
-/*
- * Connection key exporting/importing.
- */
-
-nvlist_t *
-npf_connkey_export(npf_t *npf, const npf_connkey_t *key)
-{
-	unsigned alen, proto, ifid, di;
-	npf_addr_t ips[2];
-	uint16_t ids[2];
-	nvlist_t *key_nv;
-
-	key_nv = nvlist_create(0);
-
-	npf_connkey_getkey(key, &alen, &proto, ips, ids);
-	nvlist_add_number(key_nv, "proto", proto);
-	nvlist_add_number(key_nv, "sport", ids[NPF_SRC]);
-	nvlist_add_number(key_nv, "dport", ids[NPF_DST]);
-	nvlist_add_binary(key_nv, "saddr", &ips[NPF_SRC], alen);
-	nvlist_add_binary(key_nv, "daddr", &ips[NPF_DST], alen);
-
-	npf_connkey_getckey(key, &ifid, &di);
-	if (ifid) {
-		char ifname[IFNAMSIZ];
-		npf_ifmap_copyname(npf, ifid, ifname, sizeof(ifname));
-		nvlist_add_string(key_nv, "ifname", ifname);
-	}
-	if (di) {
-		nvlist_add_number(key_nv, "di", di);
-	}
-
-	return key_nv;
-}
-
-unsigned
-npf_connkey_import(npf_t *npf, const nvlist_t *key_nv, npf_connkey_t *key)
-{
-	npf_addr_t const * ips[2];
-	size_t alen1, alen2, proto;
-	unsigned ret, di, ifid = 0;
-	const char *ifname;
-	uint16_t ids[2];
-
-	proto = dnvlist_get_number(key_nv, "proto", 0);
-	if (proto >= IPPROTO_MAX) {
-		return 0;
-	}
-	ids[NPF_SRC] = dnvlist_get_number(key_nv, "sport", 0);
-	ids[NPF_DST] = dnvlist_get_number(key_nv, "dport", 0);
-	ips[NPF_SRC] = dnvlist_get_binary(key_nv, "saddr", &alen1, NULL, 0);
-	ips[NPF_DST] = dnvlist_get_binary(key_nv, "daddr", &alen2, NULL, 0);
-	if (alen1 == 0 || alen1 > sizeof(npf_addr_t) || alen1 != alen2) {
-		return 0;
-	}
-	ret = npf_connkey_setkey(key, alen1, proto, ips, ids, NPF_FLOW_FORW);
-	if (ret == 0) {
-		return 0;
-	}
-
-	ifname = dnvlist_get_string(key_nv, "ifname", NULL);
-	if (ifname && (ifid = npf_ifmap_register(npf, ifname)) == 0) {
-		return 0;
-	}
-	di = dnvlist_get_number(key_nv, "di", 0) & PFIL_ALL;
-	npf_connkey_setckey(key, ifid, di);
-
-	return ret;
-}
-
-#if defined(DDB) || defined(_NPF_TESTING)
-
-void
-npf_connkey_print(const npf_connkey_t *key)
-{
-	unsigned alen, proto, ifid, di;
-	npf_addr_t ips[2];
-	uint16_t ids[2];
-
-	npf_connkey_getkey(key, &alen, &proto, ips, ids);
-	npf_connkey_getckey(key, &ifid, &di);
-	printf("\tkey (ifid %u, di %x)\t", ifid, di);
-	printf("%s:%u", npf_addr_dump(&ips[0], alen), ids[0]);
-	printf("-> %s:%u\n", npf_addr_dump(&ips[1], alen), ids[1]);
-}
-
-#endif
diff --git a/src/kern/npf_ctl.c b/src/kern/npf_ctl.c
deleted file mode 100644
index 0d4b5e9..0000000
--- a/src/kern/npf_ctl.c
+++ /dev/null
@@ -1,879 +0,0 @@
-/*-
- * Copyright (c) 2009-2020 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * This material is based upon work partially supported by The
- * NetBSD Foundation under a contract with Mindaugas Rasiukevicius.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
- * NPF device control.
- *
- * Implementation of (re)loading, construction of tables and rules.
- * NPF nvlist(3) consumer.
- */
-
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD$");
-
-#include <sys/param.h>
-#include <sys/conf.h>
-#include <sys/kmem.h>
-#include <net/bpf.h>
-#endif
-
-#include "npf_impl.h"
-#include "npf_conn.h"
-
-#define	NPF_ERR_DEBUG(e) \
-	nvlist_add_string((e), "source-file", __FILE__); \
-	nvlist_add_number((e), "source-line", __LINE__);
-
-static int __noinline
-npf_mk_params(npf_t *npf, const nvlist_t *req, nvlist_t *resp, bool set)
-{
-	const nvlist_t *params;
-	int type, error, val;
-	const char *name;
-	void *cookie;
-
-	params = dnvlist_get_nvlist(req, "params", NULL);
-	if (params == NULL) {
-		return 0;
-	}
-	cookie = NULL;
-	while ((name = nvlist_next(params, &type, &cookie)) != NULL) {
-		if (type != NV_TYPE_NUMBER) {
-			NPF_ERR_DEBUG(resp);
-			return EINVAL;
-		}
-		val = (int)nvlist_get_number(params, name);
-		if (set) {
-			/* Actually set the parameter. */
-			error = npfk_param_set(npf, name, val);
-			KASSERT(error == 0);
-			continue;
-		}
-
-		/* Validate the parameter and its value. */
-		error = npf_param_check(npf, name, val);
-		if (__predict_true(error == 0)) {
-			continue;
-		}
-		if (error == ENOENT) {
-			nvlist_add_stringf(resp, "error-msg",
-			    "invalid parameter `%s`", name);
-		}
-		if (error == EINVAL) {
-			nvlist_add_stringf(resp, "error-msg",
-			    "invalid parameter `%s` value %d", name, val);
-		}
-		return error;
-	}
-	return 0;
-}
-
-static int __noinline
-npf_mk_table_entries(npf_table_t *t, const nvlist_t *req, nvlist_t *resp)
-{
-	const nvlist_t * const *entries;
-	size_t nitems;
-	int error = 0;
-
-	if (!nvlist_exists_nvlist_array(req, "entries")) {
-		return 0;
-	}
-	entries = nvlist_get_nvlist_array(req, "entries", &nitems);
-	for (unsigned i = 0; i < nitems; i++) {
-		const nvlist_t *entry = entries[i];
-		const npf_addr_t *addr;
-		npf_netmask_t mask;
-		size_t alen;
-
-		/* Get address and mask; add a table entry. */
-		addr = dnvlist_get_binary(entry, "addr", &alen, NULL, 0);
-		mask = dnvlist_get_number(entry, "mask", NPF_NO_NETMASK);
-		if (addr == NULL || alen == 0) {
-			NPF_ERR_DEBUG(resp);
-			error = EINVAL;
-			break;
-		}
-		error = npf_table_insert(t, alen, addr, mask);
-		if (__predict_false(error)) {
-			if (error == EEXIST) {
-				nvlist_add_stringf(resp, "error-msg",
-				    "table `%s' has a duplicate entry",
-				    nvlist_get_string(req, "name"));
-			} else {
-				NPF_ERR_DEBUG(resp);
-			}
-			break;
-		}
-	}
-	return error;
-}
-
-/*
- * npf_mk_table: create a table from provided nvlist.
- */
-static int __noinline
-npf_mk_table(npf_t *npf, const nvlist_t *req, nvlist_t *resp,
-    npf_tableset_t *tblset, npf_table_t **tblp, bool replacing)
-{
-	npf_table_t *t;
-	const char *name;
-	const void *blob;
-	uint64_t tid;
-	size_t size;
-	int type;
-	int error = 0;
-
-	KASSERT(tblp != NULL);
-
-	/* Table name, ID and type.  Validate them. */
-	name = dnvlist_get_string(req, "name", NULL);
-	if (!name) {
-		NPF_ERR_DEBUG(resp);
-		error = EINVAL;
-		goto out;
-	}
-	tid = dnvlist_get_number(req, "id", UINT64_MAX);
-	type = dnvlist_get_number(req, "type", UINT64_MAX);
-	error = npf_table_check(tblset, name, tid, type, replacing);
-	if (error) {
-		NPF_ERR_DEBUG(resp);
-		goto out;
-	}
-
-	/* Get the entries or binary data. */
-	blob = dnvlist_get_binary(req, "data", &size, NULL, 0);
-	if (type == NPF_TABLE_CONST && (blob == NULL || size == 0)) {
-		NPF_ERR_DEBUG(resp);
-		error = EINVAL;
-		goto out;
-	}
-
-	t = npf_table_create(name, (unsigned)tid, type, blob, size);
-	if (t == NULL) {
-		NPF_ERR_DEBUG(resp);
-		error = ENOMEM;
-		goto out;
-	}
-
-	if ((error = npf_mk_table_entries(t, req, resp)) != 0) {
-		npf_table_destroy(t);
-		goto out;
-	}
-
-	*tblp = t;
-out:
-	return error;
-}
-
-static int __noinline
-npf_mk_tables(npf_t *npf, const nvlist_t *req, nvlist_t *resp, npf_config_t *nc)
-{
-	const nvlist_t * const *tables;
-	npf_tableset_t *tblset;
-	size_t nitems;
-	int error = 0;
-
-	if (nvlist_exists_nvlist_array(req, "tables")) {
-		tables = nvlist_get_nvlist_array(req, "tables", &nitems);
-		if (nitems > NPF_MAX_TABLES) {
-			NPF_ERR_DEBUG(resp);
-			return E2BIG;
-		}
-	} else {
-		tables = NULL;
-		nitems = 0;
-	}
-	tblset = npf_tableset_create(nitems);
-	for (unsigned i = 0; i < nitems; i++) {
-		const nvlist_t *table = tables[i];
-		npf_table_t *t;
-
-		error = npf_mk_table(npf, table, resp, tblset, &t, 0);
-		if (error) {
-			break;
-		}
-
-		error = npf_tableset_insert(tblset, t);
-		KASSERT(error == 0);
-	}
-	nc->tableset = tblset;
-	return error;
-}
-
-static npf_rproc_t *
-npf_mk_singlerproc(npf_t *npf, const nvlist_t *rproc, nvlist_t *resp)
-{
-	const nvlist_t * const *extcalls;
-	size_t nitems;
-	npf_rproc_t *rp;
-
-	if ((rp = npf_rproc_create(rproc)) == NULL) {
-		NPF_ERR_DEBUG(resp);
-		return NULL;
-	}
-	if (!nvlist_exists_nvlist_array(rproc, "extcalls")) {
-		return rp;
-	}
-	extcalls = nvlist_get_nvlist_array(rproc, "extcalls", &nitems);
-	for (unsigned i = 0; i < nitems; i++) {
-		const nvlist_t *extcall = extcalls[i];
-		const char *name;
-
-		name = dnvlist_get_string(extcall, "name", NULL);
-		if (!name || npf_ext_construct(npf, name, rp, extcall)) {
-			NPF_ERR_DEBUG(resp);
-			npf_rproc_release(rp);
-			rp = NULL;
-			break;
-		}
-	}
-	return rp;
-}
-
-static int __noinline
-npf_mk_rprocs(npf_t *npf, const nvlist_t *req, nvlist_t *resp, npf_config_t *nc)
-{
-	const nvlist_t * const *rprocs;
-	npf_rprocset_t *rpset;
-	size_t nitems;
-	int error = 0;
-
-	if (nvlist_exists_nvlist_array(req, "rprocs")) {
-		rprocs = nvlist_get_nvlist_array(req, "rprocs", &nitems);
-		if (nitems > NPF_MAX_RPROCS) {
-			NPF_ERR_DEBUG(resp);
-			return E2BIG;
-		}
-	} else {
-		rprocs = NULL;
-		nitems = 0;
-	}
-	rpset = npf_rprocset_create();
-	for (unsigned i = 0; i < nitems; i++) {
-		const nvlist_t *rproc = rprocs[i];
-		npf_rproc_t *rp;
-
-		if ((rp = npf_mk_singlerproc(npf, rproc, resp)) == NULL) {
-			error = EINVAL;
-			break;
-		}
-		npf_rprocset_insert(rpset, rp);
-	}
-	nc->rule_procs = rpset;
-	return error;
-}
-
-static int __noinline
-npf_mk_algs(npf_t *npf, const nvlist_t *req, nvlist_t *resp)
-{
-	const nvlist_t * const *algs;
-	size_t nitems;
-
-	if (nvlist_exists_nvlist_array(req, "algs")) {
-		algs = nvlist_get_nvlist_array(req, "algs", &nitems);
-	} else {
-		algs = NULL;
-		nitems = 0;
-	}
-	for (unsigned i = 0; i < nitems; i++) {
-		const nvlist_t *alg = algs[i];
-		const char *name;
-
-		name = dnvlist_get_string(alg, "name", NULL);
-		if (!name) {
-			NPF_ERR_DEBUG(resp);
-			return EINVAL;
-		}
-		if (!npf_alg_construct(npf, name)) {
-			NPF_ERR_DEBUG(resp);
-			return EINVAL;
-		}
-	}
-	return 0;
-}
-
-static int __noinline
-npf_mk_singlerule(npf_t *npf, const nvlist_t *req, nvlist_t *resp,
-    npf_rprocset_t *rpset, npf_rule_t **rlret)
-{
-	npf_rule_t *rl;
-	const char *rname;
-	const void *code;
-	size_t clen;
-	int error = 0;
-
-	if ((rl = npf_rule_alloc(npf, req)) == NULL) {
-		NPF_ERR_DEBUG(resp);
-		return EINVAL;
-	}
-
-	/* Assign the rule procedure, if any. */
-	if ((rname = dnvlist_get_string(req, "rproc", NULL)) != NULL) {
-		npf_rproc_t *rp;
-
-		if (rpset == NULL) {
-			NPF_ERR_DEBUG(resp);
-			error = EINVAL;
-			goto err;
-		}
-		if ((rp = npf_rprocset_lookup(rpset, rname)) == NULL) {
-			NPF_ERR_DEBUG(resp);
-			error = EINVAL;
-			goto err;
-		}
-		npf_rule_setrproc(rl, rp);
-	}
-
-	/* Filter byte-code (binary data). */
-	code = dnvlist_get_binary(req, "code", &clen, NULL, 0);
-	if (code) {
-		void *bc;
-		int type;
-
-		type = dnvlist_get_number(req, "code-type", UINT64_MAX);
-		if (type != NPF_CODE_BPF) {
-			NPF_ERR_DEBUG(resp);
-			error = ENOTSUP;
-			goto err;
-		}
-		if (clen == 0) {
-			NPF_ERR_DEBUG(resp);
-			error = EINVAL;
-			goto err;
-		}
-		if (!npf_bpf_validate(code, clen)) {
-			NPF_ERR_DEBUG(resp);
-			error = EINVAL;
-			goto err;
-		}
-		bc = kmem_alloc(clen, KM_SLEEP);
-		memcpy(bc, code, clen); // XXX: use nvlist_take
-		npf_rule_setcode(rl, type, bc, clen);
-	}
-
-	*rlret = rl;
-	return 0;
-err:
-	nvlist_add_number(resp, "id", dnvlist_get_number(req, "prio", 0));
-	npf_rule_free(rl);
-	return error;
-}
-
-static int __noinline
-npf_mk_rules(npf_t *npf, const nvlist_t *req, nvlist_t *resp, npf_config_t *nc)
-{
-	const nvlist_t * const *rules;
-	npf_ruleset_t *rlset;
-	size_t nitems;
-	int error = 0;
-
-	if (nvlist_exists_nvlist_array(req, "rules")) {
-		rules = nvlist_get_nvlist_array(req, "rules", &nitems);
-		if (nitems > NPF_MAX_RULES) {
-			NPF_ERR_DEBUG(resp);
-			return E2BIG;
-		}
-	} else {
-		rules = NULL;
-		nitems = 0;
-	}
-	rlset = npf_ruleset_create(nitems);
-	for (unsigned i = 0; i < nitems; i++) {
-		const nvlist_t *rule = rules[i];
-		npf_rule_t *rl = NULL;
-		const char *name;
-
-		error = npf_mk_singlerule(npf, rule, resp, nc->rule_procs, &rl);
-		if (error) {
-			break;
-		}
-		name = dnvlist_get_string(rule, "name", NULL);
-		if (name && npf_ruleset_lookup(rlset, name)) {
-			NPF_ERR_DEBUG(resp);
-			npf_rule_free(rl);
-			error = EEXIST;
-			break;
-		}
-		npf_ruleset_insert(rlset, rl);
-	}
-	nc->ruleset = rlset;
-	return error;
-}
-
-static int __noinline
-npf_mk_singlenat(npf_t *npf, const nvlist_t *nat, nvlist_t *resp,
-    npf_ruleset_t *ntset, npf_tableset_t *tblset, npf_rule_t **rlp)
-{
-	npf_rule_t *rl = NULL;
-	npf_natpolicy_t *np;
-	int error;
-
-	/*
-	 * NAT rules are standard rules, plus the translation policy.
-	 * We first construct the rule structure.
-	 */
-	error = npf_mk_singlerule(npf, nat, resp, NULL, &rl);
-	if (error) {
-		return error;
-	}
-	KASSERT(rl != NULL);
-	*rlp = rl;
-
-	/* If this rule is named, then it is a group with NAT policies. */
-	if (dnvlist_get_string(nat, "name", NULL)) {
-		return 0;
-	}
-
-	/* Check the table ID. */
-	if (nvlist_exists_number(nat, "nat-table-id")) {
-		unsigned tid = nvlist_get_number(nat, "nat-table-id");
-
-		if (!npf_tableset_getbyid(tblset, tid)) {
-			NPF_ERR_DEBUG(resp);
-			error = EINVAL;
-			goto out;
-		}
-	}
-
-	/* Allocate a new NAT policy and assign it to the rule. */
-	np = npf_natpolicy_create(npf, nat, ntset);
-	if (np == NULL) {
-		NPF_ERR_DEBUG(resp);
-		error = ENOMEM;
-		goto out;
-	}
-	npf_rule_setnat(rl, np);
-out:
-	if (error) {
-		npf_rule_free(rl);
-	}
-	return error;
-}
-
-static int __noinline
-npf_mk_natlist(npf_t *npf, const nvlist_t *req, nvlist_t *resp, npf_config_t *nc)
-{
-	const nvlist_t * const *nat_rules;
-	npf_ruleset_t *ntset;
-	size_t nitems;
-	int error = 0;
-
-	/*
-	 * NAT policies must be an array, but enforce a limit.
-	 */
-	if (nvlist_exists_nvlist_array(req, "nat")) {
-		nat_rules = nvlist_get_nvlist_array(req, "nat", &nitems);
-		if (nitems > NPF_MAX_RULES) {
-			NPF_ERR_DEBUG(resp);
-			return E2BIG;
-		}
-	} else {
-		nat_rules = NULL;
-		nitems = 0;
-	}
-	ntset = npf_ruleset_create(nitems);
-	for (unsigned i = 0; i < nitems; i++) {
-		const nvlist_t *nat = nat_rules[i];
-		npf_rule_t *rl = NULL;
-
-		error = npf_mk_singlenat(npf, nat, resp, ntset,
-		    nc->tableset, &rl);
-		if (error) {
-			break;
-		}
-		npf_ruleset_insert(ntset, rl);
-	}
-	nc->nat_ruleset = ntset;
-	return error;
-}
-
-/*
- * npf_mk_connlist: import a list of connections and load them.
- */
-static int __noinline
-npf_mk_connlist(npf_t *npf, const nvlist_t *req, nvlist_t *resp,
-    npf_config_t *nc, npf_conndb_t **conndb)
-{
-	const nvlist_t * const *conns;
-	npf_conndb_t *cd;
-	size_t nitems;
-	int error = 0;
-
-	if (!nvlist_exists_nvlist_array(req, "conn-list")) {
-		*conndb = NULL;
-		return 0;
-	}
-	cd = npf_conndb_create();
-	conns = nvlist_get_nvlist_array(req, "conn-list", &nitems);
-	for (unsigned i = 0; i < nitems; i++) {
-		const nvlist_t *conn = conns[i];
-
-		/* Construct and insert the connection. */
-		error = npf_conn_import(npf, cd, conn, nc->nat_ruleset);
-		if (error) {
-			NPF_ERR_DEBUG(resp);
-			break;
-		}
-	}
-	if (error) {
-		npf_conndb_gc(npf, cd, true, false);
-		npf_conndb_destroy(cd);
-	} else {
-		*conndb = cd;
-	}
-	return error;
-}
-
-/*
- * npfctl_load: store passed data i.e. the update settings, create the
- * passed rules, tables, etc and atomically activate them all.
- */
-static int
-npfctl_load(npf_t *npf, const nvlist_t *req, nvlist_t *resp)
-{
-	npf_config_t *nc;
-	npf_conndb_t *conndb = NULL;
-	bool flush;
-	int error;
-
-	nc = npf_config_create();
-	error = npf_mk_params(npf, req, resp, false /* validate */);
-	if (error) {
-		goto fail;
-	}
-	error = npf_mk_algs(npf, req, resp);
-	if (error) {
-		goto fail;
-	}
-	error = npf_mk_tables(npf, req, resp, nc);
-	if (error) {
-		goto fail;
-	}
-	error = npf_mk_rprocs(npf, req, resp, nc);
-	if (error) {
-		goto fail;
-	}
-	error = npf_mk_natlist(npf, req, resp, nc);
-	if (error) {
-		goto fail;
-	}
-	error = npf_mk_rules(npf, req, resp, nc);
-	if (error) {
-		goto fail;
-	}
-	error = npf_mk_connlist(npf, req, resp, nc, &conndb);
-	if (error) {
-		goto fail;
-	}
-
-	flush = dnvlist_get_bool(req, "flush", false);
-	nc->default_pass = flush;
-
-	/*
-	 * Finally - perform the load.
-	 */
-	npf_config_load(npf, nc, conndb, flush);
-	npf_mk_params(npf, req, resp, true /* set the params */);
-	return 0;
-
-fail:
-	npf_config_destroy(nc);
-	return error;
-}
-
-/*
- * npfctl_save: export the active configuration, including the current
- * snapshot of the connections.  Additionally, set the version and indicate
- * whether the ruleset is currently active.
- */
-static int
-npfctl_save(npf_t *npf, const nvlist_t *req, nvlist_t *resp)
-{
-	npf_config_t *nc;
-	int error;
-
-	/*
-	 * Serialize the whole NPF configuration, including connections.
-	 */
-	nvlist_add_number(resp, "version", NPF_VERSION);
-	nc = npf_config_enter(npf);
-	error = npf_params_export(npf, resp);
-	if (error) {
-		goto out;
-	}
-	error = npf_conndb_export(npf, resp);
-	if (error) {
-		goto out;
-	}
-	error = npf_ruleset_export(npf, nc->ruleset, "rules", resp);
-	if (error) {
-		goto out;
-	}
-	error = npf_ruleset_export(npf, nc->nat_ruleset, "nat", resp);
-	if (error) {
-		goto out;
-	}
-	error = npf_tableset_export(npf, nc->tableset, resp);
-	if (error) {
-		goto out;
-	}
-	error = npf_rprocset_export(nc->rule_procs, resp);
-	if (error) {
-		goto out;
-	}
-	error = npf_alg_export(npf, resp);
-	if (error) {
-		goto out;
-	}
-	nvlist_add_bool(resp, "active", npf_active_p());
-out:
-	npf_config_exit(npf);
-	return error;
-}
-
-/*
- * npfctl_table_replace: atomically replace a table's contents with
- * the passed table data.
- */
-static int __noinline
-npfctl_table_replace(npf_t *npf, const nvlist_t *req, nvlist_t *resp)
-{
-	npf_table_t *tbl, *gc_tbl = NULL;
-	npf_config_t *nc;
-	int error = 0;
-
-	nc = npf_config_enter(npf);
-	error = npf_mk_table(npf, req, resp, nc->tableset, &tbl, true);
-	if (error) {
-		goto err;
-	}
-	gc_tbl = npf_tableset_swap(nc->tableset, tbl);
-	if (gc_tbl == NULL) {
-		error = EINVAL;
-		gc_tbl = tbl;
-		goto err;
-	}
-	npf_config_sync(npf);
-err:
-	npf_config_exit(npf);
-	if (gc_tbl) {
-		npf_table_destroy(gc_tbl);
-	}
-	return error;
-}
-
-/*
- * npfctl_rule: add or remove dynamic rules in the specified ruleset.
- */
-static int
-npfctl_rule(npf_t *npf, const nvlist_t *req, nvlist_t *resp)
-{
-	npf_ruleset_t *rlset;
-	npf_rule_t *rl = NULL;
-	const char *ruleset_name;
-	npf_config_t *nc;
-	uint32_t rcmd;
-	int error = 0;
-	bool natset;
-
-	rcmd = dnvlist_get_number(req, "command", 0);
-	natset = dnvlist_get_bool(req, "nat-ruleset", false);
-	ruleset_name = dnvlist_get_string(req, "ruleset-name", NULL);
-	if (!ruleset_name) {
-		error = EINVAL;
-		goto out;
-	}
-
-	nc = npf_config_enter(npf);
-	rlset = natset ? nc->nat_ruleset : nc->ruleset;
-	switch (rcmd) {
-	case NPF_CMD_RULE_ADD: {
-		if (natset) {
-			/*
-			 * Translation rule.
-			 */
-			error = npf_mk_singlenat(npf, req, resp, rlset,
-			    nc->tableset, &rl);
-		} else {
-			/*
-			 * Standard rule.
-			 */
-			error = npf_mk_singlerule(npf, req, resp, NULL, &rl);
-		}
-		if (error) {
-			goto out;
-		}
-		if ((error = npf_ruleset_add(rlset, ruleset_name, rl)) == 0) {
-			/* Success. */
-			uint64_t id = npf_rule_getid(rl);
-			nvlist_add_number(resp, "id", id);
-			rl = NULL;
-		}
-		break;
-	}
-	case NPF_CMD_RULE_REMOVE: {
-		uint64_t id = dnvlist_get_number(req, "id", UINT64_MAX);
-		error = npf_ruleset_remove(rlset, ruleset_name, id);
-		break;
-	}
-	case NPF_CMD_RULE_REMKEY: {
-		const void *key;
-		size_t len;
-
-		key = dnvlist_get_binary(req, "key", &len, NULL, 0);
-		if (len == 0 || len > NPF_RULE_MAXKEYLEN) {
-			error = EINVAL;
-			break;
-		}
-		error = npf_ruleset_remkey(rlset, ruleset_name, key, len);
-		break;
-	}
-	case NPF_CMD_RULE_LIST: {
-		error = npf_ruleset_list(npf, rlset, ruleset_name, resp);
-		break;
-	}
-	case NPF_CMD_RULE_FLUSH: {
-		error = npf_ruleset_flush(rlset, ruleset_name);
-		break;
-	}
-	default:
-		error = EINVAL;
-		break;
-	}
-
-	/* Destroy any removed rules. */
-	if (!error && rcmd != NPF_CMD_RULE_ADD && rcmd != NPF_CMD_RULE_LIST) {
-		npf_config_sync(npf);
-		npf_ruleset_gc(rlset);
-	}
-out:
-	npf_config_exit(npf);
-
-	if (rl) {
-		KASSERT(error);
-		npf_rule_free(rl);
-	}
-	return error;
-}
-
-/*
- * npfctl_table: add, remove or query entries in the specified table.
- *
- * For maximum performance, the interface is using plain structures.
- */
-int
-npfctl_table(npf_t *npf, void *data)
-{
-	const npf_ioctl_table_t *nct = data;
-	char tname[NPF_TABLE_MAXNAMELEN];
-	npf_config_t *nc;
-	npf_table_t *t;
-	int error;
-
-	error = copyinstr(nct->nct_name, tname, sizeof(tname), NULL);
-	if (error) {
-		return error;
-	}
-
-	nc = npf_config_enter(npf);
-	if ((t = npf_tableset_getbyname(nc->tableset, tname)) == NULL) {
-		npf_config_exit(npf);
-		return EINVAL;
-	}
-
-	switch (nct->nct_cmd) {
-	case NPF_CMD_TABLE_LOOKUP:
-		error = npf_table_lookup(t, nct->nct_data.ent.alen,
-		    &nct->nct_data.ent.addr);
-		break;
-	case NPF_CMD_TABLE_ADD:
-		error = npf_table_insert(t, nct->nct_data.ent.alen,
-		    &nct->nct_data.ent.addr, nct->nct_data.ent.mask);
-		break;
-	case NPF_CMD_TABLE_REMOVE:
-		error = npf_table_remove(t, nct->nct_data.ent.alen,
-		    &nct->nct_data.ent.addr, nct->nct_data.ent.mask);
-		break;
-	case NPF_CMD_TABLE_LIST:
-		error = npf_table_list(t, nct->nct_data.buf.buf,
-		    nct->nct_data.buf.len);
-		break;
-	case NPF_CMD_TABLE_FLUSH:
-		error = npf_table_flush(t);
-		break;
-	default:
-		error = EINVAL;
-		break;
-	}
-	npf_table_gc(npf, t);
-	npf_config_exit(npf);
-
-	return error;
-}
-
-/*
- * npfctl_run_op: run a particular NPF operation with a given the request.
- *
- * => Checks the ABI version.
- * => Sets the error number for the response.
- */
-int
-npfctl_run_op(npf_t *npf, unsigned op, const nvlist_t *req, nvlist_t *resp)
-{
-	uint64_t ver;
-	int error;
-
-	ver = dnvlist_get_number(req, "version", UINT64_MAX);
-	if (__predict_false(ver != NPF_VERSION)) {
-		return EPROGMISMATCH;
-	}
-	switch (op) {
-	case IOC_NPF_LOAD:
-		error = npfctl_load(npf, req, resp);
-		break;
-	case IOC_NPF_SAVE:
-		error = npfctl_save(npf, req, resp);
-		break;
-	case IOC_NPF_RULE:
-		error = npfctl_rule(npf, req, resp);
-		break;
-	case IOC_NPF_CONN_LOOKUP:
-		error = npf_conn_find(npf, req, resp);
-		break;
-	case IOC_NPF_TABLE_REPLACE:
-		error = npfctl_table_replace(npf, req, resp);
-		break;
-	default:
-		error = ENOTTY;
-		break;
-	}
-	nvlist_add_number(resp, "errno", error);
-	return error;
-}
diff --git a/src/kern/npf_ext_log.c b/src/kern/npf_ext_log.c
deleted file mode 100644
index 88f2064..0000000
--- a/src/kern/npf_ext_log.c
+++ /dev/null
@@ -1,193 +0,0 @@
-/*-
- * Copyright (c) 2010-2012 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * This material is based upon work partially supported by The
- * NetBSD Foundation under a contract with Mindaugas Rasiukevicius.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
- * NPF logging extension.
- */
-
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD$");
-
-#include <sys/types.h>
-#include <sys/module.h>
-
-#include <sys/conf.h>
-#include <sys/kmem.h>
-#include <sys/mbuf.h>
-#include <sys/mutex.h>
-#include <sys/queue.h>
-
-#include <net/if.h>
-#include <net/if_types.h>
-#include <net/bpf.h>
-#endif
-
-#include "npf_impl.h"
-#include "if_npflog.h"
-
-NPF_EXT_MODULE(npf_ext_log, "");
-
-#define	NPFEXT_LOG_VER		1
-
-static void *		npf_ext_log_id;
-
-typedef struct {
-	unsigned int	if_idx;
-} npf_ext_log_t;
-
-static int
-npf_log_ctor(npf_rproc_t *rp, const nvlist_t *params)
-{
-	npf_ext_log_t *meta;
-
-	meta = kmem_zalloc(sizeof(npf_ext_log_t), KM_SLEEP);
-	meta->if_idx = dnvlist_get_number(params, "log-interface", 0);
-	npf_rproc_assign(rp, meta);
-	return 0;
-}
-
-static void
-npf_log_dtor(npf_rproc_t *rp, void *meta)
-{
-	kmem_free(meta, sizeof(npf_ext_log_t));
-}
-
-static bool
-npf_log(npf_cache_t *npc, void *meta, const npf_match_info_t *mi, int *decision)
-{
-	struct mbuf *m = nbuf_head_mbuf(npc->npc_nbuf);
-	const npf_ext_log_t *log = meta;
-	struct psref psref;
-	ifnet_t *ifp;
-	struct npfloghdr hdr;
-
-	memset(&hdr, 0, sizeof(hdr));
-	/* Set the address family. */
-	if (npf_iscached(npc, NPC_IP4)) {
-		hdr.af = AF_INET;
-	} else if (npf_iscached(npc, NPC_IP6)) {
-		hdr.af = AF_INET6;
-	} else {
-		hdr.af = AF_UNSPEC;
-	}
-
-	hdr.length = NPFLOG_REAL_HDRLEN;
-	hdr.action = *decision == NPF_DECISION_PASS ?
-	    0 /* pass */ : 1 /* block */;
-	hdr.reason = 0;	/* match */
-
-	struct nbuf *nb = npc->npc_nbuf;
-	npf_ifmap_copyname(npc->npc_ctx, nb ? nb->nb_ifid : 0,
-	    hdr.ifname, sizeof(hdr.ifname));
-
-	hdr.rulenr = htonl((uint32_t)mi->mi_rid);
-	hdr.subrulenr = htonl((uint32_t)(mi->mi_rid >> 32));
-	strlcpy(hdr.ruleset, "rules", sizeof(hdr.ruleset));
-
-	hdr.uid = UID_MAX;
-	hdr.pid = (pid_t)-1;
-	hdr.rule_uid = UID_MAX;
-	hdr.rule_pid = (pid_t)-1;
-
-	switch (mi->mi_di) {
-	default:
-	case PFIL_IN|PFIL_OUT:
-		hdr.dir = 0;
-		break;
-	case PFIL_IN:
-		hdr.dir = 1;
-		break;
-	case PFIL_OUT:
-		hdr.dir = 2;
-		break;
-	}
-
-	KERNEL_LOCK(1, NULL);
-
-	/* Find a pseudo-interface to log. */
-	ifp = if_get_byindex(log->if_idx, &psref);
-	if (ifp == NULL) {
-		/* No interface. */
-		KERNEL_UNLOCK_ONE(NULL);
-		return true;
-	}
-
-	if_statadd2(ifp, if_opackets, 1, if_obytes, m->m_pkthdr.len);
-	if (ifp->if_bpf) {
-		/* Pass through BPF. */
-		bpf_mtap2(ifp->if_bpf, &hdr, NPFLOG_HDRLEN, m, BPF_D_OUT);
-	}
-	if_put(ifp, &psref);
-
-	KERNEL_UNLOCK_ONE(NULL);
-
-	return true;
-}
-
-__dso_public int
-npf_ext_log_init(npf_t *npf)
-{
-	static const npf_ext_ops_t npf_log_ops = {
-		.version	= NPFEXT_LOG_VER,
-		.ctx		= NULL,
-		.ctor		= npf_log_ctor,
-		.dtor		= npf_log_dtor,
-		.proc		= npf_log
-	};
-	npf_ext_log_id = npf_ext_register(npf, "log", &npf_log_ops);
-	return npf_ext_log_id ? 0 : EEXIST;
-}
-
-__dso_public int
-npf_ext_log_fini(npf_t *npf)
-{
-	return npf_ext_unregister(npf, npf_ext_log_id);
-}
-
-#ifdef _KERNEL
-static int
-npf_ext_log_modcmd(modcmd_t cmd, void *arg)
-{
-	npf_t *npf = npf_getkernctx();
-
-	switch (cmd) {
-	case MODULE_CMD_INIT:
-		return npf_ext_log_init(npf);
-	case MODULE_CMD_FINI:
-		return npf_ext_log_fini(npf);
-		break;
-	case MODULE_CMD_AUTOUNLOAD:
-		return npf_autounload_p() ? 0 : EBUSY;
-	default:
-		return ENOTTY;
-	}
-	return 0;
-}
-#endif
diff --git a/src/kern/npf_ext_normalize.c b/src/kern/npf_ext_normalize.c
deleted file mode 100644
index 2c73caf..0000000
--- a/src/kern/npf_ext_normalize.c
+++ /dev/null
@@ -1,246 +0,0 @@
-/*-
- * Copyright (c) 2009-2012 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD$");
-
-#include <sys/types.h>
-#include <sys/module.h>
-#include <sys/kmem.h>
-
-#include <net/if.h>
-#include <netinet/in_systm.h>
-#include <netinet/in.h>
-#include <netinet/in_var.h>
-#endif
-
-#include "npf.h"
-#include "npf_impl.h"
-
-/*
- * NPF extension module definition and the identifier.
- */
-NPF_EXT_MODULE(npf_ext_normalize, "");
-
-#define	NPFEXT_NORMALIZE_VER	1
-
-static void *		npf_ext_normalize_id;
-
-/*
- * Normalisation parameters.
- */
-typedef struct {
-	unsigned	n_minttl;
-	unsigned	n_maxmss;
-	bool		n_random_id;
-	bool		n_no_df;
-} npf_normalize_t;
-
-/*
- * npf_normalize_ctor: a constructor for the normalisation rule procedure
- * with the given parameters.
- */
-static int
-npf_normalize_ctor(npf_rproc_t *rp, const nvlist_t *params)
-{
-	npf_normalize_t *np;
-
-	/* Create a structure for normalisation parameters. */
-	np = kmem_zalloc(sizeof(npf_normalize_t), KM_SLEEP);
-
-	/* IP ID randomisation and IP_DF flag cleansing. */
-	np->n_random_id = dnvlist_get_bool(params, "random-id", false);
-	np->n_no_df = dnvlist_get_bool(params, "no-df", false);
-
-	/* Minimum IP TTL and maximum TCP MSS. */
-	np->n_minttl = dnvlist_get_number(params, "min-ttl", 0);
-	np->n_maxmss = dnvlist_get_number(params, "max-mss", 0);
-
-	/* Assign the parameters for this rule procedure. */
-	npf_rproc_assign(rp, np);
-	return 0;
-}
-
-/*
- * npf_normalize_dtor: a destructor for a normalisation rule procedure.
- */
-static void
-npf_normalize_dtor(npf_rproc_t *rp, void *params)
-{
-	/* Free our meta-data, associated with the procedure. */
-	kmem_free(params, sizeof(npf_normalize_t));
-}
-
-/*
- * npf_normalize_ip4: routine to normalize IPv4 header (randomize ID,
- * clear "don't fragment" and/or enforce minimum TTL).
- */
-static inline void
-npf_normalize_ip4(npf_cache_t *npc, npf_normalize_t *np)
-{
-	struct ip *ip = npc->npc_ip.v4;
-	uint16_t cksum = ip->ip_sum;
-	uint16_t ip_off = ip->ip_off;
-	uint8_t ttl = ip->ip_ttl;
-	unsigned minttl = np->n_minttl;
-
-	KASSERT(np->n_random_id || np->n_no_df || minttl);
-
-	/* Randomize IPv4 ID. */
-	if (np->n_random_id) {
-		uint16_t oid = ip->ip_id, nid;
-
-		nid = htons(ip_randomid(ip_ids, 0));
-		cksum = npf_fixup16_cksum(cksum, oid, nid);
-		ip->ip_id = nid;
-	}
-
-	/* IP_DF flag cleansing. */
-	if (np->n_no_df && (ip_off & htons(IP_DF)) != 0) {
-		uint16_t nip_off = ip_off & ~htons(IP_DF);
-
-		cksum = npf_fixup16_cksum(cksum, ip_off, nip_off);
-		ip->ip_off = nip_off;
-	}
-
-	/* Enforce minimum TTL. */
-	if (minttl && ttl < minttl) {
-		cksum = npf_fixup16_cksum(cksum, ttl, minttl);
-		ip->ip_ttl = minttl;
-	}
-
-	/* Update IPv4 checksum. */
-	ip->ip_sum = cksum;
-}
-
-/*
- * npf_normalize: the main routine to normalize IPv4 and/or TCP headers.
- */
-static bool
-npf_normalize(npf_cache_t *npc, void *params, const npf_match_info_t *mi,
-    int *decision)
-{
-	npf_normalize_t *np = params;
-	uint16_t cksum, mss, maxmss = np->n_maxmss;
-	uint16_t old[2], new[2];
-	struct tcphdr *th;
-	int wscale;
-	bool mid;
-
-	/* Skip, if already blocking. */
-	if (*decision == NPF_DECISION_BLOCK) {
-		return true;
-	}
-
-	/* Normalize IPv4.  Nothing to do for IPv6. */
-	if (npf_iscached(npc, NPC_IP4) && (np->n_random_id || np->n_minttl)) {
-		npf_normalize_ip4(npc, np);
-	}
-	th = npc->npc_l4.tcp;
-
-	/*
-	 * TCP Maximum Segment Size (MSS) "clamping".  Only if SYN packet.
-	 * Fetch MSS and check whether rewrite to lower is needed.
-	 */
-	if (maxmss == 0 || !npf_iscached(npc, NPC_TCP) ||
-	    (th->th_flags & TH_SYN) == 0) {
-		/* Not required; done. */
-		return true;
-	}
-	mss = 0;
-	if (!npf_fetch_tcpopts(npc, &mss, &wscale)) {
-		return true;
-	}
-	if (ntohs(mss) <= maxmss) {
-		/* Nothing else to do. */
-		return true;
-	}
-	maxmss = htons(maxmss);
-
-	/*
-	 * Store new MSS, calculate TCP checksum and update it. The MSS may
-	 * not be aligned and fall in the middle of two uint16_t's, so we
-	 * need to take care of that when calculating the checksum.
-	 *
-	 * WARNING: must re-fetch the TCP header after the modification.
-	 */
-	if (npf_set_mss(npc, maxmss, old, new, &mid) &&
-	    !nbuf_cksum_barrier(npc->npc_nbuf, mi->mi_di)) {
-		th = npc->npc_l4.tcp;
-		if (mid) {
-			cksum = th->th_sum;
-			cksum = npf_fixup16_cksum(cksum, old[0], new[0]);
-			cksum = npf_fixup16_cksum(cksum, old[1], new[1]);
-		} else {
-			cksum = npf_fixup16_cksum(th->th_sum, mss, maxmss);
-		}
-		th->th_sum = cksum;
-	}
-
-	return true;
-}
-
-__dso_public int
-npf_ext_normalize_init(npf_t *npf)
-{
-	static const npf_ext_ops_t npf_normalize_ops = {
-		.version	= NPFEXT_NORMALIZE_VER,
-		.ctx		= NULL,
-		.ctor		= npf_normalize_ctor,
-		.dtor		= npf_normalize_dtor,
-		.proc		= npf_normalize
-	};
-	npf_ext_normalize_id = npf_ext_register(npf,
-	    "normalize", &npf_normalize_ops);
-	return npf_ext_normalize_id ? 0 : EEXIST;
-}
-
-__dso_public int
-npf_ext_normalize_fini(npf_t *npf)
-{
-	return npf_ext_unregister(npf, npf_ext_normalize_id);
-}
-
-#ifdef _KERNEL
-static int
-npf_ext_normalize_modcmd(modcmd_t cmd, void *arg)
-{
-	npf_t *npf = npf_getkernctx();
-
-	switch (cmd) {
-	case MODULE_CMD_INIT:
-		return npf_ext_normalize_init(npf);
-	case MODULE_CMD_FINI:
-		return npf_ext_unregister(npf, npf_ext_normalize_id);
-	case MODULE_CMD_AUTOUNLOAD:
-		return npf_autounload_p() ? 0 : EBUSY;
-	default:
-		return ENOTTY;
-	}
-	return 0;
-}
-#endif
diff --git a/src/kern/npf_ext_rndblock.c b/src/kern/npf_ext_rndblock.c
deleted file mode 100644
index 1603ac1..0000000
--- a/src/kern/npf_ext_rndblock.c
+++ /dev/null
@@ -1,189 +0,0 @@
-/*-
- * Copyright (c) 2012 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
- * NPF random blocking extension - kernel module.
- * This is also a demo extension.
- */
-
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD$");
-
-#include <sys/types.h>
-#include <sys/cprng.h>
-#include <sys/atomic.h>
-#include <sys/module.h>
-#include <sys/kmem.h>
-#endif
-
-#include "npf_impl.h"
-
-/*
- * NPF extension module definition and the identifier.
- */
-NPF_EXT_MODULE(npf_ext_rndblock, "");
-
-#define	NPFEXT_RNDBLOCK_VER		1
-
-static void *		npf_ext_rndblock_id;
-
-#define	PERCENTAGE_BASE	10000
-
-/*
- * Meta-data structure, containing parameters.
- */
-typedef struct {
-	unsigned int	mod;
-	unsigned long	counter;
-	unsigned int	percentage;
-} npf_ext_rndblock_t;
-
-/*
- * npf_ext_rndblock_ctor: a constructor to parse and store any parameters
- * associated with a rule procedure, which is being newly created.
- */
-static int
-npf_ext_rndblock_ctor(npf_rproc_t *rp, const nvlist_t *params)
-{
-	npf_ext_rndblock_t *meta;
-
-	/*
-	 * Allocate and a associate a structure for the parameter
-	 * and our meta-data.
-	 */
-	meta = kmem_zalloc(sizeof(npf_ext_rndblock_t), KM_SLEEP);
-	meta->mod = dnvlist_get_number(params, "mod", 0);
-	meta->percentage = dnvlist_get_number(params, "percentage", 0);
-	npf_rproc_assign(rp, meta);
-
-	return 0;
-}
-
-/*
- * npf_ext_rndblock_dtor: a destructor for our rule procedure.
- */
-static void
-npf_ext_rndblock_dtor(npf_rproc_t *rp, void *meta)
-{
-	/* Free our meta-data, associated with the procedure. */
-	kmem_free(meta, sizeof(npf_ext_rndblock_t));
-}
-
-/*
- * npf_ext_rndblock: main routine implementing the extension functionality.
- */
-static bool
-npf_ext_rndblock(npf_cache_t *npc, void *meta, const npf_match_info_t *mi,
-    int *decision)
-{
-	npf_ext_rndblock_t *rndblock = meta;
-	unsigned long c;
-
-	/* Skip, if already blocking. */
-	if (*decision == NPF_DECISION_BLOCK) {
-		return true;
-	}
-
-	/*
-	 * Sample demo:
-	 *
-	 * Drop the packets according to the given module or percentage.
-	 *
-	 * Rule procedures may be executed concurrently in an SMP system.
-	 * Use atomic operation to increment the counter.
-	 */
-	c = atomic_inc_ulong_nv(&rndblock->counter);
-
-	if (rndblock->mod) {
-		if ((c % rndblock->mod) == 0) {
-			*decision = NPF_DECISION_BLOCK;
-		}
-	}
-
-	if (rndblock->percentage) {
-		uint32_t w = cprng_fast32() % PERCENTAGE_BASE;
-		if (w <= rndblock->percentage) {
-			*decision = NPF_DECISION_BLOCK;
-		}
-	}
-
-	return true;
-}
-
-__dso_public int
-npf_ext_rndblock_init(npf_t *npf)
-{
-	static const npf_ext_ops_t npf_rndblock_ops = {
-		.version	= NPFEXT_RNDBLOCK_VER,
-		.ctx		= NULL,
-		.ctor		= npf_ext_rndblock_ctor,
-		.dtor		= npf_ext_rndblock_dtor,
-		.proc		= npf_ext_rndblock
-	};
-
-	/*
-	 * Initialize the NPF extension.  Register the "rndblock" extension
-	 * calls (constructor, destructor, the processing routine, etc).
-	 */
-	npf_ext_rndblock_id = npf_ext_register(npf, "rndblock",
-	    &npf_rndblock_ops);
-	return npf_ext_rndblock_id ? 0 : EEXIST;
-}
-
-__dso_public int
-npf_ext_rndblock_fini(npf_t *npf)
-{
-	/*
-	 * Remove the rndblock extension.  NPF may return an if there
-	 * are active references and it cannot drain them.
-	 */
-	return npf_ext_unregister(npf, npf_ext_rndblock_id);
-}
-
-#ifdef _KERNEL
-/*
- * Kernel module interface.
- */
-static int
-npf_ext_rndblock_modcmd(modcmd_t cmd, void *arg)
-{
-	npf_t *npf = npf_getkernctx();
-
-	switch (cmd) {
-	case MODULE_CMD_INIT:
-		return npf_ext_rndblock_init(npf);
-	case MODULE_CMD_FINI:
-		return npf_ext_rndblock_fini(npf);
-	case MODULE_CMD_AUTOUNLOAD:
-		/* Allow auto-unload only if NPF permits it. */
-		return npf_autounload_p() ? 0 : EBUSY;
-	default:
-		return ENOTTY;
-	}
-	return 0;
-}
-#endif
diff --git a/src/kern/npf_handler.c b/src/kern/npf_handler.c
deleted file mode 100644
index 793ba7c..0000000
--- a/src/kern/npf_handler.c
+++ /dev/null
@@ -1,337 +0,0 @@
-/*-
- * Copyright (c) 2020 Mindaugas Rasiukevicius <rmind at noxt eu>
- * Copyright (c) 2009-2013 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * This material is based upon work partially supported by The
- * NetBSD Foundation under a contract with Mindaugas Rasiukevicius.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
- * NPF packet handler.
- *
- * This is the main entry point to the NPF where packet processing happens.
- * There are some important synchronization rules:
- *
- *	1) Lookups into the connection database and configuration (ruleset,
- *	tables, etc) are protected by Epoch-Based Reclamation (EBR);
- *
- *	2) The code in the critical path (protected by EBR) should generally
- *	not block (that includes adaptive mutex acquisitions);
- *
- *	3) Where it will blocks, references should be acquired atomically,
- *	while in the critical path, on the relevant objects.
- */
-
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD$");
-
-#include <sys/types.h>
-#include <sys/param.h>
-
-#include <sys/mbuf.h>
-#include <sys/mutex.h>
-#include <net/if.h>
-#include <net/pfil.h>
-#include <sys/socketvar.h>
-
-#include <netinet/in_systm.h>
-#include <netinet/in.h>
-#include <netinet/ip_var.h>
-#include <netinet/ip6.h>
-#include <netinet6/ip6_var.h>
-#endif
-
-#include "npf_impl.h"
-#include "npf_conn.h"
-
-#if defined(_NPF_STANDALONE)
-#define	m_freem(m)		npf->mbufops->free(m)
-#define	m_clear_flag(m,f)
-#else
-#define	m_clear_flag(m,f)	(m)->m_flags &= ~(f)
-#endif
-
-#ifndef INET6
-#define ip6_reass_packet(x, y)	ENOTSUP
-#endif
-
-static int
-npf_reassembly(npf_t *npf, npf_cache_t *npc, bool *mff)
-{
-	nbuf_t *nbuf = npc->npc_nbuf;
-	int error = EINVAL;
-	struct mbuf *m;
-
-	*mff = false;
-	m = nbuf_head_mbuf(nbuf);
-
-	if (npf_iscached(npc, NPC_IP4) && npf->ip4_reassembly) {
-		error = ip_reass_packet(&m);
-	} else if (npf_iscached(npc, NPC_IP6) && npf->ip6_reassembly) {
-		error = ip6_reass_packet(&m, npc->npc_hlen);
-	} else {
-		/*
-		 * Reassembly is disabled: just pass the packet through
-		 * the ruleset for inspection.
-		 */
-		return 0;
-	}
-
-	if (error) {
-		/* Reassembly failed; free the mbuf, clear the nbuf. */
-		npf_stats_inc(npf, NPF_STAT_REASSFAIL);
-		m_freem(m);
-		memset(nbuf, 0, sizeof(nbuf_t));
-		return error;
-	}
-	if (m == NULL) {
-		/* More fragments should come. */
-		npf_stats_inc(npf, NPF_STAT_FRAGMENTS);
-		*mff = true;
-		return 0;
-	}
-
-	/*
-	 * Reassembly is complete, we have the final packet.
-	 * Cache again, since layer 4 data is accessible now.
-	 */
-	nbuf_init(npf, nbuf, m, nbuf->nb_ifp);
-	npc->npc_info = 0;
-
-	if (npf_cache_all(npc) & (NPC_IPFRAG|NPC_FMTERR)) {
-		return EINVAL;
-	}
-	npf_stats_inc(npf, NPF_STAT_REASSEMBLY);
-	return 0;
-}
-
-static inline bool
-npf_packet_bypass_tag_p(nbuf_t *nbuf)
-{
-	uint32_t ntag;
-	return nbuf_find_tag(nbuf, &ntag) == 0 && (ntag & NPF_NTAG_PASS) != 0;
-}
-
-/*
- * npfk_packet_handler: main packet handling routine for layer 3.
- *
- * Note: packet flow and inspection logic is in strict order.
- */
-__dso_public int
-npfk_packet_handler(npf_t *npf, struct mbuf **mp, ifnet_t *ifp, int di)
-{
-	nbuf_t nbuf;
-	npf_cache_t npc;
-	npf_conn_t *con;
-	npf_rule_t *rl;
-	npf_rproc_t *rp;
-	int error, decision, flags;
-	npf_match_info_t mi;
-	bool mff;
-
-	KASSERT(ifp != NULL);
-
-	/*
-	 * Initialize packet information cache.
-	 * Note: it is enough to clear the info bits.
-	 */
-	nbuf_init(npf, &nbuf, *mp, ifp);
-	memset(&npc, 0, sizeof(npf_cache_t));
-	npc.npc_ctx = npf;
-	npc.npc_nbuf = &nbuf;
-
-	mi.mi_di = di;
-	mi.mi_rid = 0;
-	mi.mi_retfl = 0;
-
-	*mp = NULL;
-	decision = NPF_DECISION_BLOCK;
-	error = 0;
-	rp = NULL;
-	con = NULL;
-
-	/* Cache everything. */
-	flags = npf_cache_all(&npc);
-
-	/* Malformed packet, leave quickly. */
-	if (flags & NPC_FMTERR) {
-		error = EINVAL;
-		goto out;
-	}
-
-	/* Determine whether it is an IP fragment. */
-	if (__predict_false(flags & NPC_IPFRAG)) {
-		/* Pass to IPv4/IPv6 reassembly mechanism. */
-		error = npf_reassembly(npf, &npc, &mff);
-		if (error) {
-			goto out;
-		}
-		if (mff) {
-			/* More fragments should come. */
-			return 0;
-		}
-	}
-
-	/* Just pass-through if specially tagged. */
-	if (npf_packet_bypass_tag_p(&nbuf)) {
-		goto pass;
-	}
-
-	/* Inspect the list of connections (if found, acquires a reference). */
-	con = npf_conn_inspect(&npc, di, &error);
-
-	/* If "passing" connection found - skip the ruleset inspection. */
-	if (con && npf_conn_pass(con, &mi, &rp)) {
-		npf_stats_inc(npf, NPF_STAT_PASS_CONN);
-		KASSERT(error == 0);
-		goto pass;
-	}
-	if (__predict_false(error)) {
-		if (error == ENETUNREACH)
-			goto block;
-		goto out;
-	}
-
-	/* Acquire the lock, inspect the ruleset using this packet. */
-	int slock = npf_config_read_enter(npf);
-	npf_ruleset_t *rlset = npf_config_ruleset(npf);
-
-	rl = npf_ruleset_inspect(&npc, rlset, di, NPF_LAYER_3);
-	if (__predict_false(rl == NULL)) {
-		const bool pass = npf_default_pass(npf);
-		npf_config_read_exit(npf, slock);
-
-		if (pass) {
-			npf_stats_inc(npf, NPF_STAT_PASS_DEFAULT);
-			goto pass;
-		}
-		npf_stats_inc(npf, NPF_STAT_BLOCK_DEFAULT);
-		goto block;
-	}
-
-	/*
-	 * Get the rule procedure (acquires a reference) for association
-	 * with a connection (if any) and execution.
-	 */
-	KASSERT(rp == NULL);
-	rp = npf_rule_getrproc(rl);
-
-	/* Conclude with the rule and release the lock. */
-	error = npf_rule_conclude(rl, &mi);
-	npf_config_read_exit(npf, slock);
-
-	if (error) {
-		npf_stats_inc(npf, NPF_STAT_BLOCK_RULESET);
-		goto block;
-	}
-	npf_stats_inc(npf, NPF_STAT_PASS_RULESET);
-
-	/*
-	 * Establish a "pass" connection, if required.  Just proceed if
-	 * connection creation fails (e.g. due to unsupported protocol).
-	 */
-	if ((mi.mi_retfl & NPF_RULE_STATEFUL) != 0 && !con) {
-		con = npf_conn_establish(&npc, di,
-		    (mi.mi_retfl & NPF_RULE_GSTATEFUL) == 0);
-		if (con) {
-			/*
-			 * Note: the reference on the rule procedure is
-			 * transferred to the connection.  It will be
-			 * released on connection destruction.
-			 */
-			npf_conn_setpass(con, &mi, rp);
-		}
-	}
-
-pass:
-	decision = NPF_DECISION_PASS;
-	KASSERT(error == 0);
-
-	/*
-	 * Perform NAT.
-	 */
-	error = npf_do_nat(&npc, con, di);
-
-block:
-	/*
-	 * Execute the rule procedure, if any is associated.
-	 * It may reverse the decision from pass to block.
-	 */
-	if (rp && !npf_rproc_run(&npc, rp, &mi, &decision)) {
-		if (con) {
-			npf_conn_release(con);
-		}
-		npf_rproc_release(rp);
-		/* mbuf already freed */
-		return 0;
-	}
-
-out:
-	/*
-	 * Release the reference on a connection.  Release the reference
-	 * on a rule procedure only if there was no association.
-	 */
-	if (con) {
-		npf_conn_release(con);
-	} else if (rp) {
-		npf_rproc_release(rp);
-	}
-
-	/* Get the new mbuf pointer. */
-	if ((*mp = nbuf_head_mbuf(&nbuf)) == NULL) {
-		return error ? error : ENOMEM;
-	}
-
-	/* Pass the packet if decided and there is no error. */
-	if (decision == NPF_DECISION_PASS && !error) {
-		/*
-		 * XXX: Disable for now, it will be set accordingly later,
-		 * for optimisations (to reduce inspection).
-		 */
-		m_clear_flag(*mp, M_CANFASTFWD);
-		return 0;
-	}
-
-	/*
-	 * Block the packet.  ENETUNREACH is used to indicate blocking.
-	 * Depending on the flags and protocol, return TCP reset (RST) or
-	 * ICMP destination unreachable.
-	 */
-	if (mi.mi_retfl && npf_return_block(&npc, mi.mi_retfl)) {
-		*mp = NULL;
-	}
-
-	if (!error) {
-		error = ENETUNREACH;
-	}
-
-	if (*mp) {
-		/* Free the mbuf chain. */
-		m_freem(*mp);
-		*mp = NULL;
-	}
-	return error;
-}
diff --git a/src/kern/npf_if.c b/src/kern/npf_if.c
deleted file mode 100644
index ed533ac..0000000
--- a/src/kern/npf_if.c
+++ /dev/null
@@ -1,244 +0,0 @@
-/*-
- * Copyright (c) 2019 Mindaugas Rasiukevicius <rmind at noxt eu>
- * Copyright (c) 2013 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * This code is derived from software contributed to The NetBSD Foundation
- * by Mindaugas Rasiukevicius.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
- * NPF network interface handling.
- *
- * NPF uses its own interface IDs (npf-if-id).  These IDs start from 1.
- * Zero is reserved to indicate "no interface" case or an interface of
- * no interest (i.e. not registered).
- *
- * This module provides an interface to primarily handle the following:
- *
- * - Bind a symbolic interface name to NPF interface ID.
- * - Associate NPF interface ID when the network interface is attached.
- *
- * When NPF configuration is (re)loaded, each referenced network interface
- * name is registered with a unique ID.  If the network interface is already
- * attached, then the ID is associated with it immediately; otherwise, IDs
- * are associated/disassociated on interface events which are monitored
- * using pfil(9) hooks.
- *
- * To avoid race conditions when an active NPF configuration is updated or
- * interfaces are detached/attached, the interface names are never removed
- * and therefore IDs are never re-assigned.  The only point when interface
- * names and IDs are cleared is when the configuration is flushed.
- *
- * A linear counter is used for IDs.
- */
-
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD$");
-
-#include <sys/param.h>
-#include <sys/types.h>
-#include <sys/kmem.h>
-#include <net/if.h>
-#endif
-
-#include "npf_impl.h"
-
-typedef struct npf_ifmap {
-	char		ifname[IFNAMSIZ + 1];
-} npf_ifmap_t;
-
-#define	NPF_IFMAP_NOID			(0U)
-#define	NPF_IFMAP_SLOT2ID(npf, slot)	((npf)->ifmap_off + (slot) + 1)
-#define	NPF_IFMAP_ID2SLOT(npf, id)	\
-    ((id) - atomic_load_relaxed(&(npf)->ifmap_off) - 1)
-
-void
-npf_ifmap_init(npf_t *npf, const npf_ifops_t *ifops)
-{
-	const size_t nbytes = sizeof(npf_ifmap_t) * NPF_MAX_IFMAP;
-
-	KASSERT(ifops != NULL);
-	ifops->flush(npf, (void *)(uintptr_t)0);
-
-	mutex_init(&npf->ifmap_lock, MUTEX_DEFAULT, IPL_SOFTNET);
-	npf->ifmap = kmem_zalloc(nbytes, KM_SLEEP);
-	npf->ifmap_cnt = 0;
-	npf->ifmap_off = 0;
-	npf->ifops = ifops;
-}
-
-void
-npf_ifmap_fini(npf_t *npf)
-{
-	const size_t nbytes = sizeof(npf_ifmap_t) * NPF_MAX_IFMAP;
-	mutex_destroy(&npf->ifmap_lock);
-	kmem_free(npf->ifmap, nbytes);
-}
-
-static unsigned
-npf_ifmap_lookup(npf_t *npf, const char *ifname)
-{
-	KASSERT(mutex_owned(&npf->ifmap_lock));
-
-	for (unsigned i = 0; i < npf->ifmap_cnt; i++) {
-		npf_ifmap_t *ifmap = &npf->ifmap[i];
-
-		if (strcmp(ifmap->ifname, ifname) == 0) {
-			return NPF_IFMAP_SLOT2ID(npf, i);
-		}
-	}
-	return NPF_IFMAP_NOID;
-}
-
-/*
- * npf_ifmap_register: register an interface name; return an assigned
- * NPF network ID on success (non-zero).
- *
- * This routine is mostly called on NPF configuration (re)load for the
- * interfaces names referenced by the rules.
- */
-unsigned
-npf_ifmap_register(npf_t *npf, const char *ifname)
-{
-	npf_ifmap_t *ifmap;
-	unsigned id, i;
-	ifnet_t *ifp;
-
-	mutex_enter(&npf->ifmap_lock);
-	if ((id = npf_ifmap_lookup(npf, ifname)) != NPF_IFMAP_NOID) {
-		goto out;
-	}
-	if (npf->ifmap_cnt == NPF_MAX_IFMAP) {
-		printf("npf_ifmap_new: out of slots; bump NPF_MAX_IFMAP\n");
-		id = NPF_IFMAP_NOID;
-		goto out;
-	}
-	KASSERT(npf->ifmap_cnt < NPF_MAX_IFMAP);
-
-	/* Allocate a new slot and convert and assign an ID. */
-	i = npf->ifmap_cnt++;
-	ifmap = &npf->ifmap[i];
-	strlcpy(ifmap->ifname, ifname, IFNAMSIZ);
-	id = NPF_IFMAP_SLOT2ID(npf, i);
-
-	if ((ifp = npf->ifops->lookup(npf, ifname)) != NULL) {
-		npf->ifops->setmeta(npf, ifp, (void *)(uintptr_t)id);
-	}
-out:
-	mutex_exit(&npf->ifmap_lock);
-	return id;
-}
-
-void
-npf_ifmap_flush(npf_t *npf)
-{
-	mutex_enter(&npf->ifmap_lock);
-	npf->ifops->flush(npf, (void *)(uintptr_t)NPF_IFMAP_NOID);
-	for (unsigned i = 0; i < npf->ifmap_cnt; i++) {
-		npf->ifmap[i].ifname[0] = '\0';
-	}
-	npf->ifmap_cnt = 0;
-
-	/*
-	 * Reset the ID counter if reaching the overflow; this is not
-	 * realistic, but we maintain correctness.
-	 */
-	if (npf->ifmap_off < (UINT_MAX - NPF_MAX_IFMAP)) {
-		npf->ifmap_off += NPF_MAX_IFMAP;
-	} else {
-		npf->ifmap_off = 0;
-	}
-	mutex_exit(&npf->ifmap_lock);
-}
-
-/*
- * npf_ifmap_getid: get the ID for the given network interface.
- *
- * => This routine is typically called from the packet handler when
- *    matching whether the packet is on particular network interface.
- *
- * => This routine is lock-free; if the NPF configuration is flushed
- *    while the packet is in-flight, the ID will not match because we
- *    keep the IDs linear.
- */
-unsigned
-npf_ifmap_getid(npf_t *npf, const ifnet_t *ifp)
-{
-	const unsigned id = (uintptr_t)npf->ifops->getmeta(npf, ifp);
-	return id;
-}
-
-/*
- * npf_ifmap_copylogname: this function is toxic; it can return garbage
- * as we don't lock, but it is only used temporarily and only for logging.
- */
-void
-npf_ifmap_copylogname(npf_t *npf, unsigned id, char *buf, size_t len)
-{
-	const unsigned i = NPF_IFMAP_ID2SLOT(npf, id);
-
-	membar_consumer();
-
-	if (id != NPF_IFMAP_NOID && i < NPF_MAX_IFMAP) {
-		/*
-		 * Lock-free access is safe as there is an extra byte
-		 * with a permanent NUL terminator at the end.
-		 */
-		const npf_ifmap_t *ifmap = &npf->ifmap[i];
-		strlcpy(buf, ifmap->ifname, MIN(len, IFNAMSIZ));
-	} else {
-		strlcpy(buf, "???", len);
-	}
-}
-
-void
-npf_ifmap_copyname(npf_t *npf, unsigned id, char *buf, size_t len)
-{
-	mutex_enter(&npf->ifmap_lock);
-	npf_ifmap_copylogname(npf, id, buf, len);
-	mutex_exit(&npf->ifmap_lock);
-}
-
-__dso_public void
-npfk_ifmap_attach(npf_t *npf, ifnet_t *ifp)
-{
-	const npf_ifops_t *ifops = npf->ifops;
-	unsigned id;
-
-	mutex_enter(&npf->ifmap_lock);
-	id = npf_ifmap_lookup(npf, ifops->getname(npf, ifp));
-	ifops->setmeta(npf, ifp, (void *)(uintptr_t)id);
-	mutex_exit(&npf->ifmap_lock);
-}
-
-__dso_public void
-npfk_ifmap_detach(npf_t *npf, ifnet_t *ifp)
-{
-	/* Diagnostic. */
-	mutex_enter(&npf->ifmap_lock);
-	npf->ifops->setmeta(npf, ifp, (void *)(uintptr_t)NPF_IFMAP_NOID);
-	mutex_exit(&npf->ifmap_lock);
-}
diff --git a/src/kern/npf_ifaddr.c b/src/kern/npf_ifaddr.c
deleted file mode 100644
index 7704e92..0000000
--- a/src/kern/npf_ifaddr.c
+++ /dev/null
@@ -1,178 +0,0 @@
-/*-
- * Copyright (c) 2014 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * This code is derived from software contributed to The NetBSD Foundation
- * by Mindaugas Rasiukevicius.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
- * NPF network interface handling module.
- */
-
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD$");
-
-#include <sys/param.h>
-#include <sys/types.h>
-#include <sys/kmem.h>
-
-#include <net/if.h>
-#include <netinet/in.h>
-#include <netinet6/in6_var.h>
-#endif
-
-#include "npf_impl.h"
-
-static npf_table_t *
-lookup_ifnet_table(npf_t *npf, ifnet_t *ifp)
-{
-	const npf_ifops_t *ifops = npf->ifops;
-	char tname[NPF_TABLE_MAXNAMELEN];
-	const char *ifname;
-	npf_config_t *nc;
-	npf_table_t *t;
-	unsigned tid;
-
-	/* Get the interface name and prefix it. */
-	ifname = ifops->getname(npf, ifp);
-	snprintf(tname, sizeof(tname), ".ifnet-%s", ifname);
-
-	KERNEL_LOCK(1, NULL);
-	nc = npf_config_enter(npf);
-
-	/*
-	 * Check whether this interface is of any interest to us.
-	 */
-	t = npf_tableset_getbyname(nc->tableset, tname);
-	if (!t) {
-		goto out;
-	}
-	tid = npf_table_getid(t);
-
-	/* Create a new NPF table for the interface. */
-	t = npf_table_create(tname, tid, NPF_TABLE_IFADDR, NULL, 0);
-	if (!t) {
-		goto out;
-	}
-	return t;
-out:
-	npf_config_exit(npf);
-	KERNEL_UNLOCK_ONE(NULL);
-	return NULL;
-}
-
-static void
-replace_ifnet_table(npf_t *npf, npf_table_t *newt)
-{
-	npf_tableset_t *ts = npf->config->tableset;
-	npf_table_t *oldt;
-
-	KERNEL_UNLOCK_ONE(NULL);
-
-	/*
-	 * Finally, swap the tables and issue a sync barrier.
-	 */
-	oldt = npf_tableset_swap(ts, newt);
-	npf_config_sync(npf);
-	npf_config_exit(npf);
-
-	/* At this point, it is safe to destroy the old table. */
-	npf_table_destroy(oldt);
-}
-
-void
-npf_ifaddr_sync(npf_t *npf, ifnet_t *ifp)
-{
-	npf_table_t *t;
-	struct ifaddr *ifa;
-
-	/*
-	 * First, check whether this interface is of any interest to us.
-	 *
-	 * => Acquires npf-config-lock and kernel-lock on success.
-	 */
-	t = lookup_ifnet_table(npf, ifp);
-	if (!t)
-		return;
-
-	/*
-	 * Populate the table with the interface addresses.
-	 * Note: currently, this list is protected by the kernel-lock.
-	 */
-	IFADDR_FOREACH(ifa, ifp) {
-		struct sockaddr *sa = ifa->ifa_addr;
-		const void *p = NULL;
-		int alen = 0;
-
-		if (sa->sa_family == AF_INET) {
-			const struct sockaddr_in *sin4 = satosin(sa);
-			alen = sizeof(struct in_addr);
-			p = &sin4->sin_addr;
-		}
-		if (sa->sa_family == AF_INET6) {
-			const struct sockaddr_in6 *sin6 = satosin6(sa);
-			alen = sizeof(struct in6_addr);
-			p = &sin6->sin6_addr;
-		}
-		if (alen) {
-			npf_addr_t addr;
-			memcpy(&addr, p, alen);
-			npf_table_insert(t, alen, &addr, NPF_NO_NETMASK);
-		}
-	}
-
-	/* Publish the new table. */
-	replace_ifnet_table(npf, t);
-}
-
-void
-npf_ifaddr_flush(npf_t *npf, ifnet_t *ifp)
-{
-	npf_table_t *t;
-
-	/*
-	 * Flush: just load an empty table.
-	 */
-	t = lookup_ifnet_table(npf, ifp);
-	if (!t) {
-		return;
-	}
-	replace_ifnet_table(npf, t);
-}
-
-void
-npf_ifaddr_syncall(npf_t *npf)
-{
-	ifnet_t *ifp;
-
-	KERNEL_LOCK(1, NULL);
-	IFNET_GLOBAL_LOCK();
-	IFNET_WRITER_FOREACH(ifp) {
-		npf_ifaddr_sync(npf, ifp);
-	}
-	IFNET_GLOBAL_UNLOCK();
-	KERNEL_UNLOCK_ONE(NULL);
-}
diff --git a/src/kern/npf_impl.h b/src/kern/npf_impl.h
deleted file mode 100644
index ef92972..0000000
--- a/src/kern/npf_impl.h
+++ /dev/null
@@ -1,547 +0,0 @@
-/*-
- * Copyright (c) 2009-2019 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * This material is based upon work partially supported by The
- * NetBSD Foundation under a contract with Mindaugas Rasiukevicius.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
- * Private NPF structures and interfaces.
- * For internal use within NPF core only.
- */
-
-#ifndef _NPF_IMPL_H_
-#define _NPF_IMPL_H_
-
-#if !defined(_KERNEL) && !defined(_NPF_STANDALONE)
-#error "Kernel-level header only"
-#endif
-
-#ifdef _KERNEL_OPT
-/* For INET/INET6 definitions. */
-#include "opt_inet.h"
-#include "opt_inet6.h"
-#endif
-
-#ifdef _KERNEL
-#include <sys/types.h>
-#include <sys/queue.h>
-
-#include <net/bpf.h>
-#include <net/bpfjit.h>
-#include <net/if.h>
-#endif
-#include <dnv.h>
-#include <nv.h>
-
-#include "npf.h"
-#include "npfkern.h"
-
-#ifdef _NPF_DEBUG
-#define	NPF_PRINTF(x)	printf x
-#else
-#define	NPF_PRINTF(x)
-#endif
-
-/*
- * STRUCTURE DECLARATIONS.
- */
-
-struct npf_ruleset;
-struct npf_rule;
-struct npf_rprocset;
-struct npf_portmap;
-struct npf_nat;
-struct npf_conn;
-
-typedef struct npf_ruleset	npf_ruleset_t;
-typedef struct npf_rule		npf_rule_t;
-typedef struct npf_portmap	npf_portmap_t;
-typedef struct npf_nat		npf_nat_t;
-typedef struct npf_rprocset	npf_rprocset_t;
-typedef struct npf_alg		npf_alg_t;
-typedef struct npf_natpolicy	npf_natpolicy_t;
-typedef struct npf_conn		npf_conn_t;
-
-struct npf_conndb;
-struct npf_table;
-struct npf_tableset;
-struct npf_algset;
-struct npf_ifmap;
-
-typedef struct npf_conndb	npf_conndb_t;
-typedef struct npf_table	npf_table_t;
-typedef struct npf_tableset	npf_tableset_t;
-typedef struct npf_algset	npf_algset_t;
-
-#ifdef __NetBSD__
-typedef void			ebr_t;
-#endif
-
-/*
- * DEFINITIONS.
- */
-
-typedef struct {
-	npf_ruleset_t *		ruleset;
-	npf_ruleset_t *		nat_ruleset;
-	npf_rprocset_t *	rule_procs;
-	npf_tableset_t *	tableset;
-	bool			default_pass;
-} npf_config_t;
-
-typedef void (*npf_workfunc_t)(npf_t *);
-
-typedef struct {
-	uint64_t	mi_rid;
-	unsigned	mi_retfl;
-	unsigned	mi_di;
-} npf_match_info_t;
-
-/*
- * Some artificial limits.
- * Note: very unlikely to have many ALGs.
- */
-#define	NPF_MAX_RULES		(1024 * 1024)
-#define	NPF_MAX_TABLES		128
-#define	NPF_MAX_RPROCS		128
-#define	NPF_MAX_IFMAP		64
-#define	NPF_MAX_ALGS		4
-#define	NPF_MAX_WORKS		4
-
-/*
- * CONNECTION STATE STRUCTURES
- */
-
-typedef enum {
-	NPF_FLOW_FORW = 0,
-	NPF_FLOW_BACK = 1,
-} npf_flow_t;
-
-typedef struct {
-	uint32_t	nst_end;
-	uint32_t	nst_maxend;
-	uint32_t	nst_maxwin;
-	int		nst_wscale;
-} npf_tcpstate_t;
-
-typedef struct {
-	unsigned 	nst_state;
-	npf_tcpstate_t	nst_tcpst[2];
-} npf_state_t;
-
-/*
- * ALG FUNCTIONS.
- */
-
-typedef struct {
-	bool		(*match)(npf_cache_t *, npf_nat_t *, int);
-	bool		(*translate)(npf_cache_t *, npf_nat_t *, npf_flow_t);
-	npf_conn_t *	(*inspect)(npf_cache_t *, int);
-	void		(*destroy)(npf_t *, npf_nat_t *, npf_conn_t *);
-} npfa_funcs_t;
-
-/*
- * NBUF STRUCTURE.
- */
-
-struct nbuf {
-	struct mbuf *	nb_mbuf0;
-	struct mbuf *	nb_mbuf;
-	void *		nb_nptr;
-	const ifnet_t *	nb_ifp;
-	unsigned	nb_ifid;
-	int		nb_flags;
-	const npf_mbufops_t *nb_mops;
-};
-
-/*
- * PARAMS.
- */
-
-typedef struct npf_paraminfo npf_paraminfo_t;
-
-typedef struct {
-	const char *	name;
-	int *		valp;
-	int		default_val;
-	/*
-	 * Minimum and maximum allowed values (inclusive).
-	 */
-	int		min;
-	int		max;
-} npf_param_t;
-
-typedef enum {
-	NPF_PARAMS_CONN = 0,
-	NPF_PARAMS_CONNDB,
-	NPF_PARAMS_GENERIC_STATE,
-	NPF_PARAMS_TCP_STATE,
-	NPF_PARAMS_COUNT
-} npf_paramgroup_t;
-
-/*
- * NPF INSTANCE (CONTEXT) STRUCTURE AND AUXILIARY OPERATIONS.
- */
-
-struct npf {
-	/* Active NPF configuration. */
-	kmutex_t		config_lock;
-	ebr_t *			ebr;
-	npf_config_t *		config;
-
-	/*
-	 * BPF byte-code context, mbuf operations an arbitrary user argument.
-	 */
-	bpf_ctx_t *		bpfctx;
-	const npf_mbufops_t *	mbufops;
-	void *			arg;
-
-	/* Parameters. */
-	npf_paraminfo_t *	paraminfo;
-	void *			params[NPF_PARAMS_COUNT];
-	int			ip4_reassembly;
-	int			ip4_drop_options;
-	int			ip6_reassembly;
-	int			ip6_drop_options;
-
-	/*
-	 * Connection tracking state: disabled (off) or enabled (on).
-	 * Connection tracking database, connection cache and the lock.
-	 * There are two caches (pools): for IPv4 and IPv6.
-	 */
-	volatile int		conn_tracking;
-	kmutex_t		conn_lock;
-	npf_conndb_t *		conn_db;
-	pool_cache_t		conn_cache[2];
-
-	/* NAT and ALGs. */
-	npf_portmap_t *		portmap;
-	npf_algset_t *		algset;
-
-	/* Interface mapping. */
-	const npf_ifops_t *	ifops;
-	struct npf_ifmap *	ifmap;
-	unsigned		ifmap_cnt;
-	unsigned		ifmap_off;
-	kmutex_t		ifmap_lock;
-
-	/* List of extensions and its lock. */
-	LIST_HEAD(, npf_ext)	ext_list;
-	kmutex_t		ext_lock;
-
-	/* Associated worker information. */
-	unsigned		worker_flags;
-	LIST_ENTRY(npf)		worker_entry;
-	unsigned		worker_wait_time;
-	npf_workfunc_t		worker_funcs[NPF_MAX_WORKS];
-
-	/* Statistics. */
-	percpu_t *		stats_percpu;
-};
-
-/*
- * NPF extensions and rule procedure interface.
- */
-
-struct npf_rproc;
-typedef struct npf_rproc npf_rproc_t;
-
-typedef struct {
-	u_int	version;
-	void *	ctx;
-	int	(*ctor)(npf_rproc_t *, const nvlist_t *);
-	void	(*dtor)(npf_rproc_t *, void *);
-	bool	(*proc)(npf_cache_t *, void *, const npf_match_info_t *, int *);
-} npf_ext_ops_t;
-
-void *		npf_ext_register(npf_t *, const char *, const npf_ext_ops_t *);
-int		npf_ext_unregister(npf_t *, void *);
-void		npf_rproc_assign(npf_rproc_t *, void *);
-
-/*
- * INTERFACES.
- */
-
-/* NPF config, statistics, etc. */
-void		npf_config_init(npf_t *);
-void		npf_config_fini(npf_t *);
-
-npf_config_t *	npf_config_enter(npf_t *);
-void		npf_config_exit(npf_t *);
-void		npf_config_sync(npf_t *);
-bool		npf_config_locked_p(npf_t *);
-int		npf_config_read_enter(npf_t *);
-void		npf_config_read_exit(npf_t *, int);
-
-npf_config_t *	npf_config_create(void);
-void		npf_config_destroy(npf_config_t *);
-void		npf_config_load(npf_t *, npf_config_t *, npf_conndb_t *, bool);
-npf_ruleset_t *	npf_config_ruleset(npf_t *npf);
-npf_ruleset_t *	npf_config_natset(npf_t *npf);
-npf_tableset_t *npf_config_tableset(npf_t *npf);
-bool		npf_default_pass(npf_t *);
-bool		npf_active_p(void);
-
-int		npf_worker_sysinit(unsigned);
-void		npf_worker_sysfini(void);
-int		npf_worker_addfunc(npf_t *, npf_workfunc_t);
-void		npf_worker_enlist(npf_t *);
-void		npf_worker_discharge(npf_t *);
-void		npf_worker_signal(npf_t *);
-
-int		npfctl_run_op(npf_t *, unsigned, const nvlist_t *, nvlist_t *);
-int		npfctl_table(npf_t *, void *);
-
-void		npf_stats_inc(npf_t *, npf_stats_t);
-void		npf_stats_dec(npf_t *, npf_stats_t);
-
-void		npf_param_init(npf_t *);
-void		npf_param_fini(npf_t *);
-void		npf_param_register(npf_t *, npf_param_t *, unsigned);
-void *		npf_param_allocgroup(npf_t *, npf_paramgroup_t, size_t);
-void		npf_param_freegroup(npf_t *, npf_paramgroup_t, size_t);
-int		npf_param_check(npf_t *, const char *, int);
-int		npf_params_export(const npf_t *, nvlist_t *);
-
-void		npf_ifmap_init(npf_t *, const npf_ifops_t *);
-void		npf_ifmap_fini(npf_t *);
-u_int		npf_ifmap_register(npf_t *, const char *);
-void		npf_ifmap_flush(npf_t *);
-u_int		npf_ifmap_getid(npf_t *, const ifnet_t *);
-void		npf_ifmap_copylogname(npf_t *, unsigned, char *, size_t);
-void		npf_ifmap_copyname(npf_t *, unsigned, char *, size_t);
-
-void		npf_ifaddr_sync(npf_t *, ifnet_t *);
-void		npf_ifaddr_flush(npf_t *, ifnet_t *);
-void		npf_ifaddr_syncall(npf_t *);
-
-/* Protocol helpers. */
-int		npf_cache_all(npf_cache_t *);
-void		npf_recache(npf_cache_t *);
-
-bool		npf_rwrip(const npf_cache_t *, u_int, const npf_addr_t *);
-bool		npf_rwrport(const npf_cache_t *, u_int, const in_port_t);
-bool		npf_rwrcksum(const npf_cache_t *, u_int,
-		    const npf_addr_t *, const in_port_t);
-int		npf_napt_rwr(const npf_cache_t *, u_int, const npf_addr_t *,
-		    const in_addr_t);
-int		npf_npt66_rwr(const npf_cache_t *, u_int, const npf_addr_t *,
-		    npf_netmask_t, uint16_t);
-
-uint16_t	npf_fixup16_cksum(uint16_t, uint16_t, uint16_t);
-uint16_t	npf_fixup32_cksum(uint16_t, uint32_t, uint32_t);
-uint16_t	npf_addr_cksum(uint16_t, int, const npf_addr_t *,
-		    const npf_addr_t *);
-uint32_t	npf_addr_mix(const int, const npf_addr_t *, const npf_addr_t *);
-int		npf_addr_cmp(const npf_addr_t *, const npf_netmask_t,
-		    const npf_addr_t *, const npf_netmask_t, const int);
-void		npf_addr_mask(const npf_addr_t *, const npf_netmask_t,
-		    const int, npf_addr_t *);
-void		npf_addr_bitor(const npf_addr_t *, const npf_netmask_t,
-		    const int, npf_addr_t *);
-int		npf_netmask_check(const int, npf_netmask_t);
-
-int		npf_tcpsaw(const npf_cache_t *, tcp_seq *, tcp_seq *,
-		    uint32_t *);
-bool		npf_fetch_tcpopts(npf_cache_t *, uint16_t *, int *);
-bool		npf_set_mss(npf_cache_t *, uint16_t, uint16_t *, uint16_t *,
-		    bool *);
-bool		npf_return_block(npf_cache_t *, const int);
-
-/* BPF interface. */
-void		npf_bpf_sysinit(void);
-void		npf_bpf_sysfini(void);
-void		npf_bpf_prepare(npf_cache_t *, bpf_args_t *, uint32_t *);
-int		npf_bpf_filter(bpf_args_t *, const void *, bpfjit_func_t);
-void *		npf_bpf_compile(void *, size_t);
-bool		npf_bpf_validate(const void *, size_t);
-
-/* Tableset interface. */
-void		npf_tableset_sysinit(void);
-void		npf_tableset_sysfini(void);
-
-npf_tableset_t *npf_tableset_create(u_int);
-void		npf_tableset_destroy(npf_tableset_t *);
-int		npf_tableset_insert(npf_tableset_t *, npf_table_t *);
-npf_table_t *	npf_tableset_getbyname(npf_tableset_t *, const char *);
-npf_table_t *	npf_tableset_getbyid(npf_tableset_t *, u_int);
-npf_table_t *	npf_tableset_swap(npf_tableset_t *, npf_table_t *);
-void		npf_tableset_reload(npf_t *, npf_tableset_t *, npf_tableset_t *);
-int		npf_tableset_export(npf_t *, const npf_tableset_t *, nvlist_t *);
-
-npf_table_t *	npf_table_create(const char *, u_int, int, const void *, size_t);
-void		npf_table_destroy(npf_table_t *);
-
-u_int		npf_table_getid(npf_table_t *);
-int		npf_table_check(npf_tableset_t *, const char *, uint64_t, uint64_t, bool);
-int		npf_table_insert(npf_table_t *, const int,
-		    const npf_addr_t *, const npf_netmask_t);
-int		npf_table_remove(npf_table_t *, const int,
-		    const npf_addr_t *, const npf_netmask_t);
-int		npf_table_lookup(npf_table_t *, const int, const npf_addr_t *);
-npf_addr_t *	npf_table_getsome(npf_table_t *, const int, unsigned);
-int		npf_table_list(npf_table_t *, void *, size_t);
-int		npf_table_flush(npf_table_t *);
-void		npf_table_gc(npf_t *, npf_table_t *);
-
-/* Ruleset interface. */
-npf_ruleset_t *	npf_ruleset_create(size_t);
-void		npf_ruleset_destroy(npf_ruleset_t *);
-void		npf_ruleset_insert(npf_ruleset_t *, npf_rule_t *);
-void		npf_ruleset_reload(npf_t *, npf_ruleset_t *,
-		    npf_ruleset_t *, bool);
-npf_natpolicy_t *npf_ruleset_findnat(npf_ruleset_t *, uint64_t);
-void		npf_ruleset_freealg(npf_ruleset_t *, npf_alg_t *);
-int		npf_ruleset_export(npf_t *, const npf_ruleset_t *,
-		    const char *, nvlist_t *);
-
-npf_rule_t *	npf_ruleset_lookup(npf_ruleset_t *, const char *);
-int		npf_ruleset_add(npf_ruleset_t *, const char *, npf_rule_t *);
-int		npf_ruleset_remove(npf_ruleset_t *, const char *, uint64_t);
-int		npf_ruleset_remkey(npf_ruleset_t *, const char *,
-		    const void *, size_t);
-int		npf_ruleset_list(npf_t *, npf_ruleset_t *, const char *, nvlist_t *);
-int		npf_ruleset_flush(npf_ruleset_t *, const char *);
-void		npf_ruleset_gc(npf_ruleset_t *);
-
-npf_rule_t *	npf_ruleset_inspect(npf_cache_t *, const npf_ruleset_t *,
-		    const int, const int);
-int		npf_rule_conclude(const npf_rule_t *, npf_match_info_t *);
-
-/* Rule interface. */
-npf_rule_t *	npf_rule_alloc(npf_t *, const nvlist_t *);
-void		npf_rule_setcode(npf_rule_t *, int, void *, size_t);
-void		npf_rule_setrproc(npf_rule_t *, npf_rproc_t *);
-void		npf_rule_free(npf_rule_t *);
-uint64_t	npf_rule_getid(const npf_rule_t *);
-npf_natpolicy_t *npf_rule_getnat(const npf_rule_t *);
-void		npf_rule_setnat(npf_rule_t *, npf_natpolicy_t *);
-npf_rproc_t *	npf_rule_getrproc(const npf_rule_t *);
-
-void		npf_ext_init(npf_t *);
-void		npf_ext_fini(npf_t *);
-int		npf_ext_construct(npf_t *, const char *,
-		    npf_rproc_t *, const nvlist_t *);
-
-npf_rprocset_t *npf_rprocset_create(void);
-void		npf_rprocset_destroy(npf_rprocset_t *);
-npf_rproc_t *	npf_rprocset_lookup(npf_rprocset_t *, const char *);
-void		npf_rprocset_insert(npf_rprocset_t *, npf_rproc_t *);
-int		npf_rprocset_export(const npf_rprocset_t *, nvlist_t *);
-
-npf_rproc_t *	npf_rproc_create(const nvlist_t *);
-void		npf_rproc_acquire(npf_rproc_t *);
-void		npf_rproc_release(npf_rproc_t *);
-const char *	npf_rproc_getname(const npf_rproc_t *);
-bool		npf_rproc_run(npf_cache_t *, npf_rproc_t *,
-		    const npf_match_info_t *, int *);
-
-/* State handling. */
-void		npf_state_sysinit(npf_t *);
-void		npf_state_sysfini(npf_t *);
-
-bool		npf_state_init(npf_cache_t *, npf_state_t *);
-bool		npf_state_inspect(npf_cache_t *, npf_state_t *, npf_flow_t);
-int		npf_state_etime(npf_t *, const npf_state_t *, const int);
-void		npf_state_destroy(npf_state_t *);
-
-void		npf_state_tcp_sysinit(npf_t *);
-void		npf_state_tcp_sysfini(npf_t *);
-bool		npf_state_tcp(npf_cache_t *, npf_state_t *, npf_flow_t);
-int		npf_state_tcp_timeout(npf_t *, const npf_state_t *);
-
-/* Portmap. */
-void		npf_portmap_init(npf_t *);
-void		npf_portmap_fini(npf_t *);
-
-npf_portmap_t *	npf_portmap_create(int, int);
-void		npf_portmap_destroy(npf_portmap_t *);
-
-in_port_t	npf_portmap_get(npf_portmap_t *, int, const npf_addr_t *);
-bool		npf_portmap_take(npf_portmap_t *, int, const npf_addr_t *, in_port_t);
-void		npf_portmap_put(npf_portmap_t *, int, const npf_addr_t *, in_port_t);
-void		npf_portmap_flush(npf_portmap_t *);
-
-/* NAT. */
-void		npf_nat_sysinit(void);
-void		npf_nat_sysfini(void);
-npf_natpolicy_t *npf_natpolicy_create(npf_t *, const nvlist_t *, npf_ruleset_t *);
-int		npf_natpolicy_export(const npf_natpolicy_t *, nvlist_t *);
-void		npf_natpolicy_destroy(npf_natpolicy_t *);
-bool		npf_natpolicy_cmp(npf_natpolicy_t *, npf_natpolicy_t *);
-void		npf_nat_setid(npf_natpolicy_t *, uint64_t);
-uint64_t	npf_nat_getid(const npf_natpolicy_t *);
-void		npf_nat_freealg(npf_natpolicy_t *, npf_alg_t *);
-
-int		npf_do_nat(npf_cache_t *, npf_conn_t *, const unsigned);
-npf_nat_t *	npf_nat_share_policy(npf_cache_t *, npf_conn_t *, npf_nat_t *);
-void		npf_nat_destroy(npf_conn_t *, npf_nat_t *);
-void		npf_nat_getorig(npf_nat_t *, npf_addr_t **, in_port_t *);
-void		npf_nat_gettrans(npf_nat_t *, npf_addr_t **, in_port_t *);
-void		npf_nat_setalg(npf_nat_t *, npf_alg_t *, uintptr_t);
-npf_alg_t *	npf_nat_getalg(const npf_nat_t *);
-uintptr_t	npf_nat_getalgarg(const npf_nat_t *);
-
-void		npf_nat_export(npf_t *, const npf_nat_t *, nvlist_t *);
-npf_nat_t *	npf_nat_import(npf_t *, const nvlist_t *, npf_ruleset_t *,
-		    npf_conn_t *);
-
-/* ALG interface. */
-void		npf_alg_sysinit(void);
-void		npf_alg_sysfini(void);
-void		npf_alg_init(npf_t *);
-void		npf_alg_fini(npf_t *);
-npf_alg_t *	npf_alg_register(npf_t *, const char *, const npfa_funcs_t *);
-int		npf_alg_unregister(npf_t *, npf_alg_t *);
-npf_alg_t *	npf_alg_construct(npf_t *, const char *);
-bool		npf_alg_match(npf_cache_t *, npf_nat_t *, int);
-void		npf_alg_exec(npf_cache_t *, npf_nat_t *, const npf_flow_t);
-npf_conn_t *	npf_alg_conn(npf_cache_t *, int);
-int		npf_alg_export(npf_t *, nvlist_t *);
-void		npf_alg_destroy(npf_t *, npf_alg_t *, npf_nat_t *, npf_conn_t *);
-
-/* Wrappers for the reclamation mechanism. */
-ebr_t *		npf_ebr_create(void);
-void		npf_ebr_destroy(ebr_t *);
-void		npf_ebr_register(ebr_t *);
-void		npf_ebr_unregister(ebr_t *);
-int		npf_ebr_enter(ebr_t *);
-void		npf_ebr_exit(ebr_t *, int);
-void		npf_ebr_full_sync(ebr_t *);
-bool		npf_ebr_incrit_p(ebr_t *);
-
-/* Debugging routines. */
-const char *	npf_addr_dump(const npf_addr_t *, int);
-void		npf_state_dump(const npf_state_t *);
-void		npf_nat_dump(const npf_nat_t *);
-void		npf_ruleset_dump(npf_t *, const char *);
-void		npf_state_setsampler(void (*)(npf_state_t *, bool));
-
-/* In-kernel routines. */
-void		npf_setkernctx(npf_t *);
-npf_t *		npf_getkernctx(void);
-
-#endif	/* _NPF_IMPL_H_ */
diff --git a/src/kern/npf_inet.c b/src/kern/npf_inet.c
deleted file mode 100644
index ec42762..0000000
--- a/src/kern/npf_inet.c
+++ /dev/null
@@ -1,927 +0,0 @@
-/*-
- * Copyright (c) 2009-2014 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * This material is based upon work partially supported by The
- * NetBSD Foundation under a contract with Mindaugas Rasiukevicius.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
- * Various protocol related helper routines.
- *
- * This layer manipulates npf_cache_t structure i.e. caches requested headers
- * and stores which information was cached in the information bit field.
- * It is also responsibility of this layer to update or invalidate the cache
- * on rewrites (e.g. by translation routines).
- */
-
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD$");
-
-#include <sys/param.h>
-#include <sys/types.h>
-
-#include <net/pfil.h>
-#include <net/if.h>
-#include <net/ethertypes.h>
-#include <net/if_ether.h>
-
-#include <netinet/in_systm.h>
-#include <netinet/in.h>
-#include <netinet6/in6_var.h>
-#include <netinet/ip.h>
-#include <netinet/ip6.h>
-#include <netinet/tcp.h>
-#include <netinet/udp.h>
-#include <netinet/ip_icmp.h>
-#endif
-
-#include "npf_impl.h"
-
-/*
- * npf_fixup{16,32}_cksum: incremental update of the Internet checksum.
- */
-
-uint16_t
-npf_fixup16_cksum(uint16_t cksum, uint16_t odatum, uint16_t ndatum)
-{
-	uint32_t sum;
-
-	/*
-	 * RFC 1624:
-	 *	HC' = ~(~HC + ~m + m')
-	 *
-	 * Note: 1's complement sum is endian-independent (RFC 1071, page 2).
-	 */
-	sum = ~cksum & 0xffff;
-	sum += (~odatum & 0xffff) + ndatum;
-	sum = (sum >> 16) + (sum & 0xffff);
-	sum += (sum >> 16);
-
-	return ~sum & 0xffff;
-}
-
-uint16_t
-npf_fixup32_cksum(uint16_t cksum, uint32_t odatum, uint32_t ndatum)
-{
-	uint32_t sum;
-
-	/*
-	 * Checksum 32-bit datum as as two 16-bit.  Note, the first
-	 * 32->16 bit reduction is not necessary.
-	 */
-	sum = ~cksum & 0xffff;
-	sum += (~odatum & 0xffff) + (ndatum & 0xffff);
-
-	sum += (~odatum >> 16) + (ndatum >> 16);
-	sum = (sum >> 16) + (sum & 0xffff);
-	sum += (sum >> 16);
-	return ~sum & 0xffff;
-}
-
-/*
- * npf_addr_cksum: calculate checksum of the address, either IPv4 or IPv6.
- */
-uint16_t
-npf_addr_cksum(uint16_t cksum, int sz, const npf_addr_t *oaddr,
-    const npf_addr_t *naddr)
-{
-	const uint32_t *oip32 = (const uint32_t *)oaddr;
-	const uint32_t *nip32 = (const uint32_t *)naddr;
-
-	KASSERT(sz % sizeof(uint32_t) == 0);
-	do {
-		cksum = npf_fixup32_cksum(cksum, *oip32++, *nip32++);
-		sz -= sizeof(uint32_t);
-	} while (sz);
-
-	return cksum;
-}
-
-/*
- * npf_addr_sum: provide IP addresses as a XORed 32-bit integer.
- * Note: used for hash function.
- */
-uint32_t
-npf_addr_mix(const int alen, const npf_addr_t *a1, const npf_addr_t *a2)
-{
-	const int nwords = alen >> 2;
-	uint32_t mix = 0;
-
-	KASSERT(alen > 0 && a1 != NULL && a2 != NULL);
-
-	for (int i = 0; i < nwords; i++) {
-		mix ^= a1->word32[i];
-		mix ^= a2->word32[i];
-	}
-	return mix;
-}
-
-/*
- * npf_addr_mask: apply the mask to a given address and store the result.
- */
-void
-npf_addr_mask(const npf_addr_t *addr, const npf_netmask_t mask,
-    const int alen, npf_addr_t *out)
-{
-	const int nwords = alen >> 2;
-	uint_fast8_t length = mask;
-
-	/* Note: maximum length is 32 for IPv4 and 128 for IPv6. */
-	KASSERT(length <= NPF_MAX_NETMASK);
-
-	for (int i = 0; i < nwords; i++) {
-		uint32_t wordmask;
-
-		if (length >= 32) {
-			wordmask = htonl(0xffffffff);
-			length -= 32;
-		} else if (length) {
-			wordmask = htonl(0xffffffff << (32 - length));
-			length = 0;
-		} else {
-			wordmask = 0;
-		}
-		out->word32[i] = addr->word32[i] & wordmask;
-	}
-}
-
-/*
- * npf_addr_bitor: bitwise OR the host part (given the netmask).
- * Zero mask can be used to OR the entire address.
- */
-void
-npf_addr_bitor(const npf_addr_t *addr, const npf_netmask_t mask,
-    const int alen, npf_addr_t *out)
-{
-	const int nwords = alen >> 2;
-	uint_fast8_t length = mask;
-
-	/* Note: maximum length is 32 for IPv4 and 128 for IPv6. */
-	KASSERT(length <= NPF_MAX_NETMASK);
-
-	for (int i = 0; i < nwords; i++) {
-		uint32_t wordmask;
-
-		if (length >= 32) {
-			wordmask = htonl(0xffffffff);
-			length -= 32;
-		} else if (length) {
-			wordmask = htonl(0xffffffff << (32 - length));
-			length = 0;
-		} else {
-			wordmask = 0;
-		}
-		out->word32[i] |= addr->word32[i] & ~wordmask;
-	}
-}
-
-/*
- * npf_addr_cmp: compare two addresses, either IPv4 or IPv6.
- *
- * => Return 0 if equal and negative/positive if less/greater accordingly.
- * => Ignore the mask, if NPF_NO_NETMASK is specified.
- */
-int
-npf_addr_cmp(const npf_addr_t *addr1, const npf_netmask_t mask1,
-    const npf_addr_t *addr2, const npf_netmask_t mask2, const int alen)
-{
-	npf_addr_t realaddr1, realaddr2;
-
-	if (mask1 != NPF_NO_NETMASK) {
-		npf_addr_mask(addr1, mask1, alen, &realaddr1);
-		addr1 = &realaddr1;
-	}
-	if (mask2 != NPF_NO_NETMASK) {
-		npf_addr_mask(addr2, mask2, alen, &realaddr2);
-		addr2 = &realaddr2;
-	}
-	return memcmp(addr1, addr2, alen);
-}
-
-int
-npf_netmask_check(const int alen, npf_netmask_t mask)
-{
-	switch (alen) {
-	case sizeof(struct in_addr):
-		if (__predict_false(mask > 32 && mask != NPF_NO_NETMASK)) {
-			return EINVAL;
-		}
-		break;
-	case sizeof(struct in6_addr):
-		if (__predict_false(mask > 128 && mask != NPF_NO_NETMASK)) {
-			return EINVAL;
-		}
-		break;
-	default:
-		return EINVAL;
-	}
-	return 0;
-}
-
-/*
- * npf_tcpsaw: helper to fetch SEQ, ACK, WIN and return TCP data length.
- *
- * => Returns all values in host byte-order.
- */
-int
-npf_tcpsaw(const npf_cache_t *npc, tcp_seq *seq, tcp_seq *ack, uint32_t *win)
-{
-	const struct tcphdr *th = npc->npc_l4.tcp;
-	u_int thlen;
-
-	KASSERT(npf_iscached(npc, NPC_TCP));
-
-	*seq = ntohl(th->th_seq);
-	*ack = ntohl(th->th_ack);
-	*win = (uint32_t)ntohs(th->th_win);
-	thlen = th->th_off << 2;
-
-	if (npf_iscached(npc, NPC_IP4)) {
-		const struct ip *ip = npc->npc_ip.v4;
-		return ntohs(ip->ip_len) - npc->npc_hlen - thlen;
-	} else if (npf_iscached(npc, NPC_IP6)) {
-		const struct ip6_hdr *ip6 = npc->npc_ip.v6;
-		return ntohs(ip6->ip6_plen) -
-		    (npc->npc_hlen - sizeof(*ip6)) - thlen;
-	}
-	return 0;
-}
-
-/*
- * npf_fetch_tcpopts: parse and return TCP options.
- */
-bool
-npf_fetch_tcpopts(npf_cache_t *npc, uint16_t *mss, int *wscale)
-{
-	nbuf_t *nbuf = npc->npc_nbuf;
-	const struct tcphdr *th = npc->npc_l4.tcp;
-	int cnt, optlen = 0;
-	uint8_t *cp, opt;
-	uint8_t val;
-	bool ok;
-
-	KASSERT(npf_iscached(npc, NPC_IP46));
-	KASSERT(npf_iscached(npc, NPC_TCP));
-
-	/* Determine if there are any TCP options, get their length. */
-	cnt = (th->th_off << 2) - sizeof(struct tcphdr);
-	if (cnt <= 0) {
-		/* No options. */
-		return false;
-	}
-	KASSERT(cnt <= MAX_TCPOPTLEN);
-
-	/* Fetch all the options at once. */
-	nbuf_reset(nbuf);
-	const int step = npc->npc_hlen + sizeof(struct tcphdr);
-	if ((cp = nbuf_advance(nbuf, step, cnt)) == NULL) {
-		ok = false;
-		goto done;
-	}
-
-	/* Scan the options. */
-	for (; cnt > 0; cnt -= optlen, cp += optlen) {
-		opt = cp[0];
-		if (opt == TCPOPT_EOL)
-			break;
-		if (opt == TCPOPT_NOP)
-			optlen = 1;
-		else {
-			if (cnt < 2)
-				break;
-			optlen = cp[1];
-			if (optlen < 2 || optlen > cnt)
-				break;
-		}
-
-		switch (opt) {
-		case TCPOPT_MAXSEG:
-			if (optlen != TCPOLEN_MAXSEG)
-				continue;
-			if (mss) {
-				memcpy(mss, cp + 2, sizeof(uint16_t));
-			}
-			break;
-		case TCPOPT_WINDOW:
-			if (optlen != TCPOLEN_WINDOW)
-				continue;
-			val = *(cp + 2);
-			*wscale = (val > TCP_MAX_WINSHIFT) ? TCP_MAX_WINSHIFT : val;
-			break;
-		default:
-			break;
-		}
-	}
-
-	ok = true;
-done:
-	if (nbuf_flag_p(nbuf, NBUF_DATAREF_RESET)) {
-		npf_recache(npc);
-	}
-	return ok;
-}
-
-/*
- * npf_set_mss: set the MSS.
- */
-bool
-npf_set_mss(npf_cache_t *npc, uint16_t mss, uint16_t *old, uint16_t *new,
-    bool *mid)
-{
-	nbuf_t *nbuf = npc->npc_nbuf;
-	const struct tcphdr *th = npc->npc_l4.tcp;
-	int cnt, optlen = 0;
-	uint8_t *cp, *base, opt;
-	bool ok;
-
-	KASSERT(npf_iscached(npc, NPC_IP46));
-	KASSERT(npf_iscached(npc, NPC_TCP));
-
-	/* Determine if there are any TCP options, get their length. */
-	cnt = (th->th_off << 2) - sizeof(struct tcphdr);
-	if (cnt <= 0) {
-		/* No options. */
-		return false;
-	}
-	KASSERT(cnt <= MAX_TCPOPTLEN);
-
-	/* Fetch all the options at once. */
-	nbuf_reset(nbuf);
-	const int step = npc->npc_hlen + sizeof(struct tcphdr);
-	if ((base = nbuf_advance(nbuf, step, cnt)) == NULL) {
-		ok = false;
-		goto done;
-	}
-
-	/* Scan the options. */
-	for (cp = base; cnt > 0; cnt -= optlen, cp += optlen) {
-		opt = cp[0];
-		if (opt == TCPOPT_EOL)
-			break;
-		if (opt == TCPOPT_NOP)
-			optlen = 1;
-		else {
-			if (cnt < 2)
-				break;
-			optlen = cp[1];
-			if (optlen < 2 || optlen > cnt)
-				break;
-		}
-
-		switch (opt) {
-		case TCPOPT_MAXSEG:
-			if (optlen != TCPOLEN_MAXSEG)
-				continue;
-			if (((cp + 2) - base) % sizeof(uint16_t) != 0) {
-				*mid = true;
-				memcpy(&old[0], cp + 1, sizeof(uint16_t));
-				memcpy(&old[1], cp + 3, sizeof(uint16_t));
-				memcpy(cp + 2, &mss, sizeof(uint16_t));
-				memcpy(&new[0], cp + 1, sizeof(uint16_t));
-				memcpy(&new[1], cp + 3, sizeof(uint16_t));
-			} else {
-				*mid = false;
-				memcpy(cp + 2, &mss, sizeof(uint16_t));
-			}
-			break;
-		default:
-			break;
-		}
-	}
-
-	ok = true;
-done:
-	if (nbuf_flag_p(nbuf, NBUF_DATAREF_RESET)) {
-		npf_recache(npc);
-	}
-	return ok;
-}
-
-static int
-npf_cache_ip(npf_cache_t *npc, nbuf_t *nbuf)
-{
-	const void *nptr = nbuf_dataptr(nbuf);
-	const uint8_t ver = *(const uint8_t *)nptr;
-	const npf_t *npf = npc->npc_ctx;
-	int flags = 0;
-
-	/*
-	 * We intentionally don't read the L4 payload after IPPROTO_AH.
-	 */
-
-	switch (ver >> 4) {
-	case IPVERSION: {
-		struct ip *ip;
-
-		ip = nbuf_ensure_contig(nbuf, sizeof(struct ip));
-		if (ip == NULL) {
-			return NPC_FMTERR;
-		}
-
-		/* Retrieve the complete header. */
-		if ((u_int)(ip->ip_hl << 2) < sizeof(struct ip)) {
-			return NPC_FMTERR;
-		}
-		if ((ip->ip_hl != 5) && npf->ip4_drop_options) {
-			return NPC_FMTERR;
-		}
-		ip = nbuf_ensure_contig(nbuf, (u_int)(ip->ip_hl << 2));
-		if (ip == NULL) {
-			return NPC_FMTERR;
-		}
-
-		if (ip->ip_off & ~htons(IP_DF | IP_RF)) {
-			/* Note fragmentation. */
-			flags |= NPC_IPFRAG;
-		}
-
-		/* Cache: layer 3 - IPv4. */
-		npc->npc_alen = sizeof(struct in_addr);
-		npc->npc_ips[NPF_SRC] = (npf_addr_t *)&ip->ip_src;
-		npc->npc_ips[NPF_DST] = (npf_addr_t *)&ip->ip_dst;
-		npc->npc_hlen = ip->ip_hl << 2;
-		npc->npc_proto = ip->ip_p;
-
-		npc->npc_ip.v4 = ip;
-		flags |= NPC_IP4;
-		break;
-	}
-
-	case (IPV6_VERSION >> 4): {
-		struct ip6_hdr *ip6;
-		struct ip6_ext *ip6e;
-		struct ip6_frag *ip6f;
-		size_t off, hlen;
-		int frag_present;
-
-		ip6 = nbuf_ensure_contig(nbuf, sizeof(struct ip6_hdr));
-		if (ip6 == NULL) {
-			return NPC_FMTERR;
-		}
-
-		/*
-		 * XXX: We don't handle IPv6 Jumbograms.
-		 */
-
-		/* Set initial next-protocol value. */
-		hlen = sizeof(struct ip6_hdr);
-		npc->npc_proto = ip6->ip6_nxt;
-		npc->npc_hlen = hlen;
-
-		frag_present = 0;
-
-		/*
-		 * Advance by the length of the current header.
-		 */
-		off = nbuf_offset(nbuf);
-		while ((ip6e = nbuf_advance(nbuf, hlen, sizeof(*ip6e))) != NULL) {
-			/*
-			 * Determine whether we are going to continue.
-			 */
-			switch (npc->npc_proto) {
-			case IPPROTO_HOPOPTS:
-			case IPPROTO_DSTOPTS:
-			case IPPROTO_ROUTING:
-				if (npf->ip6_drop_options) {
-					return NPC_FMTERR;
-				}
-				hlen = (ip6e->ip6e_len + 1) << 3;
-				break;
-			case IPPROTO_FRAGMENT:
-				if (frag_present++)
-					return NPC_FMTERR;
-				ip6f = nbuf_ensure_contig(nbuf, sizeof(*ip6f));
-				if (ip6f == NULL)
-					return NPC_FMTERR;
-
-				/* RFC6946: Skip dummy fragments. */
-				if (!ntohs(ip6f->ip6f_offlg & IP6F_OFF_MASK) &&
-				    !(ip6f->ip6f_offlg & IP6F_MORE_FRAG)) {
-					hlen = sizeof(struct ip6_frag);
-					break;
-				}
-
-				hlen = 0;
-				flags |= NPC_IPFRAG;
-
-				break;
-			default:
-				hlen = 0;
-				break;
-			}
-
-			if (!hlen) {
-				break;
-			}
-			npc->npc_proto = ip6e->ip6e_nxt;
-			npc->npc_hlen += hlen;
-		}
-
-		if (ip6e == NULL) {
-			return NPC_FMTERR;
-		}
-
-		/*
-		 * Re-fetch the header pointers (nbufs might have been
-		 * reallocated).  Restore the original offset (if any).
-		 */
-		nbuf_reset(nbuf);
-		ip6 = nbuf_dataptr(nbuf);
-		if (off) {
-			nbuf_advance(nbuf, off, 0);
-		}
-
-		/* Cache: layer 3 - IPv6. */
-		npc->npc_alen = sizeof(struct in6_addr);
-		npc->npc_ips[NPF_SRC] = (npf_addr_t *)&ip6->ip6_src;
-		npc->npc_ips[NPF_DST] = (npf_addr_t *)&ip6->ip6_dst;
-
-		npc->npc_ip.v6 = ip6;
-		flags |= NPC_IP6;
-		break;
-	}
-	default:
-		break;
-	}
-	return flags;
-}
-
-static inline int
-npf_cache_tcp(npf_cache_t *npc, nbuf_t *nbuf, unsigned hlen)
-{
-	struct tcphdr *th;
-
-	th = nbuf_advance(nbuf, hlen, sizeof(struct tcphdr));
-	if (__predict_false(th == NULL)) {
-		return NPC_FMTERR;
-	}
-	if (__predict_false(th->th_off < 5)) {
-		return NPC_FMTERR;
-	}
-	npc->npc_l4.tcp = th;
-	return NPC_LAYER4 | NPC_TCP;
-}
-
-/*
- * npf_cache_all: general routine to cache all relevant IP (v4 or v6)
- * and TCP, UDP or ICMP headers.
- *
- * => nbuf offset shall be set accordingly.
- */
-int
-npf_cache_all(npf_cache_t *npc)
-{
-	nbuf_t *nbuf = npc->npc_nbuf;
-	int flags, l4flags;
-	u_int hlen;
-
-	/*
-	 * This routine is a main point where the references are cached,
-	 * therefore clear the flag as we reset.
-	 */
-again:
-	nbuf_unset_flag(nbuf, NBUF_DATAREF_RESET);
-
-	/*
-	 * First, cache the L3 header (IPv4 or IPv6).  If IP packet is
-	 * fragmented, then we cannot look into L4.
-	 */
-	flags = npf_cache_ip(npc, nbuf);
-	if ((flags & NPC_IP46) == 0 || (flags & NPC_IPFRAG) != 0 ||
-	    (flags & NPC_FMTERR) != 0) {
-		goto out;
-	}
-	hlen = npc->npc_hlen;
-
-	/*
-	 * Note: we guarantee that the potential "Query Id" field of the
-	 * ICMPv4/ICMPv6 packets is in the nbuf. This field is used in the
-	 * ICMP ALG.
-	 */
-	switch (npc->npc_proto) {
-	case IPPROTO_TCP:
-		/* Cache: layer 4 - TCP. */
-		l4flags = npf_cache_tcp(npc, nbuf, hlen);
-		break;
-	case IPPROTO_UDP:
-		/* Cache: layer 4 - UDP. */
-		npc->npc_l4.udp = nbuf_advance(nbuf, hlen,
-		    sizeof(struct udphdr));
-		l4flags = NPC_LAYER4 | NPC_UDP;
-		break;
-	case IPPROTO_ICMP:
-		/* Cache: layer 4 - ICMPv4. */
-		npc->npc_l4.icmp = nbuf_advance(nbuf, hlen,
-		    ICMP_MINLEN);
-		l4flags = NPC_LAYER4 | NPC_ICMP;
-		break;
-	case IPPROTO_ICMPV6:
-		/* Cache: layer 4 - ICMPv6. */
-		npc->npc_l4.icmp6 = nbuf_advance(nbuf, hlen,
-		    sizeof(struct icmp6_hdr));
-		l4flags = NPC_LAYER4 | NPC_ICMP;
-		break;
-	default:
-		l4flags = 0;
-		break;
-	}
-
-	/*
-	 * Error out if nbuf_advance() failed.
-	 */
-	if (__predict_false(l4flags && !npc->npc_l4.hdr)) {
-		goto err;
-	}
-
-	if (nbuf_flag_p(nbuf, NBUF_DATAREF_RESET)) {
-		goto again;
-	}
-
-	flags |= l4flags;
-	npc->npc_info |= flags;
-	return flags;
-
-err:
-	flags = NPC_FMTERR;
-out:
-	nbuf_unset_flag(nbuf, NBUF_DATAREF_RESET);
-	npc->npc_info |= flags;
-	return flags;
-}
-
-void
-npf_recache(npf_cache_t *npc)
-{
-	nbuf_t *nbuf = npc->npc_nbuf;
-	const int mflags __diagused = npc->npc_info & (NPC_IP46 | NPC_LAYER4);
-	int flags __diagused;
-
-	nbuf_reset(nbuf);
-	npc->npc_info = 0;
-	flags = npf_cache_all(npc);
-
-	KASSERT((flags & mflags) == mflags);
-	KASSERT(nbuf_flag_p(nbuf, NBUF_DATAREF_RESET) == 0);
-}
-
-/*
- * npf_rwrip: rewrite required IP address.
- */
-bool
-npf_rwrip(const npf_cache_t *npc, u_int which, const npf_addr_t *addr)
-{
-	KASSERT(npf_iscached(npc, NPC_IP46));
-	KASSERT(which == NPF_SRC || which == NPF_DST);
-
-	memcpy(npc->npc_ips[which], addr, npc->npc_alen);
-	return true;
-}
-
-/*
- * npf_rwrport: rewrite required TCP/UDP port.
- */
-bool
-npf_rwrport(const npf_cache_t *npc, u_int which, const in_port_t port)
-{
-	const int proto = npc->npc_proto;
-	in_port_t *oport;
-
-	KASSERT(npf_iscached(npc, NPC_TCP) || npf_iscached(npc, NPC_UDP));
-	KASSERT(proto == IPPROTO_TCP || proto == IPPROTO_UDP);
-	KASSERT(which == NPF_SRC || which == NPF_DST);
-
-	/* Get the offset and store the port in it. */
-	if (proto == IPPROTO_TCP) {
-		struct tcphdr *th = npc->npc_l4.tcp;
-		oport = (which == NPF_SRC) ? &th->th_sport : &th->th_dport;
-	} else {
-		struct udphdr *uh = npc->npc_l4.udp;
-		oport = (which == NPF_SRC) ? &uh->uh_sport : &uh->uh_dport;
-	}
-	memcpy(oport, &port, sizeof(in_port_t));
-	return true;
-}
-
-/*
- * npf_rwrcksum: rewrite IPv4 and/or TCP/UDP checksum.
- */
-bool
-npf_rwrcksum(const npf_cache_t *npc, u_int which,
-    const npf_addr_t *addr, const in_port_t port)
-{
-	const npf_addr_t *oaddr = npc->npc_ips[which];
-	const int proto = npc->npc_proto;
-	const int alen = npc->npc_alen;
-	uint16_t cksum, *ocksum;
-	struct tcphdr *th;
-	struct udphdr *uh;
-	in_port_t oport;
-
-	KASSERT(npf_iscached(npc, NPC_LAYER4));
-	KASSERT(which == NPF_SRC || which == NPF_DST);
-
-	if (npf_iscached(npc, NPC_IP4)) {
-		struct ip *ip = npc->npc_ip.v4;
-		uint16_t ipsum = ip->ip_sum;
-
-		/* Recalculate IPv4 checksum and rewrite. */
-		ip->ip_sum = npf_addr_cksum(ipsum, alen, oaddr, addr);
-	} else {
-		/* No checksum for IPv6. */
-		KASSERT(npf_iscached(npc, NPC_IP6));
-	}
-
-	/*
-	 * Calculate TCP/UDP checksum:
-	 * - Skip if UDP and the current checksum is zero.
-	 * - Fixup the IP address change.
-	 * - Fixup the port change, if required (non-zero).
-	 */
-	switch (proto) {
-	case IPPROTO_TCP:
-		KASSERT(npf_iscached(npc, NPC_TCP));
-		th = npc->npc_l4.tcp;
-		ocksum = &th->th_sum;
-		oport = (which == NPF_SRC) ? th->th_sport : th->th_dport;
-		break;
-	case IPPROTO_UDP:
-		KASSERT(npf_iscached(npc, NPC_UDP));
-		uh = npc->npc_l4.udp;
-		ocksum = &uh->uh_sum;
-		if (*ocksum == 0) {
-			/* No need to update. */
-			return true;
-		}
-		oport = (which == NPF_SRC) ? uh->uh_sport : uh->uh_dport;
-		break;
-	case IPPROTO_ICMP:
-	case IPPROTO_ICMPV6:
-	default:
-		/* Nothing else to do for ICMP. */
-		return true;
-	}
-
-	/*
-	 * Update and rewrite the TCP/UDP checksum.
-	 */
-	cksum = npf_addr_cksum(*ocksum, alen, oaddr, addr);
-	if (port) {
-		cksum = npf_fixup16_cksum(cksum, oport, port);
-	}
-	memcpy(ocksum, &cksum, sizeof(uint16_t));
-	return true;
-}
-
-/*
- * npf_napt_rwr: perform address and/or port translation.
- */
-int
-npf_napt_rwr(const npf_cache_t *npc, u_int which,
-    const npf_addr_t *addr, const in_addr_t port)
-{
-	const unsigned proto = npc->npc_proto;
-
-	/*
-	 * Rewrite IP and/or TCP/UDP checksums first, since we need the
-	 * current (old) address/port for the calculations.  Then perform
-	 * the address translation i.e. rewrite source or destination.
-	 */
-	if (!npf_rwrcksum(npc, which, addr, port)) {
-		return EINVAL;
-	}
-	if (!npf_rwrip(npc, which, addr)) {
-		return EINVAL;
-	}
-	if (port == 0) {
-		/* Done. */
-		return 0;
-	}
-
-	switch (proto) {
-	case IPPROTO_TCP:
-	case IPPROTO_UDP:
-		/* Rewrite source/destination port. */
-		if (!npf_rwrport(npc, which, port)) {
-			return EINVAL;
-		}
-		break;
-	case IPPROTO_ICMP:
-	case IPPROTO_ICMPV6:
-		KASSERT(npf_iscached(npc, NPC_ICMP));
-		/* Nothing. */
-		break;
-	default:
-		return ENOTSUP;
-	}
-	return 0;
-}
-
-/*
- * IPv6-to-IPv6 Network Prefix Translation (NPTv6), as per RFC 6296.
- */
-int
-npf_npt66_rwr(const npf_cache_t *npc, u_int which, const npf_addr_t *pref,
-    npf_netmask_t len, uint16_t adj)
-{
-	npf_addr_t *addr = npc->npc_ips[which];
-	unsigned remnant, word, preflen = len >> 4;
-	uint32_t sum;
-
-	KASSERT(which == NPF_SRC || which == NPF_DST);
-
-	if (!npf_iscached(npc, NPC_IP6)) {
-		return EINVAL;
-	}
-	if (len <= 48) {
-		/*
-		 * The word to adjust.  Cannot translate the 0xffff
-		 * subnet if /48 or shorter.
-		 */
-		word = 3;
-		if (addr->word16[word] == 0xffff) {
-			return EINVAL;
-		}
-	} else {
-		/*
-		 * Also, all 0s or 1s in the host part are disallowed for
-		 * longer than /48 prefixes.
-		 */
-		if ((addr->word32[2] == 0 && addr->word32[3] == 0) ||
-		    (addr->word32[2] == ~0U && addr->word32[3] == ~0U))
-			return EINVAL;
-
-		/* Determine the 16-bit word to adjust. */
-		for (word = 4; word < 8; word++)
-			if (addr->word16[word] != 0xffff)
-				break;
-	}
-
-	/* Rewrite the prefix. */
-	for (unsigned i = 0; i < preflen; i++) {
-		addr->word16[i] = pref->word16[i];
-	}
-
-	/*
-	 * If prefix length is within a 16-bit word (not dividable by 16),
-	 * then prepare a mask, determine the word and adjust it.
-	 */
-	if ((remnant = len - (preflen << 4)) != 0) {
-		const uint16_t wordmask = (1U << remnant) - 1;
-		const unsigned i = preflen;
-
-		addr->word16[i] = (pref->word16[i] & wordmask) |
-		    (addr->word16[i] & ~wordmask);
-	}
-
-	/*
-	 * Performing 1's complement sum/difference.
-	 */
-	sum = addr->word16[word] + adj;
-	while (sum >> 16) {
-		sum = (sum >> 16) + (sum & 0xffff);
-	}
-	if (sum == 0xffff) {
-		/* RFC 1071. */
-		sum = 0x0000;
-	}
-	addr->word16[word] = sum;
-	return 0;
-}
-
-#if defined(DDB) || defined(_NPF_TESTING)
-
-const char *
-npf_addr_dump(const npf_addr_t *addr, int alen)
-{
-	if (alen == sizeof(struct in_addr)) {
-		struct in_addr ip;
-		memcpy(&ip, addr, alen);
-		return inet_ntoa(ip);
-	}
-	return "[IPv6]";
-}
-
-#endif
diff --git a/src/kern/npf_mbuf.c b/src/kern/npf_mbuf.c
deleted file mode 100644
index ec757e5..0000000
--- a/src/kern/npf_mbuf.c
+++ /dev/null
@@ -1,356 +0,0 @@
-/*-
- * Copyright (c) 2009-2020 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * This material is based upon work partially supported by The
- * NetBSD Foundation under a contract with Mindaugas Rasiukevicius.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
- * NPF network buffer management interface.
- *
- * Network buffer in NetBSD is mbuf.  Internal mbuf structures are
- * abstracted within this source.
- */
-
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD$");
-
-#include <sys/param.h>
-#include <sys/mbuf.h>
-#include <netinet/in_offload.h>
-#endif
-
-#include "npf_impl.h"
-
-#ifdef _KERNEL
-#ifdef INET6
-#include <netinet6/in6.h>
-#include <netinet6/in6_offload.h>
-#endif
-#endif
-
-#if defined(_NPF_STANDALONE)
-#define	m_length(m)		(nbuf)->nb_mops->getchainlen(m)
-#define	m_buflen(m)		(nbuf)->nb_mops->getlen(m)
-#define	m_next_ptr(m)		(nbuf)->nb_mops->getnext(m)
-#define	m_ensure_contig(m,t)	(nbuf)->nb_mops->ensure_contig((m), (t))
-#define	m_makewritable(m,o,l,f)	(nbuf)->nb_mops->ensure_writable((m), (o+l))
-#define	mtod(m,t)		((t)((nbuf)->nb_mops->getdata(m)))
-#define	m_flags_p(m,f)		true
-#define	M_UNWRITABLE(m, l)	false
-#else
-#define	m_next_ptr(m)		(m)->m_next
-#define	m_buflen(m)		((size_t)(m)->m_len)
-#define	m_flags_p(m,f)		(((m)->m_flags & (f)) != 0)
-#endif
-
-#define	NBUF_ENSURE_ALIGN	(MAX(COHERENCY_UNIT, 64))
-#define	NBUF_ENSURE_MASK	(NBUF_ENSURE_ALIGN - 1)
-#define	NBUF_ENSURE_ROUNDUP(x)	(((x) + NBUF_ENSURE_ALIGN) & ~NBUF_ENSURE_MASK)
-
-void
-nbuf_init(npf_t *npf, nbuf_t *nbuf, struct mbuf *m, const ifnet_t *ifp)
-{
-	unsigned ifid = npf_ifmap_getid(npf, ifp);
-
-	KASSERT(m_flags_p(m, M_PKTHDR));
-	nbuf->nb_mops = npf->mbufops;
-
-	nbuf->nb_mbuf0 = m;
-	nbuf->nb_ifp = ifp;
-	nbuf->nb_ifid = ifid;
-	nbuf_reset(nbuf);
-}
-
-void
-nbuf_reset(nbuf_t *nbuf)
-{
-	struct mbuf *m = nbuf->nb_mbuf0;
-
-	nbuf->nb_mbuf = m;
-	nbuf->nb_nptr = mtod(m, void *);
-}
-
-void *
-nbuf_dataptr(nbuf_t *nbuf)
-{
-	KASSERT(nbuf->nb_nptr);
-	return nbuf->nb_nptr;
-}
-
-size_t
-nbuf_offset(const nbuf_t *nbuf)
-{
-	const struct mbuf *m = nbuf->nb_mbuf;
-	const unsigned off = (uintptr_t)nbuf->nb_nptr - mtod(m, uintptr_t);
-	const int poff = m_length(nbuf->nb_mbuf0) - m_length(m) + off;
-
-	return poff;
-}
-
-struct mbuf *
-nbuf_head_mbuf(nbuf_t *nbuf)
-{
-	return nbuf->nb_mbuf0;
-}
-
-bool
-nbuf_flag_p(const nbuf_t *nbuf, int flag)
-{
-	return (nbuf->nb_flags & flag) != 0;
-}
-
-void
-nbuf_unset_flag(nbuf_t *nbuf, int flag)
-{
-	nbuf->nb_flags &= ~flag;
-}
-
-/*
- * nbuf_advance: advance in nbuf or chain by specified amount of bytes and,
- * if requested, ensure that the area *after* advance is contiguous.
- *
- * => Returns new pointer to data in nbuf or NULL if offset is invalid.
- * => Current nbuf and the offset is stored in the nbuf metadata.
- */
-void *
-nbuf_advance(nbuf_t *nbuf, size_t len, size_t ensure)
-{
-	struct mbuf *m = nbuf->nb_mbuf;
-	unsigned off, wmark;
-	uint8_t *d;
-
-	/* Offset with amount to advance. */
-	off = (uintptr_t)nbuf->nb_nptr - mtod(m, uintptr_t) + len;
-	wmark = m_buflen(m);
-
-	/* Find the mbuf according to offset. */
-	while (__predict_false(wmark <= off)) {
-		m = m_next_ptr(m);
-		if (__predict_false(m == NULL)) {
-			/*
-			 * If end of the chain, then the offset is
-			 * higher than packet length.
-			 */
-			return NULL;
-		}
-		wmark += m_buflen(m);
-	}
-	KASSERT(off < m_length(nbuf->nb_mbuf0));
-
-	/* Offset in mbuf data. */
-	d = mtod(m, uint8_t *);
-	KASSERT(off >= (wmark - m_buflen(m)));
-	d += (off - (wmark - m_buflen(m)));
-
-	nbuf->nb_mbuf = m;
-	nbuf->nb_nptr = d;
-
-	if (ensure) {
-		/* Ensure contiguousness (may change nbuf chain). */
-		d = nbuf_ensure_contig(nbuf, ensure);
-	}
-	return d;
-}
-
-/*
- * nbuf_ensure_contig: check whether the specified length from the current
- * point in the nbuf is contiguous.  If not, rearrange the chain to be so.
- *
- * => Returns pointer to the data at the current offset in the buffer.
- * => Returns NULL on failure and nbuf becomes invalid.
- */
-void *
-nbuf_ensure_contig(nbuf_t *nbuf, size_t len)
-{
-	const struct mbuf * const n = nbuf->nb_mbuf;
-	const size_t off = (uintptr_t)nbuf->nb_nptr - mtod(n, uintptr_t);
-
-	KASSERT(off <= m_buflen(n));
-
-	if (__predict_false(m_buflen(n) < (off + len))) {
-		struct mbuf *m = nbuf->nb_mbuf0;
-		const size_t foff = nbuf_offset(nbuf);
-		const size_t plen = m_length(m);
-		const size_t mlen = m_buflen(m);
-		size_t target;
-		bool success;
-
-		//npf_stats_inc(npf, NPF_STAT_NBUF_NONCONTIG);
-
-		/* Attempt to round-up to NBUF_ENSURE_ALIGN bytes. */
-		if ((target = NBUF_ENSURE_ROUNDUP(foff + len)) > plen) {
-			target = foff + len;
-		}
-
-		/* Rearrange the chain to be contiguous. */
-		KASSERT(m_flags_p(m, M_PKTHDR));
-		success = m_ensure_contig(&m, target);
-		KASSERT(m != NULL);
-
-		/* If no change in the chain: return what we have. */
-		if (m == nbuf->nb_mbuf0 && m_buflen(m) == mlen) {
-			return success ? nbuf->nb_nptr : NULL;
-		}
-
-		/*
-		 * The mbuf chain was re-arranged.  Update the pointers
-		 * accordingly and indicate that the references to the data
-		 * might need a reset.
-		 */
-		KASSERT(m_flags_p(m, M_PKTHDR));
-		nbuf->nb_mbuf0 = m;
-		nbuf->nb_mbuf = m;
-
-		KASSERT(foff < m_buflen(m) && foff < m_length(m));
-		nbuf->nb_nptr = mtod(m, uint8_t *) + foff;
-		nbuf->nb_flags |= NBUF_DATAREF_RESET;
-
-		if (!success) {
-			//npf_stats_inc(npf, NPF_STAT_NBUF_CONTIG_FAIL);
-			return NULL;
-		}
-	}
-	return nbuf->nb_nptr;
-}
-
-void *
-nbuf_ensure_writable(nbuf_t *nbuf, size_t len)
-{
-	struct mbuf *m = nbuf->nb_mbuf;
-	const unsigned off = (uintptr_t)nbuf->nb_nptr - mtod(m, uintptr_t);
-	const int tlen = off + len;
-	bool head_buf;
-
-	KASSERT(off < m_length(nbuf->nb_mbuf0));
-
-	if (!M_UNWRITABLE(m, tlen)) {
-		return nbuf->nb_nptr;
-	}
-	head_buf = (nbuf->nb_mbuf0 == m);
-	if (m_makewritable(&m, 0, tlen, M_NOWAIT)) {
-		memset(nbuf, 0, sizeof(nbuf_t));
-		return NULL;
-	}
-	if (head_buf) {
-		KASSERT(m_flags_p(m, M_PKTHDR));
-		KASSERT(off < m_length(m));
-		nbuf->nb_mbuf0 = m;
-	}
-	nbuf->nb_mbuf = m;
-	nbuf->nb_nptr = mtod(m, uint8_t *) + off;
-
-	return nbuf->nb_nptr;
-}
-
-bool
-nbuf_cksum_barrier(nbuf_t *nbuf, int di)
-{
-#ifdef _KERNEL
-	struct mbuf *m;
-
-	if (di != PFIL_OUT) {
-		return false;
-	}
-	m = nbuf->nb_mbuf0;
-	KASSERT(m_flags_p(m, M_PKTHDR));
-
-	if (m->m_pkthdr.csum_flags & (M_CSUM_TCPv4 | M_CSUM_UDPv4)) {
-		in_undefer_cksum_tcpudp(m);
-		m->m_pkthdr.csum_flags &= ~(M_CSUM_TCPv4 | M_CSUM_UDPv4);
-		return true;
-	}
-#ifdef INET6
-	if (m->m_pkthdr.csum_flags & (M_CSUM_TCPv6 | M_CSUM_UDPv6)) {
-		in6_undefer_cksum_tcpudp(m);
-		m->m_pkthdr.csum_flags &= ~(M_CSUM_TCPv6 | M_CSUM_UDPv6);
-		return true;
-	}
-#endif
-#else
-	(void)nbuf; (void)di;
-#endif
-	return false;
-}
-
-/*
- * nbuf_add_tag: associate a tag with the network buffer.
- *
- * => Returns 0 on success or error number on failure.
- */
-int
-nbuf_add_tag(nbuf_t *nbuf, uint32_t val)
-{
-	struct mbuf *m = nbuf->nb_mbuf0;
-#ifdef _KERNEL
-	struct m_tag *mt;
-	uint32_t *dat;
-
-	KASSERT(m_flags_p(m, M_PKTHDR));
-
-	mt = m_tag_get(PACKET_TAG_NPF, sizeof(uint32_t), M_NOWAIT);
-	if (mt == NULL) {
-		return ENOMEM;
-	}
-	dat = (uint32_t *)(mt + 1);
-	*dat = val;
-	m_tag_prepend(m, mt);
-	return 0;
-#else
-	if (!nbuf->nb_mops->set_tag) {
-		return ENOTSUP;
-	}
-	return nbuf->nb_mops->set_tag(m, val);
-#endif
-}
-
-/*
- * nbuf_find_tag: find a tag associated with a network buffer.
- *
- * => Returns 0 on success or error number on failure.
- */
-int
-nbuf_find_tag(nbuf_t *nbuf, uint32_t *val)
-{
-	struct mbuf *m = nbuf->nb_mbuf0;
-#ifdef _KERNEL
-	struct m_tag *mt;
-
-	KASSERT(m_flags_p(m, M_PKTHDR));
-
-	mt = m_tag_find(m, PACKET_TAG_NPF);
-	if (mt == NULL) {
-		return EINVAL;
-	}
-	*val = *(uint32_t *)(mt + 1);
-	return 0;
-#else
-	if (!nbuf->nb_mops->get_tag) {
-		return ENOTSUP;
-	}
-	return nbuf->nb_mops->get_tag(m, val);
-#endif
-}
diff --git a/src/kern/npf_nat.c b/src/kern/npf_nat.c
deleted file mode 100644
index 7bc6d07..0000000
--- a/src/kern/npf_nat.c
+++ /dev/null
@@ -1,1016 +0,0 @@
-/*-
- * Copyright (c) 2014-2020 Mindaugas Rasiukevicius <rmind at noxt eu>
- * Copyright (c) 2010-2013 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * This material is based upon work partially supported by The
- * NetBSD Foundation under a contract with Mindaugas Rasiukevicius.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
- * NPF network address port translation (NAPT) and other forms of NAT.
- * Described in RFC 2663, RFC 3022, etc.
- *
- * Overview
- *
- *	There are a few mechanisms: NAT policy, port map and translation.
- *	The NAT module has a separate ruleset where rules always have an
- *	associated NAT policy.
- *
- * Translation types
- *
- *	There are two types of translation: outbound (NPF_NATOUT) and
- *	inbound (NPF_NATIN).  It should not be confused with connection
- *	direction.  See npf_nat_which() for the description of how the
- *	addresses are rewritten.  The bi-directional NAT is a combined
- *	outbound and inbound translation, therefore is constructed as
- *	two policies.
- *
- * NAT policies and port maps
- *
- *	The NAT (translation) policy is applied when packet matches the
- *	rule.  Apart from the filter criteria, the NAT policy always has
- *	a translation IP address or a table.  If port translation is set,
- *	then NAT mechanism relies on port map mechanism.
- *
- * Connections, translation entries and their life-cycle
- *
- *	NAT relies on the connection tracking module.  Each translated
- *	connection has an associated translation entry (npf_nat_t) which
- *	contains information used for backwards stream translation, i.e.
- *	the original IP address with port and translation port, allocated
- *	from the port map.  Each NAT entry is associated with the policy,
- *	which contains translation IP address.  Allocated port is returned
- *	to the port map and NAT entry is destroyed when connection expires.
- */
-
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD$");
-
-#include <sys/param.h>
-#include <sys/types.h>
-
-#include <sys/atomic.h>
-#include <sys/condvar.h>
-#include <sys/kmem.h>
-#include <sys/mutex.h>
-#include <sys/pool.h>
-#include <sys/proc.h>
-#endif
-
-#include "npf_impl.h"
-#include "npf_conn.h"
-
-/*
- * NAT policy structure.
- */
-struct npf_natpolicy {
-	npf_t *			n_npfctx;
-	kmutex_t		n_lock;
-	LIST_HEAD(, npf_nat)	n_nat_list;
-	unsigned		n_refcnt;
-	uint64_t		n_id;
-
-	/*
-	 * Translation type, flags, address or table and the port.
-	 * Additionally, there may be translation algorithm and any
-	 * auxiliary data, e.g. NPTv6 adjustment value.
-	 *
-	 * NPF_NP_CMP_START mark starts here.
-	 */
-	unsigned		n_type;
-	unsigned		n_flags;
-	unsigned		n_alen;
-
-	npf_addr_t		n_taddr;
-	npf_netmask_t		n_tmask;
-	in_port_t		n_tport;
-	unsigned		n_tid;
-
-	unsigned		n_algo;
-	union {
-		unsigned	n_rr_idx;
-		uint16_t	n_npt66_adj;
-	};
-};
-
-/*
- * Private flags - must be in the NPF_NAT_PRIVMASK range.
- */
-#define	NPF_NAT_USETABLE	(0x01000000 & NPF_NAT_PRIVMASK)
-
-#define	NPF_NP_CMP_START	offsetof(npf_natpolicy_t, n_type)
-#define	NPF_NP_CMP_SIZE		(sizeof(npf_natpolicy_t) - NPF_NP_CMP_START)
-
-/*
- * NAT entry for a connection.
- */
-struct npf_nat {
-	/* Associated NAT policy. */
-	npf_natpolicy_t *	nt_natpolicy;
-
-	uint16_t		nt_ifid;
-	uint16_t		nt_alen;
-
-	/*
-	 * Translation address as well as the original address which is
-	 * used for backwards translation.  The same for ports.
-	 */
-	npf_addr_t		nt_taddr;
-	npf_addr_t		nt_oaddr;
-
-	in_port_t		nt_oport;
-	in_port_t		nt_tport;
-
-	/* ALG (if any) associated with this NAT entry. */
-	npf_alg_t *		nt_alg;
-	uintptr_t		nt_alg_arg;
-
-	LIST_ENTRY(npf_nat)	nt_entry;
-	npf_conn_t *		nt_conn;
-};
-
-static pool_cache_t		nat_cache	__read_mostly;
-
-/*
- * npf_nat_sys{init,fini}: initialize/destroy NAT subsystem structures.
- */
-
-void
-npf_nat_sysinit(void)
-{
-	nat_cache = pool_cache_init(sizeof(npf_nat_t), 0,
-	    0, 0, "npfnatpl", NULL, IPL_NET, NULL, NULL, NULL);
-	KASSERT(nat_cache != NULL);
-}
-
-void
-npf_nat_sysfini(void)
-{
-	/* All NAT policies should already be destroyed. */
-	pool_cache_destroy(nat_cache);
-}
-
-/*
- * npf_natpolicy_create: create a new NAT policy.
- */
-npf_natpolicy_t *
-npf_natpolicy_create(npf_t *npf, const nvlist_t *nat, npf_ruleset_t *rset)
-{
-	npf_natpolicy_t *np;
-	const void *addr;
-	size_t len;
-
-	np = kmem_zalloc(sizeof(npf_natpolicy_t), KM_SLEEP);
-	atomic_store_relaxed(&np->n_refcnt, 1);
-	np->n_npfctx = npf;
-
-	/* The translation type, flags and policy ID. */
-	np->n_type = dnvlist_get_number(nat, "type", 0);
-	np->n_flags = dnvlist_get_number(nat, "flags", 0) & ~NPF_NAT_PRIVMASK;
-	np->n_id = dnvlist_get_number(nat, "nat-policy", 0);
-
-	/* Should be exclusively either inbound or outbound NAT. */
-	if (((np->n_type == NPF_NATIN) ^ (np->n_type == NPF_NATOUT)) == 0) {
-		goto err;
-	}
-	mutex_init(&np->n_lock, MUTEX_DEFAULT, IPL_SOFTNET);
-	LIST_INIT(&np->n_nat_list);
-
-	/*
-	 * Translation IP, mask and port (if applicable).  If using the
-	 * the table, specified by the ID, then the nat-addr/nat-mask will
-	 * be used as a filter for the addresses selected from table.
-	 */
-	if (nvlist_exists_number(nat, "nat-table-id")) {
-		if (np->n_flags & NPF_NAT_STATIC) {
-			goto err;
-		}
-		np->n_tid = nvlist_get_number(nat, "nat-table-id");
-		np->n_tmask = NPF_NO_NETMASK;
-		np->n_flags |= NPF_NAT_USETABLE;
-	} else {
-		addr = dnvlist_get_binary(nat, "nat-addr", &len, NULL, 0);
-		if (!addr || len == 0 || len > sizeof(npf_addr_t)) {
-			goto err;
-		}
-		memcpy(&np->n_taddr, addr, len);
-		np->n_alen = len;
-		np->n_tmask = dnvlist_get_number(nat, "nat-mask", NPF_NO_NETMASK);
-		if (npf_netmask_check(np->n_alen, np->n_tmask)) {
-			goto err;
-		}
-	}
-	np->n_tport = dnvlist_get_number(nat, "nat-port", 0);
-
-	/*
-	 * NAT algorithm.
-	 */
-	np->n_algo = dnvlist_get_number(nat, "nat-algo", 0);
-	switch (np->n_algo) {
-	case NPF_ALGO_NPT66:
-		np->n_npt66_adj = dnvlist_get_number(nat, "npt66-adj", 0);
-		break;
-	case NPF_ALGO_NETMAP:
-		break;
-	case NPF_ALGO_IPHASH:
-	case NPF_ALGO_RR:
-	default:
-		if (np->n_tmask != NPF_NO_NETMASK) {
-			goto err;
-		}
-		break;
-	}
-	return np;
-err:
-	mutex_destroy(&np->n_lock);
-	kmem_free(np, sizeof(npf_natpolicy_t));
-	return NULL;
-}
-
-int
-npf_natpolicy_export(const npf_natpolicy_t *np, nvlist_t *nat)
-{
-	nvlist_add_number(nat, "nat-policy", np->n_id);
-	nvlist_add_number(nat, "type", np->n_type);
-	nvlist_add_number(nat, "flags", np->n_flags);
-
-	if (np->n_flags & NPF_NAT_USETABLE) {
-		nvlist_add_number(nat, "nat-table-id", np->n_tid);
-	} else {
-		nvlist_add_binary(nat, "nat-addr", &np->n_taddr, np->n_alen);
-		nvlist_add_number(nat, "nat-mask", np->n_tmask);
-	}
-	nvlist_add_number(nat, "nat-port", np->n_tport);
-	nvlist_add_number(nat, "nat-algo", np->n_algo);
-
-	switch (np->n_algo) {
-	case NPF_ALGO_NPT66:
-		nvlist_add_number(nat, "npt66-adj", np->n_npt66_adj);
-		break;
-	}
-	return 0;
-}
-
-static void
-npf_natpolicy_release(npf_natpolicy_t *np)
-{
-	KASSERT(atomic_load_relaxed(&np->n_refcnt) > 0);
-
-	if (atomic_dec_uint_nv(&np->n_refcnt) != 0) {
-		return;
-	}
-	KASSERT(LIST_EMPTY(&np->n_nat_list));
-	mutex_destroy(&np->n_lock);
-	kmem_free(np, sizeof(npf_natpolicy_t));
-}
-
-/*
- * npf_natpolicy_destroy: free the NAT policy.
- *
- * => Called from npf_rule_free() during the reload via npf_ruleset_destroy().
- * => At this point, NAT policy cannot acquire new references.
- */
-void
-npf_natpolicy_destroy(npf_natpolicy_t *np)
-{
-	/*
-	 * Drain the references.  If there are active NAT connections,
-	 * then expire them and kick the worker.
-	 */
-	if (atomic_load_relaxed(&np->n_refcnt) > 1) {
-		npf_nat_t *nt;
-
-		mutex_enter(&np->n_lock);
-		LIST_FOREACH(nt, &np->n_nat_list, nt_entry) {
-			npf_conn_t *con = nt->nt_conn;
-			KASSERT(con != NULL);
-			npf_conn_expire(con);
-		}
-		mutex_exit(&np->n_lock);
-		npf_worker_signal(np->n_npfctx);
-	}
-	KASSERT(atomic_load_relaxed(&np->n_refcnt) >= 1);
-
-	/*
-	 * Drop the initial reference, but it might not be the last one.
-	 * If so, the last reference will be triggered via:
-	 *
-	 * npf_conn_destroy() -> npf_nat_destroy() -> npf_natpolicy_release()
-	 */
-	npf_natpolicy_release(np);
-}
-
-void
-npf_nat_freealg(npf_natpolicy_t *np, npf_alg_t *alg)
-{
-	npf_nat_t *nt;
-
-	mutex_enter(&np->n_lock);
-	LIST_FOREACH(nt, &np->n_nat_list, nt_entry) {
-		if (nt->nt_alg == alg) {
-			npf_alg_destroy(np->n_npfctx, alg, nt, nt->nt_conn);
-			nt->nt_alg = NULL;
-		}
-	}
-	mutex_exit(&np->n_lock);
-}
-
-/*
- * npf_natpolicy_cmp: compare two NAT policies.
- *
- * => Return 0 on match, and non-zero otherwise.
- */
-bool
-npf_natpolicy_cmp(npf_natpolicy_t *np, npf_natpolicy_t *mnp)
-{
-	const void *np_raw, *mnp_raw;
-
-	/*
-	 * Compare the relevant NAT policy information (in its raw form)
-	 * that is enough as a matching criteria.
-	 */
-	KASSERT(np && mnp && np != mnp);
-	np_raw = (const uint8_t *)np + NPF_NP_CMP_START;
-	mnp_raw = (const uint8_t *)mnp + NPF_NP_CMP_START;
-	return memcmp(np_raw, mnp_raw, NPF_NP_CMP_SIZE) == 0;
-}
-
-void
-npf_nat_setid(npf_natpolicy_t *np, uint64_t id)
-{
-	np->n_id = id;
-}
-
-uint64_t
-npf_nat_getid(const npf_natpolicy_t *np)
-{
-	return np->n_id;
-}
-
-/*
- * npf_nat_which: tell which address (source or destination) should be
- * rewritten given the combination of the NAT type and flow direction.
- *
- * => Returns NPF_SRC or NPF_DST constant.
- */
-static inline unsigned
-npf_nat_which(const unsigned type, const npf_flow_t flow)
-{
-	unsigned which;
-
-	/* The logic below relies on these values being 0 or 1. */
-	CTASSERT(NPF_SRC == 0 && NPF_DST == 1);
-	CTASSERT(NPF_FLOW_FORW == NPF_SRC && NPF_FLOW_BACK == NPF_DST);
-
-	KASSERT(type == NPF_NATIN || type == NPF_NATOUT);
-	KASSERT(flow == NPF_FLOW_FORW || flow == NPF_FLOW_BACK);
-
-	/*
-	 * Outbound NAT rewrites:
-	 *
-	 * - Source (NPF_SRC) on "forwards" stream.
-	 * - Destination (NPF_DST) on "backwards" stream.
-	 *
-	 * Inbound NAT is other way round.
-	 */
-	which = (type == NPF_NATOUT) ? flow : !flow;
-	KASSERT(which == NPF_SRC || which == NPF_DST);
-	return which;
-}
-
-/*
- * npf_nat_inspect: inspect packet against NAT ruleset and return a policy.
- *
- * => Acquire a reference on the policy, if found.
- * => NAT lookup is protected by EBR.
- */
-static npf_natpolicy_t *
-npf_nat_inspect(npf_cache_t *npc, const unsigned di)
-{
-	npf_t *npf = npc->npc_ctx;
-	int slock = npf_config_read_enter(npf);
-	npf_ruleset_t *rlset = npf_config_natset(npf);
-	npf_natpolicy_t *np;
-	npf_rule_t *rl;
-
-	rl = npf_ruleset_inspect(npc, rlset, di, NPF_LAYER_3);
-	if (rl == NULL) {
-		npf_config_read_exit(npf, slock);
-		return NULL;
-	}
-	np = npf_rule_getnat(rl);
-	atomic_inc_uint(&np->n_refcnt);
-	npf_config_read_exit(npf, slock);
-	return np;
-}
-
-static void
-npf_nat_algo_netmap(const npf_cache_t *npc, const npf_natpolicy_t *np,
-    const unsigned which, npf_addr_t *addr)
-{
-	const npf_addr_t *orig_addr = npc->npc_ips[which];
-
-	/*
-	 * NETMAP:
-	 *
-	 *	addr = net-addr | (orig-addr & ~mask)
-	 */
-	npf_addr_mask(&np->n_taddr, np->n_tmask, npc->npc_alen, addr);
-	npf_addr_bitor(orig_addr, np->n_tmask, npc->npc_alen, addr);
-}
-
-static inline npf_addr_t *
-npf_nat_getaddr(npf_cache_t *npc, npf_natpolicy_t *np, const unsigned alen)
-{
-	npf_tableset_t *ts = npf_config_tableset(np->n_npfctx);
-	npf_table_t *t = npf_tableset_getbyid(ts, np->n_tid);
-	unsigned idx;
-
-	/*
-	 * Dynamically select the translation IP address.
-	 */
-	switch (np->n_algo) {
-	case NPF_ALGO_RR:
-		idx = atomic_inc_uint_nv(&np->n_rr_idx);
-		break;
-	case NPF_ALGO_IPHASH:
-	default:
-		idx = npf_addr_mix(alen,
-		    npc->npc_ips[NPF_SRC],
-		    npc->npc_ips[NPF_DST]);
-		break;
-	}
-	return npf_table_getsome(t, alen, idx);
-}
-
-/*
- * npf_nat_create: create a new NAT translation entry.
- *
- * => The caller must pass the NAT policy with a reference acquired for us.
- */
-static npf_nat_t *
-npf_nat_create(npf_cache_t *npc, npf_natpolicy_t *np, npf_conn_t *con)
-{
-	const unsigned proto = npc->npc_proto;
-	const unsigned alen = npc->npc_alen;
-	const nbuf_t *nbuf = npc->npc_nbuf;
-	npf_t *npf = npc->npc_ctx;
-	npf_addr_t *taddr;
-	npf_nat_t *nt;
-
-	KASSERT(npf_iscached(npc, NPC_IP46));
-	KASSERT(npf_iscached(npc, NPC_LAYER4));
-
-	/* Construct a new NAT entry and associate it with the connection. */
-	nt = pool_cache_get(nat_cache, PR_NOWAIT);
-	if (__predict_false(!nt)) {
-		return NULL;
-	}
-	npf_stats_inc(npf, NPF_STAT_NAT_CREATE);
-	nt->nt_natpolicy = np;
-	nt->nt_conn = con;
-	nt->nt_alg = NULL;
-
-	/*
-	 * Save the interface ID.
-	 *
-	 * Note: this can be different from the given connection if it
-	 * was established on a different interface, using the global state
-	 * mode (state.key.interface = 0).
-	 */
-	KASSERT(nbuf->nb_ifid != 0);
-	nt->nt_ifid = nbuf->nb_ifid;
-
-	/*
-	 * Select the translation address.
-	 */
-	if (np->n_flags & NPF_NAT_USETABLE) {
-		int slock = npf_config_read_enter(npf);
-		taddr = npf_nat_getaddr(npc, np, alen);
-		if (__predict_false(!taddr)) {
-			npf_config_read_exit(npf, slock);
-			pool_cache_put(nat_cache, nt);
-			return NULL;
-		}
-		memcpy(&nt->nt_taddr, taddr, alen);
-		npf_config_read_exit(npf, slock);
-
-	} else if (np->n_algo == NPF_ALGO_NETMAP) {
-		const unsigned which = npf_nat_which(np->n_type, NPF_FLOW_FORW);
-		npf_nat_algo_netmap(npc, np, which, &nt->nt_taddr);
-		taddr = &nt->nt_taddr;
-	} else {
-		/* Static IP address. */
-		taddr = &np->n_taddr;
-		memcpy(&nt->nt_taddr, taddr, alen);
-	}
-	nt->nt_alen = alen;
-
-	/* Save the original address which may be rewritten. */
-	if (np->n_type == NPF_NATOUT) {
-		/* Outbound NAT: source (think internal) address. */
-		memcpy(&nt->nt_oaddr, npc->npc_ips[NPF_SRC], alen);
-	} else {
-		/* Inbound NAT: destination (think external) address. */
-		KASSERT(np->n_type == NPF_NATIN);
-		memcpy(&nt->nt_oaddr, npc->npc_ips[NPF_DST], alen);
-	}
-
-	/*
-	 * Port translation, if required, and if it is TCP/UDP.
-	 */
-	if ((np->n_flags & NPF_NAT_PORTS) == 0 ||
-	    (proto != IPPROTO_TCP && proto != IPPROTO_UDP)) {
-		nt->nt_oport = 0;
-		nt->nt_tport = 0;
-		goto out;
-	}
-
-	/* Save the relevant TCP/UDP port. */
-	if (proto == IPPROTO_TCP) {
-		const struct tcphdr *th = npc->npc_l4.tcp;
-		nt->nt_oport = (np->n_type == NPF_NATOUT) ?
-		    th->th_sport : th->th_dport;
-	} else {
-		const struct udphdr *uh = npc->npc_l4.udp;
-		nt->nt_oport = (np->n_type == NPF_NATOUT) ?
-		    uh->uh_sport : uh->uh_dport;
-	}
-
-	/* Get a new port for translation. */
-	if ((np->n_flags & NPF_NAT_PORTMAP) != 0) {
-		npf_portmap_t *pm = np->n_npfctx->portmap;
-		nt->nt_tport = npf_portmap_get(pm, alen, taddr);
-	} else {
-		nt->nt_tport = np->n_tport;
-	}
-out:
-	mutex_enter(&np->n_lock);
-	LIST_INSERT_HEAD(&np->n_nat_list, nt, nt_entry);
-	/* Note: we also consume the reference on policy. */
-	mutex_exit(&np->n_lock);
-	return nt;
-}
-
-/*
- * npf_dnat_translate: perform translation given the state data.
- */
-static inline int
-npf_dnat_translate(npf_cache_t *npc, npf_nat_t *nt, npf_flow_t flow)
-{
-	const npf_natpolicy_t *np = nt->nt_natpolicy;
-	const unsigned which = npf_nat_which(np->n_type, flow);
-	const npf_addr_t *addr;
-	in_port_t port;
-
-	KASSERT(npf_iscached(npc, NPC_IP46));
-	KASSERT(npf_iscached(npc, NPC_LAYER4));
-
-	if (flow == NPF_FLOW_FORW) {
-		/* "Forwards" stream: use translation address/port. */
-		addr = &nt->nt_taddr;
-		port = nt->nt_tport;
-	} else {
-		/* "Backwards" stream: use original address/port. */
-		addr = &nt->nt_oaddr;
-		port = nt->nt_oport;
-	}
-	KASSERT((np->n_flags & NPF_NAT_PORTS) != 0 || port == 0);
-
-	/* Execute ALG translation first. */
-	if ((npc->npc_info & NPC_ALG_EXEC) == 0) {
-		npc->npc_info |= NPC_ALG_EXEC;
-		npf_alg_exec(npc, nt, flow);
-		npf_recache(npc);
-	}
-	KASSERT(!nbuf_flag_p(npc->npc_nbuf, NBUF_DATAREF_RESET));
-
-	/* Finally, perform the translation. */
-	return npf_napt_rwr(npc, which, addr, port);
-}
-
-/*
- * npf_snat_translate: perform translation given the algorithm.
- */
-static inline int
-npf_snat_translate(npf_cache_t *npc, const npf_natpolicy_t *np, npf_flow_t flow)
-{
-	const unsigned which = npf_nat_which(np->n_type, flow);
-	const npf_addr_t *taddr;
-	npf_addr_t addr;
-
-	KASSERT(np->n_flags & NPF_NAT_STATIC);
-
-	switch (np->n_algo) {
-	case NPF_ALGO_NETMAP:
-		npf_nat_algo_netmap(npc, np, which, &addr);
-		taddr = &addr;
-		break;
-	case NPF_ALGO_NPT66:
-		return npf_npt66_rwr(npc, which, &np->n_taddr,
-		    np->n_tmask, np->n_npt66_adj);
-	default:
-		taddr = &np->n_taddr;
-		break;
-	}
-	return npf_napt_rwr(npc, which, taddr, np->n_tport);
-}
-
-/*
- * Associate NAT policy with an existing connection state.
- */
-npf_nat_t *
-npf_nat_share_policy(npf_cache_t *npc, npf_conn_t *con, npf_nat_t *src_nt)
-{
-	npf_natpolicy_t *np = src_nt->nt_natpolicy;
-	npf_nat_t *nt;
-	int ret;
-
-	/* Create a new NAT entry. */
-	nt = npf_nat_create(npc, np, con);
-	if (__predict_false(nt == NULL)) {
-		return NULL;
-	}
-	atomic_inc_uint(&np->n_refcnt);
-
-	/* Associate the NAT translation entry with the connection. */
-	ret = npf_conn_setnat(npc, con, nt, np->n_type);
-	if (__predict_false(ret)) {
-		/* Will release the reference. */
-		npf_nat_destroy(con, nt);
-		return NULL;
-	}
-	return nt;
-}
-
-/*
- * npf_nat_lookup: lookup the (dynamic) NAT state and return its entry,
- *
- * => Checks that the packet is on the interface where NAT policy is applied.
- * => Determines the flow direction in the context of the NAT policy.
- */
-static npf_nat_t *
-npf_nat_lookup(const npf_cache_t *npc, npf_conn_t *con,
-    const unsigned di, npf_flow_t *flow)
-{
-	const nbuf_t *nbuf = npc->npc_nbuf;
-	const npf_natpolicy_t *np;
-	npf_nat_t *nt;
-
-	if ((nt = npf_conn_getnat(con)) == NULL) {
-		return NULL;
-	}
-	if (nt->nt_ifid != nbuf->nb_ifid) {
-		return NULL;
-	}
-
-	np = nt->nt_natpolicy;
-	KASSERT(atomic_load_relaxed(&np->n_refcnt) > 0);
-
-	/*
-	 * We rely on NPF_NAT{IN,OUT} being equal to PFIL_{IN,OUT}.
-	 */
-	CTASSERT(NPF_NATIN == PFIL_IN && NPF_NATOUT == PFIL_OUT);
-	*flow = (np->n_type == di) ? NPF_FLOW_FORW : NPF_FLOW_BACK;
-	return nt;
-}
-
-/*
- * npf_do_nat:
- *
- *	- Inspect packet for a NAT policy, unless a connection with a NAT
- *	  association already exists.  In such case, determine whether it
- *	  is a "forwards" or "backwards" stream.
- *
- *	- Perform translation: rewrite source or destination fields,
- *	  depending on translation type and direction.
- *
- *	- Associate a NAT policy with a connection (may establish a new).
- */
-int
-npf_do_nat(npf_cache_t *npc, npf_conn_t *con, const unsigned di)
-{
-	nbuf_t *nbuf = npc->npc_nbuf;
-	npf_conn_t *ncon = NULL;
-	npf_natpolicy_t *np;
-	npf_flow_t flow;
-	npf_nat_t *nt;
-	int error;
-
-	/* All relevant data should be already cached. */
-	if (!npf_iscached(npc, NPC_IP46) || !npf_iscached(npc, NPC_LAYER4)) {
-		return 0;
-	}
-	KASSERT(!nbuf_flag_p(nbuf, NBUF_DATAREF_RESET));
-
-	/*
-	 * Return the NAT entry associated with the connection, if any.
-	 * Determines whether the stream is "forwards" or "backwards".
-	 * Note: no need to lock, since reference on connection is held.
-	 */
-	if (con && (nt = npf_nat_lookup(npc, con, di, &flow)) != NULL) {
-		np = nt->nt_natpolicy;
-		goto translate;
-	}
-
-	/*
-	 * Inspect the packet for a NAT policy, if there is no connection.
-	 * Note: acquires a reference if found.
-	 */
-	np = npf_nat_inspect(npc, di);
-	if (np == NULL) {
-		/* If packet does not match - done. */
-		return 0;
-	}
-	flow = NPF_FLOW_FORW;
-
-	/* Static NAT - just perform the translation. */
-	if (np->n_flags & NPF_NAT_STATIC) {
-		if (nbuf_cksum_barrier(nbuf, di)) {
-			npf_recache(npc);
-		}
-		error = npf_snat_translate(npc, np, flow);
-		npf_natpolicy_release(np);
-		return error;
-	}
-
-	/*
-	 * If there is no local connection (no "stateful" rule - unusual,
-	 * but possible configuration), establish one before translation.
-	 * Note that it is not a "pass" connection, therefore passing of
-	 * "backwards" stream depends on other, stateless filtering rules.
-	 */
-	if (con == NULL) {
-		ncon = npf_conn_establish(npc, di, true);
-		if (ncon == NULL) {
-			npf_natpolicy_release(np);
-			return ENOMEM;
-		}
-		con = ncon;
-	}
-
-	/*
-	 * Create a new NAT entry and associate with the connection.
-	 * We will consume the reference on success (release on error).
-	 */
-	nt = npf_nat_create(npc, np, con);
-	if (nt == NULL) {
-		npf_natpolicy_release(np);
-		error = ENOMEM;
-		goto out;
-	}
-
-	/* Determine whether any ALG matches. */
-	if (npf_alg_match(npc, nt, di)) {
-		KASSERT(nt->nt_alg != NULL);
-	}
-
-	/* Associate the NAT translation entry with the connection. */
-	error = npf_conn_setnat(npc, con, nt, np->n_type);
-	if (error) {
-		/* Will release the reference. */
-		npf_nat_destroy(con, nt);
-		goto out;
-	}
-
-translate:
-	/* May need to process the delayed checksums first (XXX: NetBSD). */
-	if (nbuf_cksum_barrier(nbuf, di)) {
-		npf_recache(npc);
-	}
-
-	/* Perform the translation. */
-	error = npf_dnat_translate(npc, nt, flow);
-out:
-	if (__predict_false(ncon)) {
-		if (error) {
-			/* It was created for NAT - just expire. */
-			npf_conn_expire(ncon);
-		}
-		npf_conn_release(ncon);
-	}
-	return error;
-}
-
-/*
- * npf_nat_gettrans: return translation IP address and port.
- */
-void
-npf_nat_gettrans(npf_nat_t *nt, npf_addr_t **addr, in_port_t *port)
-{
-	*addr = &nt->nt_taddr;
-	*port = nt->nt_tport;
-}
-
-/*
- * npf_nat_getorig: return original IP address and port from translation entry.
- */
-void
-npf_nat_getorig(npf_nat_t *nt, npf_addr_t **addr, in_port_t *port)
-{
-	*addr = &nt->nt_oaddr;
-	*port = nt->nt_oport;
-}
-
-/*
- * npf_nat_setalg: associate an ALG with the NAT entry.
- */
-void
-npf_nat_setalg(npf_nat_t *nt, npf_alg_t *alg, uintptr_t arg)
-{
-	nt->nt_alg = alg;
-	nt->nt_alg_arg = arg;
-}
-
-npf_alg_t *
-npf_nat_getalg(const npf_nat_t *nt)
-{
-	return nt->nt_alg;
-}
-
-uintptr_t
-npf_nat_getalgarg(const npf_nat_t *nt)
-{
-	return nt->nt_alg_arg;
-}
-
-/*
- * npf_nat_destroy: destroy NAT structure (performed on connection expiration).
- */
-void
-npf_nat_destroy(npf_conn_t *con, npf_nat_t *nt)
-{
-	npf_natpolicy_t *np = nt->nt_natpolicy;
-	npf_t *npf = np->n_npfctx;
-	npf_alg_t *alg;
-
-	/* Execute the ALG destroy callback, if any. */
-	if ((alg = npf_nat_getalg(nt)) != NULL) {
-		npf_alg_destroy(npf, alg, nt, con);
-		nt->nt_alg = NULL;
-	}
-
-	/* Return taken port to the portmap. */
-	if ((np->n_flags & NPF_NAT_PORTMAP) != 0 && nt->nt_tport) {
-		npf_portmap_t *pm = npf->portmap;
-		npf_portmap_put(pm, nt->nt_alen, &nt->nt_taddr, nt->nt_tport);
-	}
-	npf_stats_inc(np->n_npfctx, NPF_STAT_NAT_DESTROY);
-
-	/*
-	 * Remove the connection from the list and drop the reference on
-	 * the NAT policy.  Note: this might trigger its destruction.
-	 */
-	mutex_enter(&np->n_lock);
-	LIST_REMOVE(nt, nt_entry);
-	mutex_exit(&np->n_lock);
-	npf_natpolicy_release(np);
-
-	pool_cache_put(nat_cache, nt);
-}
-
-/*
- * npf_nat_export: serialize the NAT entry with a NAT policy ID.
- */
-void
-npf_nat_export(npf_t *npf, const npf_nat_t *nt, nvlist_t *con_nv)
-{
-	npf_natpolicy_t *np = nt->nt_natpolicy;
-	unsigned alen = nt->nt_alen;
-	nvlist_t *nat_nv;
-
-	nat_nv = nvlist_create(0);
-	if (nt->nt_ifid) {
-		char ifname[IFNAMSIZ];
-		npf_ifmap_copyname(npf, nt->nt_ifid, ifname, sizeof(ifname));
-		nvlist_add_string(nat_nv, "ifname", ifname);
-	}
-	nvlist_add_number(nat_nv, "alen", alen);
-
-	nvlist_add_binary(nat_nv, "oaddr", &nt->nt_oaddr, alen);
-	nvlist_add_number(nat_nv, "oport", nt->nt_oport);
-
-	nvlist_add_binary(nat_nv, "taddr", &nt->nt_taddr, alen);
-	nvlist_add_number(nat_nv, "tport", nt->nt_tport);
-
-	nvlist_add_number(nat_nv, "nat-policy", np->n_id);
-	nvlist_move_nvlist(con_nv, "nat", nat_nv);
-}
-
-/*
- * npf_nat_import: find the NAT policy and unserialize the NAT entry.
- */
-npf_nat_t *
-npf_nat_import(npf_t *npf, const nvlist_t *nat,
-    npf_ruleset_t *natlist, npf_conn_t *con)
-{
-	npf_natpolicy_t *np;
-	npf_nat_t *nt;
-	const char *ifname;
-	const void *taddr, *oaddr;
-	size_t alen, len;
-	uint64_t np_id;
-
-	np_id = dnvlist_get_number(nat, "nat-policy", UINT64_MAX);
-	if ((np = npf_ruleset_findnat(natlist, np_id)) == NULL) {
-		return NULL;
-	}
-	nt = pool_cache_get(nat_cache, PR_WAITOK);
-	memset(nt, 0, sizeof(npf_nat_t));
-
-	ifname = dnvlist_get_string(nat, "ifname", NULL);
-	if (ifname && (nt->nt_ifid = npf_ifmap_register(npf, ifname)) == 0) {
-		goto err;
-	}
-
-	alen = dnvlist_get_number(nat, "alen", 0);
-	if (alen == 0 || alen > sizeof(npf_addr_t)) {
-		goto err;
-	}
-
-	taddr = dnvlist_get_binary(nat, "taddr", &len, NULL, 0);
-	if (!taddr || len != alen) {
-		goto err;
-	}
-	memcpy(&nt->nt_taddr, taddr, sizeof(npf_addr_t));
-
-	oaddr = dnvlist_get_binary(nat, "oaddr", &len, NULL, 0);
-	if (!oaddr || len != alen) {
-		goto err;
-	}
-	memcpy(&nt->nt_oaddr, oaddr, sizeof(npf_addr_t));
-
-	nt->nt_oport = dnvlist_get_number(nat, "oport", 0);
-	nt->nt_tport = dnvlist_get_number(nat, "tport", 0);
-
-	/* Take a specific port from port-map. */
-	if ((np->n_flags & NPF_NAT_PORTMAP) != 0 && nt->nt_tport) {
-		npf_portmap_t *pm = npf->portmap;
-
-		if (!npf_portmap_take(pm, nt->nt_alen,
-		    &nt->nt_taddr, nt->nt_tport)) {
-			goto err;
-		}
-	}
-	npf_stats_inc(npf, NPF_STAT_NAT_CREATE);
-
-	/*
-	 * Associate, take a reference and insert.  Unlocked/non-atomic
-	 * since the policy is not yet globally visible.
-	 */
-	nt->nt_natpolicy = np;
-	nt->nt_conn = con;
-	atomic_store_relaxed(&np->n_refcnt,
-	    atomic_load_relaxed(&np->n_refcnt) + 1);
-	LIST_INSERT_HEAD(&np->n_nat_list, nt, nt_entry);
-	return nt;
-err:
-	pool_cache_put(nat_cache, nt);
-	return NULL;
-}
-
-#if defined(DDB) || defined(_NPF_TESTING)
-
-void
-npf_nat_dump(const npf_nat_t *nt)
-{
-	const npf_natpolicy_t *np;
-	struct in_addr ip;
-
-	np = nt->nt_natpolicy;
-	memcpy(&ip, &nt->nt_taddr, sizeof(ip));
-	printf("\tNATP(%p): type %u flags 0x%x taddr %s tport %d\n", np,
-	    np->n_type, np->n_flags, inet_ntoa(ip), ntohs(np->n_tport));
-	memcpy(&ip, &nt->nt_oaddr, sizeof(ip));
-	printf("\tNAT: original address %s oport %d tport %d\n",
-	    inet_ntoa(ip), ntohs(nt->nt_oport), ntohs(nt->nt_tport));
-	if (nt->nt_alg) {
-		printf("\tNAT ALG = %p, ARG = %p\n",
-		    nt->nt_alg, (void *)nt->nt_alg_arg);
-	}
-}
-
-#endif
diff --git a/src/kern/npf_os.c b/src/kern/npf_os.c
deleted file mode 100644
index 80006dd..0000000
--- a/src/kern/npf_os.c
+++ /dev/null
@@ -1,577 +0,0 @@
-/*-
- * Copyright (c) 2009-2016 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * This material is based upon work partially supported by The
- * NetBSD Foundation under a contract with Mindaugas Rasiukevicius.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
- * NPF main: dynamic load/initialisation and unload routines.
- */
-
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD$");
-
-#ifdef _KERNEL_OPT
-#include "pf.h"
-#if NPF > 0
-#error "NPF and PF are mutually exclusive; please select one"
-#endif
-#endif
-
-#include <sys/param.h>
-#include <sys/types.h>
-
-#include <sys/conf.h>
-#include <sys/kauth.h>
-#include <sys/kmem.h>
-#include <sys/lwp.h>
-#include <sys/module.h>
-#include <sys/pserialize.h>
-#include <sys/socketvar.h>
-#include <sys/uio.h>
-
-#include <netinet/in.h>
-#include <netinet6/in6_var.h>
-#endif
-
-#include "npf_impl.h"
-#include "npfkern.h"
-
-#ifdef _KERNEL
-#ifndef _MODULE
-#include "opt_modular.h"
-#include "opt_net_mpsafe.h"
-#endif
-#include "ioconf.h"
-#endif
-
-/*
- * Module and device structures.
- */
-#ifndef _MODULE
-/*
- * Modular kernels load drivers too early, and we need percpu to be inited
- * So we make this misc; a better way would be to have early boot and late
- * boot drivers.
- */
-MODULE(MODULE_CLASS_MISC, npf, "bpf");
-#else
-/* This module autoloads via /dev/npf so it needs to be a driver */
-MODULE(MODULE_CLASS_DRIVER, npf, "bpf");
-#endif
-
-#define	NPF_IOCTL_DATA_LIMIT	(4 * 1024 * 1024)
-
-static int	npf_pfil_register(bool);
-static void	npf_pfil_unregister(bool);
-
-static int	npf_dev_open(dev_t, int, int, lwp_t *);
-static int	npf_dev_close(dev_t, int, int, lwp_t *);
-static int	npf_dev_ioctl(dev_t, u_long, void *, int, lwp_t *);
-static int	npf_dev_poll(dev_t, int, lwp_t *);
-static int	npf_dev_read(dev_t, struct uio *, int);
-
-const struct cdevsw npf_cdevsw = {
-	.d_open = npf_dev_open,
-	.d_close = npf_dev_close,
-	.d_read = npf_dev_read,
-	.d_write = nowrite,
-	.d_ioctl = npf_dev_ioctl,
-	.d_stop = nostop,
-	.d_tty = notty,
-	.d_poll = npf_dev_poll,
-	.d_mmap = nommap,
-	.d_kqfilter = nokqfilter,
-	.d_discard = nodiscard,
-	.d_flag = D_OTHER | D_MPSAFE
-};
-
-static const char *	npf_ifop_getname(npf_t *, ifnet_t *);
-static ifnet_t *	npf_ifop_lookup(npf_t *, const char *);
-static void		npf_ifop_flush(npf_t *, void *);
-static void *		npf_ifop_getmeta(npf_t *, const ifnet_t *);
-static void		npf_ifop_setmeta(npf_t *, ifnet_t *, void *);
-
-static const unsigned	nworkers = 1;
-
-static bool		pfil_registered = false;
-static pfil_head_t *	npf_ph_if = NULL;
-static pfil_head_t *	npf_ph_inet = NULL;
-static pfil_head_t *	npf_ph_inet6 = NULL;
-
-static const npf_ifops_t kern_ifops = {
-	.getname	= npf_ifop_getname,
-	.lookup		= npf_ifop_lookup,
-	.flush		= npf_ifop_flush,
-	.getmeta	= npf_ifop_getmeta,
-	.setmeta	= npf_ifop_setmeta,
-};
-
-static int
-npf_fini(void)
-{
-	npf_t *npf = npf_getkernctx();
-
-	/* At first, detach device and remove pfil hooks. */
-#ifdef _MODULE
-	devsw_detach(NULL, &npf_cdevsw);
-#endif
-	npf_pfil_unregister(true);
-	npfk_destroy(npf);
-	npfk_sysfini();
-	return 0;
-}
-
-static int
-npf_init(void)
-{
-	npf_t *npf;
-	int error = 0;
-
-	error = npfk_sysinit(nworkers);
-	if (error)
-		return error;
-	npf = npfk_create(0, NULL, &kern_ifops, NULL);
-	npf_setkernctx(npf);
-	npf_pfil_register(true);
-
-#ifdef _MODULE
-	devmajor_t bmajor = NODEVMAJOR, cmajor = NODEVMAJOR;
-
-	/* Attach /dev/npf device. */
-	error = devsw_attach("npf", NULL, &bmajor, &npf_cdevsw, &cmajor);
-	if (error) {
-		/* It will call devsw_detach(), which is safe. */
-		(void)npf_fini();
-	}
-#endif
-	return error;
-}
-
-
-/*
- * Module interface.
- */
-static int
-npf_modcmd(modcmd_t cmd, void *arg)
-{
-	switch (cmd) {
-	case MODULE_CMD_INIT:
-		return npf_init();
-	case MODULE_CMD_FINI:
-		return npf_fini();
-	case MODULE_CMD_AUTOUNLOAD:
-		if (npf_autounload_p()) {
-			return EBUSY;
-		}
-		break;
-	default:
-		return ENOTTY;
-	}
-	return 0;
-}
-
-void
-npfattach(int nunits)
-{
-	/* Nothing */
-}
-
-static int
-npf_dev_open(dev_t dev, int flag, int mode, lwp_t *l)
-{
-	/* Available only for super-user. */
-	if (kauth_authorize_network(l->l_cred, KAUTH_NETWORK_FIREWALL,
-	    KAUTH_REQ_NETWORK_FIREWALL_FW, NULL, NULL, NULL)) {
-		return EPERM;
-	}
-	return 0;
-}
-
-static int
-npf_dev_close(dev_t dev, int flag, int mode, lwp_t *l)
-{
-	return 0;
-}
-
-static int
-npf_stats_export(npf_t *npf, void *data)
-{
-	uint64_t *fullst, *uptr = *(uint64_t **)data;
-	int error;
-
-	fullst = kmem_alloc(NPF_STATS_SIZE, KM_SLEEP);
-	npfk_stats(npf, fullst); /* will zero the buffer */
-	error = copyout(fullst, uptr, NPF_STATS_SIZE);
-	kmem_free(fullst, NPF_STATS_SIZE);
-	return error;
-}
-
-/*
- * npfctl_switch: enable or disable packet inspection.
- */
-static int
-npfctl_switch(void *data)
-{
-	const bool onoff = *(int *)data ? true : false;
-	int error;
-
-	if (onoff) {
-		/* Enable: add pfil hooks. */
-		error = npf_pfil_register(false);
-	} else {
-		/* Disable: remove pfil hooks. */
-		npf_pfil_unregister(false);
-		error = 0;
-	}
-	return error;
-}
-
-static int
-npf_dev_ioctl(dev_t dev, u_long cmd, void *data, int flag, lwp_t *l)
-{
-	npf_t *npf = npf_getkernctx();
-	nvlist_t *req, *resp;
-	int error;
-
-	/* Available only for super-user. */
-	if (kauth_authorize_network(l->l_cred, KAUTH_NETWORK_FIREWALL,
-	    KAUTH_REQ_NETWORK_FIREWALL_FW, NULL, NULL, NULL)) {
-		return EPERM;
-	}
-
-	switch (cmd) {
-	case IOC_NPF_VERSION:
-		*(int *)data = NPF_VERSION;
-		return 0;
-
-	case IOC_NPF_SWITCH:
-		return npfctl_switch(data);
-
-	case IOC_NPF_TABLE:
-		return npfctl_table(npf, data);
-
-	case IOC_NPF_STATS:
-		return npf_stats_export(npf, data);
-	}
-
-	error = nvlist_copyin(data, &req, NPF_IOCTL_DATA_LIMIT);
-	if (__predict_false(error)) {
-		return error;
-	}
-	resp = nvlist_create(0);
-	npfctl_run_op(npf, cmd, req, resp);
-	error = nvlist_copyout(data, resp);
-	nvlist_destroy(resp);
-	nvlist_destroy(req);
-
-	return error;
-}
-
-static int
-npf_dev_poll(dev_t dev, int events, lwp_t *l)
-{
-	return ENOTSUP;
-}
-
-static int
-npf_dev_read(dev_t dev, struct uio *uio, int flag)
-{
-	return ENOTSUP;
-}
-
-bool
-npf_autounload_p(void)
-{
-	npf_t *npf = npf_getkernctx();
-	return !npf_active_p() && npf_default_pass(npf);
-}
-
-/*
- * Interface operations.
- */
-
-static const char *
-npf_ifop_getname(npf_t *npf __unused, ifnet_t *ifp)
-{
-	return ifp->if_xname;
-}
-
-static ifnet_t *
-npf_ifop_lookup(npf_t *npf __unused, const char *name)
-{
-	return ifunit(name);
-}
-
-static void
-npf_ifop_flush(npf_t *npf __unused, void *arg)
-{
-	ifnet_t *ifp;
-
-	KERNEL_LOCK(1, NULL);
-	IFNET_GLOBAL_LOCK();
-	IFNET_WRITER_FOREACH(ifp) {
-		ifp->if_npf_private = arg;
-	}
-	IFNET_GLOBAL_UNLOCK();
-	KERNEL_UNLOCK_ONE(NULL);
-}
-
-static void *
-npf_ifop_getmeta(npf_t *npf __unused, const ifnet_t *ifp)
-{
-	return ifp->if_npf_private;
-}
-
-static void
-npf_ifop_setmeta(npf_t *npf __unused, ifnet_t *ifp, void *arg)
-{
-	ifp->if_npf_private = arg;
-}
-
-#ifdef _KERNEL
-
-/*
- * Wrapper of the main packet handler to pass the kernel NPF context.
- */
-static int
-npfos_packet_handler(void *arg, struct mbuf **mp, ifnet_t *ifp, int di)
-{
-	npf_t *npf = npf_getkernctx();
-	return npfk_packet_handler(npf, mp, ifp, di);
-}
-
-/*
- * npf_ifhook: hook handling interface changes.
- */
-static void
-npf_ifhook(void *arg, unsigned long cmd, void *arg2)
-{
-	npf_t *npf = npf_getkernctx();
-	ifnet_t *ifp = arg2;
-
-	switch (cmd) {
-	case PFIL_IFNET_ATTACH:
-		npfk_ifmap_attach(npf, ifp);
-		npf_ifaddr_sync(npf, ifp);
-		break;
-	case PFIL_IFNET_DETACH:
-		npfk_ifmap_detach(npf, ifp);
-		npf_ifaddr_flush(npf, ifp);
-		break;
-	}
-}
-
-static void
-npf_ifaddrhook(void *arg, u_long cmd, void *arg2)
-{
-	npf_t *npf = npf_getkernctx();
-	struct ifaddr *ifa = arg2;
-
-	switch (cmd) {
-	case SIOCSIFADDR:
-	case SIOCAIFADDR:
-	case SIOCDIFADDR:
-#ifdef INET6
-	case SIOCSIFADDR_IN6:
-	case SIOCAIFADDR_IN6:
-	case SIOCDIFADDR_IN6:
-#endif
-		KASSERT(ifa != NULL);
-		break;
-	default:
-		return;
-	}
-	npf_ifaddr_sync(npf, ifa->ifa_ifp);
-}
-
-/*
- * npf_pfil_register: register pfil(9) hooks.
- */
-static int
-npf_pfil_register(bool init)
-{
-	npf_t *npf = npf_getkernctx();
-	int error = 0;
-
-	SOFTNET_KERNEL_LOCK_UNLESS_NET_MPSAFE();
-
-	/* Init: interface re-config and attach/detach hook. */
-	if (!npf_ph_if) {
-		npf_ph_if = pfil_head_get(PFIL_TYPE_IFNET, 0);
-		if (!npf_ph_if) {
-			error = ENOENT;
-			goto out;
-		}
-
-		error = pfil_add_ihook(npf_ifhook, NULL,
-		    PFIL_IFNET, npf_ph_if);
-		KASSERT(error == 0);
-
-		error = pfil_add_ihook(npf_ifaddrhook, NULL,
-		    PFIL_IFADDR, npf_ph_if);
-		KASSERT(error == 0);
-	}
-	if (init) {
-		goto out;
-	}
-
-	/* Check if pfil hooks are not already registered. */
-	if (pfil_registered) {
-		error = EEXIST;
-		goto out;
-	}
-
-	/* Capture points of the activity in the IP layer. */
-	npf_ph_inet = pfil_head_get(PFIL_TYPE_AF, (void *)AF_INET);
-	npf_ph_inet6 = pfil_head_get(PFIL_TYPE_AF, (void *)AF_INET6);
-	if (!npf_ph_inet && !npf_ph_inet6) {
-		error = ENOENT;
-		goto out;
-	}
-
-	/* Packet IN/OUT handlers for IP layer. */
-	if (npf_ph_inet) {
-		error = pfil_add_hook(npfos_packet_handler, npf,
-		    PFIL_ALL, npf_ph_inet);
-		KASSERT(error == 0);
-	}
-	if (npf_ph_inet6) {
-		error = pfil_add_hook(npfos_packet_handler, npf,
-		    PFIL_ALL, npf_ph_inet6);
-		KASSERT(error == 0);
-	}
-
-	/*
-	 * It is necessary to re-sync all/any interface address tables,
-	 * since we did not listen for any changes.
-	 */
-	npf_ifaddr_syncall(npf);
-	pfil_registered = true;
-out:
-	SOFTNET_KERNEL_UNLOCK_UNLESS_NET_MPSAFE();
-
-	return error;
-}
-
-/*
- * npf_pfil_unregister: unregister pfil(9) hooks.
- */
-static void
-npf_pfil_unregister(bool fini)
-{
-	npf_t *npf = npf_getkernctx();
-
-	SOFTNET_KERNEL_LOCK_UNLESS_NET_MPSAFE();
-
-	if (fini && npf_ph_if) {
-		(void)pfil_remove_ihook(npf_ifhook, NULL,
-		    PFIL_IFNET, npf_ph_if);
-		(void)pfil_remove_ihook(npf_ifaddrhook, NULL,
-		    PFIL_IFADDR, npf_ph_if);
-	}
-	if (npf_ph_inet) {
-		(void)pfil_remove_hook(npfos_packet_handler, npf,
-		    PFIL_ALL, npf_ph_inet);
-	}
-	if (npf_ph_inet6) {
-		(void)pfil_remove_hook(npfos_packet_handler, npf,
-		    PFIL_ALL, npf_ph_inet6);
-	}
-	pfil_registered = false;
-
-	SOFTNET_KERNEL_UNLOCK_UNLESS_NET_MPSAFE();
-}
-
-bool
-npf_active_p(void)
-{
-	return pfil_registered;
-}
-
-#endif
-
-#ifdef __NetBSD__
-
-/*
- * Epoch-Based Reclamation (EBR) wrappers: in NetBSD, we rely on the
- * passive serialization mechanism (see pserialize(9) manual page),
- * which provides sufficient guarantees for NPF.
- */
-
-ebr_t *
-npf_ebr_create(void)
-{
-	return pserialize_create();
-}
-
-void
-npf_ebr_destroy(ebr_t *ebr)
-{
-	pserialize_destroy(ebr);
-}
-
-void
-npf_ebr_register(ebr_t *ebr)
-{
-	KASSERT(ebr != NULL); (void)ebr;
-}
-
-void
-npf_ebr_unregister(ebr_t *ebr)
-{
-	KASSERT(ebr != NULL); (void)ebr;
-}
-
-int
-npf_ebr_enter(ebr_t *ebr)
-{
-	KASSERT(ebr != NULL); (void)ebr;
-	return pserialize_read_enter();
-}
-
-void
-npf_ebr_exit(ebr_t *ebr, int s)
-{
-	KASSERT(ebr != NULL); (void)ebr;
-	pserialize_read_exit(s);
-}
-
-void
-npf_ebr_full_sync(ebr_t *ebr)
-{
-	pserialize_perform(ebr);
-}
-
-bool
-npf_ebr_incrit_p(ebr_t *ebr)
-{
-	KASSERT(ebr != NULL); (void)ebr;
-	return pserialize_in_read_section();
-}
-
-#endif
diff --git a/src/kern/npf_params.c b/src/kern/npf_params.c
deleted file mode 100644
index 2f701f2..0000000
--- a/src/kern/npf_params.c
+++ /dev/null
@@ -1,263 +0,0 @@
-/*-
- * Copyright (c) 2019-2020 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD$");
-
-#include <sys/param.h>
-#include <sys/types.h>
-
-#include <sys/kmem.h>
-#include <sys/queue.h>
-#include <sys/thmap.h>
-#endif
-
-#include "npf_impl.h"
-
-typedef struct npf_paramreg {
-	struct npf_paramreg *	next;
-	unsigned		count;
-	npf_param_t		params[];
-} npf_paramreg_t;
-
-struct npf_paraminfo {
-	npf_paramreg_t *	list;
-	thmap_t *		map;
-};
-
-static inline void
-npf_param_general_register(npf_t *npf)
-{
-	npf_param_t param_map[] = {
-		{
-			"ip4.reassembly",
-			&npf->ip4_reassembly,
-			.default_val = 0, // false
-			.min = 0, .max = 1
-		},
-		{
-			"ip4.drop_options",
-			&npf->ip4_drop_options,
-			.default_val = 0, // false
-			.min = 0, .max = 1
-		},
-		{
-			"ip6.reassembly",
-			&npf->ip6_reassembly,
-			.default_val = 0, // false
-			.min = 0, .max = 1
-		},
-		{
-			"ip6.drop_options",
-			&npf->ip6_drop_options,
-			.default_val = 0, // false
-			.min = 0, .max = 1
-		},
-	};
-	npf_param_register(npf, param_map, __arraycount(param_map));
-}
-
-void
-npf_param_init(npf_t *npf)
-{
-	npf_paraminfo_t *paraminfo;
-
-	paraminfo = kmem_zalloc(sizeof(npf_paraminfo_t), KM_SLEEP);
-	paraminfo->map = thmap_create(0, NULL, THMAP_NOCOPY);
-	npf->paraminfo = paraminfo;
-
-	/* Register some general parameters. */
-	npf_param_general_register(npf);
-}
-
-void
-npf_param_fini(npf_t *npf)
-{
-	npf_paraminfo_t *pinfo = npf->paraminfo;
-	npf_paramreg_t *paramreg = pinfo->list;
-
-	while (paramreg) {
-		npf_param_t *plist = paramreg->params;
-		npf_paramreg_t *next = paramreg->next;
-		size_t len;
-
-		/* Remove the parameters from the map. */
-		for (unsigned i = 0; i < paramreg->count; i++) {
-			npf_param_t *param = &plist[i];
-			const char *name = param->name;
-			void *ret __diagused;
-
-			ret = thmap_del(pinfo->map, name, strlen(name));
-			KASSERT(ret != NULL);
-		}
-
-		/* Destroy this registry. */
-		len = offsetof(npf_paramreg_t, params[paramreg->count]);
-		kmem_free(paramreg, len);
-
-		/* Next .. */
-		paramreg = next;
-	}
-	thmap_destroy(pinfo->map);
-	kmem_free(pinfo, sizeof(npf_paraminfo_t));
-}
-
-int
-npf_params_export(const npf_t *npf, nvlist_t *nv)
-{
-	nvlist_t *params, *dparams;
-
-	/*
-	 * Export both the active and default values.  The latter are to
-	 * accommodate npfctl so it could distinguish what has been set.
-	 */
-	params = nvlist_create(0);
-	dparams = nvlist_create(0);
-	for (npf_paramreg_t *pr = npf->paraminfo->list; pr; pr = pr->next) {
-		for (unsigned i = 0; i < pr->count; i++) {
-			const npf_param_t *param = &pr->params[i];
-			const uint64_t val = *param->valp;
-			const uint64_t defval = param->default_val;
-
-			nvlist_add_number(params, param->name, val);
-			nvlist_add_number(dparams, param->name, defval);
-		}
-	}
-	nvlist_add_nvlist(nv, "params", params);
-	nvlist_add_nvlist(nv, "params-defaults", dparams);
-	return 0;
-}
-
-void *
-npf_param_allocgroup(npf_t *npf, npf_paramgroup_t group, size_t len)
-{
-	void *params = kmem_zalloc(len, KM_SLEEP);
-	npf->params[group] = params;
-	return params;
-}
-
-void
-npf_param_freegroup(npf_t *npf, npf_paramgroup_t group, size_t len)
-{
-	kmem_free(npf->params[group], len);
-	npf->params[group] = NULL; // diagnostic
-}
-
-/*
- * npf_param_register: register an array of named parameters.
- */
-void
-npf_param_register(npf_t *npf, npf_param_t *params, unsigned count)
-{
-	npf_paraminfo_t *pinfo = npf->paraminfo;
-	npf_paramreg_t *paramreg;
-	size_t len;
-
-	/*
-	 * Copy over the parameters.
-	 */
-	len = offsetof(npf_paramreg_t, params[count]);
-	paramreg = kmem_zalloc(len, KM_SLEEP);
-	memcpy(paramreg->params, params, sizeof(npf_param_t) * count);
-	paramreg->count = count;
-	params = NULL; // dead
-
-	/*
-	 * Map the parameter names to the variables.
-	 * Assign the default values.
-	 */
-	for (unsigned i = 0; i < count; i++) {
-		npf_param_t *param = &paramreg->params[i];
-		const char *name = param->name;
-		void *ret __diagused;
-
-		ret = thmap_put(pinfo->map, name, strlen(name), param);
-		KASSERT(ret == param);
-
-		/* Assign the default value. */
-		KASSERT(param->default_val >= param->min);
-		KASSERT(param->default_val <= param->max);
-		*param->valp = param->default_val;
-	}
-
-	/* Insert the registry of params into the list. */
-	paramreg->next = pinfo->list;
-	pinfo->list = paramreg;
-}
-
-/*
- * NPF param API.
- */
-
-static npf_param_t *
-npf_param_lookup(npf_t *npf, const char *name)
-{
-	npf_paraminfo_t *pinfo = npf->paraminfo;
-	const size_t namelen = strlen(name);
-	return thmap_get(pinfo->map, name, namelen);
-}
-
-int
-npf_param_check(npf_t *npf, const char *name, int val)
-{
-	npf_param_t *param;
-
-	if ((param = npf_param_lookup(npf, name)) == NULL) {
-		return ENOENT;
-	}
-	if (val < param->min || val > param->max) {
-		return EINVAL;
-	}
-	return 0;
-}
-
-__dso_public int
-npfk_param_get(npf_t *npf, const char *name, int *val)
-{
-	npf_param_t *param;
-
-	if ((param = npf_param_lookup(npf, name)) == NULL) {
-		return ENOENT;
-	}
-	*val = *param->valp;
-	return 0;
-}
-
-__dso_public int
-npfk_param_set(npf_t *npf, const char *name, int val)
-{
-	npf_param_t *param;
-
-	if ((param = npf_param_lookup(npf, name)) == NULL) {
-		return ENOENT;
-	}
-	if (val < param->min || val > param->max) {
-		return EINVAL;
-	}
-	*param->valp = val;
-	return 0;
-}
diff --git a/src/kern/npf_portmap.c b/src/kern/npf_portmap.c
deleted file mode 100644
index b95b1e4..0000000
--- a/src/kern/npf_portmap.c
+++ /dev/null
@@ -1,542 +0,0 @@
-/*-
- * Copyright (c) 2019 Mindaugas Rasiukevicius <rmind at noxt eu>
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-/*
- * NPF port map mechanism.
- *
- *	The port map is a bitmap used to track TCP/UDP ports used for
- *	translation.  Port maps are per IP addresses, therefore multiple
- *	NAT policies operating on the same IP address will share the
- *	same port map.
- */
-
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD$");
-
-#include <sys/param.h>
-#include <sys/types.h>
-
-#include <sys/atomic.h>
-#include <sys/bitops.h>
-#include <sys/kmem.h>
-#include <sys/mutex.h>
-#include <sys/cprng.h>
-#include <sys/thmap.h>
-#endif
-
-#include "npf_impl.h"
-
-/*
- * Port map uses two-level bitmaps with compression to efficiently
- * represent the maximum of 65536 (2^16) values.
- *
- * Level 0: 64 chunks each representing 1048 bits in two modes:
- *
- *	a) If PORTMAP_L1_TAG, then up to 5 values are packed in the
- *	64-bit integer using 12 bits for each value, starting from the
- *	most significant bits.  The four 4 least significant bits are
- *	unused or reserved for pointer tagging.
- *
- *	b) If there are more than 5 values, then PORTMAP_L1_TAG is set
- *	and the value serves as a pointer to the second level bitmap.
- *
- * Level 1: 16 chunks each representing 64 bits in plain uint64_t.
- */
-
-#define	PORTMAP_MAX_BITS	(65536U)
-#define	PORTMAP_MASK		(PORTMAP_MAX_BITS - 1)
-
-#define	PORTMAP_L0_SHIFT	(10) // or 11
-#define	PORTMAP_L0_MASK		((1U << PORTMAP_L0_SHIFT) - 1)
-#define	PORTMAP_L0_WORDS	(PORTMAP_MAX_BITS >> PORTMAP_L0_SHIFT)
-
-#define	PORTMAP_L1_SHIFT	(6)
-#define	PORTMAP_L1_MASK		((1U << PORTMAP_L1_SHIFT) - 1)
-#define	PORTMAP_L1_WORDS	\
-    ((PORTMAP_MAX_BITS / PORTMAP_L0_WORDS) >> PORTMAP_L1_SHIFT)
-
-#define	PORTMAP_L1_TAG		(UINT64_C(1)) // use level 1
-#define	PORTMAP_L1_GET(p)	((void *)((uintptr_t)(p) & ~(uintptr_t)3))
-
-CTASSERT(sizeof(uint64_t) >= sizeof(uintptr_t));
-
-typedef struct {
-	volatile uint64_t	bits1[PORTMAP_L1_WORDS];
-} bitmap_l1_t;
-
-typedef struct bitmap {
-	npf_addr_t		addr;
-	volatile uint64_t	bits0[PORTMAP_L0_WORDS];
-	LIST_ENTRY(bitmap)	entry;
-	unsigned		addr_len;
-} bitmap_t;
-
-#define	NPF_PORTMAP_MINPORT	1024
-#define	NPF_PORTMAP_MAXPORT	65535
-
-struct npf_portmap {
-	thmap_t	*		addr_map;
-	LIST_HEAD(, bitmap)	bitmap_list;
-	kmutex_t		list_lock;
-	int			min_port;
-	int			max_port;
-};
-
-void
-npf_portmap_init(npf_t *npf)
-{
-	npf_portmap_t *pm = npf_portmap_create(
-	    NPF_PORTMAP_MINPORT, NPF_PORTMAP_MAXPORT);
-	npf_param_t param_map[] = {
-		{
-			"portmap.min_port",
-			&pm->min_port,
-			.default_val = NPF_PORTMAP_MINPORT,
-			.min = 1024, .max = 65535
-		},
-		{
-			"portmap.max_port",
-			&pm->max_port,
-			.default_val = 49151, // RFC 6335
-			.min = 1024, .max = 65535
-		}
-	};
-	npf_param_register(npf, param_map, __arraycount(param_map));
-	npf->portmap = pm;
-}
-
-void
-npf_portmap_fini(npf_t *npf)
-{
-	npf_portmap_destroy(npf->portmap);
-	npf->portmap = NULL; // diagnostic
-}
-
-npf_portmap_t *
-npf_portmap_create(int min_port, int max_port)
-{
-	npf_portmap_t *pm;
-
-	pm = kmem_zalloc(sizeof(npf_portmap_t), KM_SLEEP);
-	mutex_init(&pm->list_lock, MUTEX_DEFAULT, IPL_SOFTNET);
-	pm->addr_map = thmap_create(0, NULL, THMAP_NOCOPY);
-	pm->min_port = min_port;
-	pm->max_port = max_port;
-	return pm;
-}
-
-void
-npf_portmap_destroy(npf_portmap_t *pm)
-{
-	npf_portmap_flush(pm);
-	KASSERT(LIST_EMPTY(&pm->bitmap_list));
-
-	thmap_destroy(pm->addr_map);
-	mutex_destroy(&pm->list_lock);
-	kmem_free(pm, sizeof(npf_portmap_t));
-}
-
-/////////////////////////////////////////////////////////////////////////
-
-/*
- * bitmap_word_isset: test whether the bit value is in the packed array.
- *
- * => Return true if any value equals the bit number value.
- *
- * Packed array: 60 MSB bits, 5 values, 12 bits each.
- *
- * Reference: "Bit Twiddling Hacks" by S.E. Anderson, Stanford.
- * Based on the hasvalue() and haszero() ideas.  Since values are
- * represented by upper 60 bits, we shift right by 4.
- */
-static bool
-bitmap_word_isset(uint64_t x, unsigned bit)
-{
-	uint64_t m, r;
-
-	bit++;
-	KASSERT((x & PORTMAP_L1_TAG) == 0);
-	KASSERT(bit <= (PORTMAP_L0_MASK + 1));
-
-	m = (x >> 4) ^ (UINT64_C(0x1001001001001) * bit);
-	r = (m - UINT64_C(0x1001001001001)) & (~m & UINT64_C(0x800800800800800));
-	return r != 0;
-}
-
-/*
- * bitmap_word_cax: compare-and-xor on packed array elements.
- */
-static uint64_t
-bitmap_word_cax(uint64_t x, int exp, int bit)
-{
-	unsigned e = exp + 1;
-
-	/*
-	 * We need to distinguish "no value" from zero.  Just add one,
-	 * since we use 12 bits to represent 11 bit values.
-	 */
-	bit++;
-	KASSERT((unsigned)bit <= (PORTMAP_L0_MASK + 1));
-	KASSERT((x & PORTMAP_L1_TAG) == 0);
-
-	if (((x >> 52) & 0xfff) == e)
-		return x ^ ((uint64_t)bit << 52);
-	if (((x >> 40) & 0xfff) == e)
-		return x ^ ((uint64_t)bit << 40);
-	if (((x >> 28) & 0xfff) == e)
-		return x ^ ((uint64_t)bit << 28);
-	if (((x >> 16) & 0xfff) == e)
-		return x ^ ((uint64_t)bit << 16);
-	if (((x >>  4) & 0xfff) == e)
-		return x ^ ((uint64_t)bit << 4);
-	return 0;
-}
-
-static unsigned
-bitmap_word_unpack(uint64_t x, unsigned bitvals[static 5])
-{
-	unsigned n = 0;
-	uint64_t v;
-
-	KASSERT((x & PORTMAP_L1_TAG) == 0);
-
-	if ((v = ((x >> 52)) & 0xfff) != 0)
-		bitvals[n++] = v - 1;
-	if ((v = ((x >> 40)) & 0xfff) != 0)
-		bitvals[n++] = v - 1;
-	if ((v = ((x >> 28)) & 0xfff) != 0)
-		bitvals[n++] = v - 1;
-	if ((v = ((x >> 16)) & 0xfff) != 0)
-		bitvals[n++] = v - 1;
-	if ((v = ((x >>  4)) & 0xfff) != 0)
-		bitvals[n++] = v - 1;
-	return n;
-}
-
-#if 0
-static bool
-bitmap_isset(const bitmap_t *bm, unsigned bit)
-{
-	unsigned i, chunk_bit;
-	uint64_t bval, b;
-	bitmap_l1_t *bm1;
-
-	KASSERT(bit < PORTMAP_MAX_BITS);
-	i = bit >> PORTMAP_L0_SHIFT;
-	bval = atomic_load_relaxed(&bm->bits0[i]);
-
-	/*
-	 * Empty check.  Note: we can test the whole word against zero,
-	 * since zero bit values in the packed array result in bits set.
-	 */
-	if (bval == 0)
-		return false;
-
-	/* Level 0 check. */
-	chunk_bit = bit & PORTMAP_L0_MASK;
-	if ((bval & PORTMAP_L1_TAG) == 0)
-		return bitmap_word_isset(bval, chunk_bit);
-
-	/* Level 1 check. */
-	bm1 = PORTMAP_L1_GET(bval);
-	KASSERT(bm1 != NULL);
-	i = chunk_bit >> PORTMAP_L1_SHIFT;
-	b = UINT64_C(1) << (chunk_bit & PORTMAP_L1_MASK);
-	return (bm1->bits1[i] & b) != 0;
-}
-#endif
-
-static bool
-bitmap_set(bitmap_t *bm, unsigned bit)
-{
-	unsigned i, chunk_bit;
-	uint64_t bval, b, oval, nval;
-	bitmap_l1_t *bm1;
-again:
-	KASSERT(bit < PORTMAP_MAX_BITS);
-	i = bit >> PORTMAP_L0_SHIFT;
-	chunk_bit = bit & PORTMAP_L0_MASK;
-	bval = atomic_load_relaxed(&bm->bits0[i]);
-
-	if ((bval & PORTMAP_L1_TAG) == 0) {
-		unsigned n = 0, bitvals[5];
-		uint64_t bm1p;
-
-		if (bitmap_word_isset(bval, chunk_bit)) {
-			return false;
-		}
-
-		/*
-		 * Look for a zero-slot and put a value there.
-		 */
-		if ((nval = bitmap_word_cax(bval, -1, chunk_bit)) != 0) {
-			KASSERT((nval & PORTMAP_L1_TAG) == 0);
-			if (atomic_cas_64(&bm->bits0[i], bval, nval) != bval) {
-				goto again;
-			}
-			return true;
-		}
-
-		/*
-		 * Full: allocate L1 block and copy over the current
-		 * values into the level.
-		 */
-		bm1 = kmem_intr_zalloc(sizeof(bitmap_l1_t), KM_NOSLEEP);
-		if (bm1 == NULL) {
-			return false; // error
-		}
-		n = bitmap_word_unpack(bval, bitvals);
-		while (n--) {
-			const unsigned v = bitvals[n];
-			const unsigned off = v >> PORTMAP_L1_SHIFT;
-
-			KASSERT(v <= PORTMAP_L0_MASK);
-			KASSERT(off < (sizeof(uint64_t) * CHAR_BIT));
-			bm1->bits1[off] |= UINT64_C(1) << (v & PORTMAP_L1_MASK);
-		}
-
-		/*
-		 * Attempt to set the L1 structure.  Note: there is no
-		 * ABA problem since the we compare the actual values.
-		 * Note: CAS serves as a memory barrier.
-		 */
-		bm1p = (uintptr_t)bm1;
-		KASSERT((bm1p & PORTMAP_L1_TAG) == 0);
-		bm1p |= PORTMAP_L1_TAG;
-		if (atomic_cas_64(&bm->bits0[i], bval, bm1p) != bval) {
-			kmem_intr_free(bm1, sizeof(bitmap_l1_t));
-			goto again;
-		}
-		bval = bm1p;
-	}
-
-	bm1 = PORTMAP_L1_GET(bval);
-	KASSERT(bm1 != NULL);
-	i = chunk_bit >> PORTMAP_L1_SHIFT;
-	b = UINT64_C(1) << (chunk_bit & PORTMAP_L1_MASK);
-
-	oval = atomic_load_relaxed(&bm1->bits1[i]);
-	if (oval & b) {
-		return false;
-	}
-	nval = oval | b;
-	if (atomic_cas_64(&bm1->bits1[i], oval, nval) != oval) {
-		goto again;
-	}
-	return true;
-}
-
-static bool
-bitmap_clr(bitmap_t *bm, unsigned bit)
-{
-	unsigned i, chunk_bit;
-	uint64_t bval, b, oval, nval;
-	bitmap_l1_t *bm1;
-again:
-	KASSERT(bit < PORTMAP_MAX_BITS);
-	i = bit >> PORTMAP_L0_SHIFT;
-	chunk_bit = bit & PORTMAP_L0_MASK;
-	bval = bm->bits0[i];
-
-	if ((bval & PORTMAP_L1_TAG) == 0) {
-		if (!bitmap_word_isset(bval, chunk_bit)) {
-			return false;
-		}
-		nval = bitmap_word_cax(bval, chunk_bit, chunk_bit);
-		KASSERT((nval & PORTMAP_L1_TAG) == 0);
-		if (atomic_cas_64(&bm->bits0[i], bval, nval) != bval) {
-			goto again;
-		}
-		return true;
-	}
-
-	bm1 = PORTMAP_L1_GET(bval);
-	KASSERT(bm1 != NULL);
-	i = chunk_bit >> PORTMAP_L1_SHIFT;
-	b = UINT64_C(1) << (chunk_bit & PORTMAP_L1_MASK);
-
-	oval = atomic_load_relaxed(&bm1->bits1[i]);
-	if ((oval & b) == 0) {
-		return false;
-	}
-	nval = oval & ~b;
-	if (atomic_cas_64(&bm1->bits1[i], oval, nval) != oval) {
-		goto again;
-	}
-	return true;
-}
-
-/////////////////////////////////////////////////////////////////////////
-
-static bitmap_t *
-npf_portmap_autoget(npf_portmap_t *pm, unsigned alen, const npf_addr_t *addr)
-{
-	bitmap_t *bm;
-
-	KASSERT(pm && pm->addr_map);
-	KASSERT(alen && alen <= sizeof(npf_addr_t));
-
-	/* Lookup the port map for this address. */
-	bm = thmap_get(pm->addr_map, addr, alen);
-	if (bm == NULL) {
-		void *ret;
-
-		/*
-		 * Allocate a new port map for this address and
-		 * attempt to insert it.
-		 */
-		bm = kmem_intr_zalloc(sizeof(bitmap_t), KM_NOSLEEP);
-		if (bm == NULL) {
-			return NULL;
-		}
-		memcpy(&bm->addr, addr, alen);
-		bm->addr_len = alen;
-
-		int s = splsoftnet();
-		ret = thmap_put(pm->addr_map, &bm->addr, alen, bm);
-		splx(s);
-
-		if (ret == bm) {
-			/* Success: insert the bitmap into the list. */
-			mutex_enter(&pm->list_lock);
-			LIST_INSERT_HEAD(&pm->bitmap_list, bm, entry);
-			mutex_exit(&pm->list_lock);
-		} else {
-			/* Race: use an existing bitmap. */
-			kmem_free(bm, sizeof(bitmap_t));
-			bm = ret;
-		}
-	}
-	return bm;
-}
-
-/*
- * npf_portmap_flush: free all bitmaps and remove all addresses.
- *
- * => Concurrent calls to this routine are not allowed; therefore no
- * need to acquire locks.
- */
-void
-npf_portmap_flush(npf_portmap_t *pm)
-{
-	bitmap_t *bm;
-
-	while ((bm = LIST_FIRST(&pm->bitmap_list)) != NULL) {
-		for (unsigned i = 0; i < PORTMAP_L0_WORDS; i++) {
-			uintptr_t bm1 = bm->bits0[i];
-
-			if (bm1 & PORTMAP_L1_TAG) {
-				bitmap_l1_t *bm1p = PORTMAP_L1_GET(bm1);
-				kmem_intr_free(bm1p, sizeof(bitmap_l1_t));
-			}
-			bm->bits0[i] = UINT64_C(0);
-		}
-		LIST_REMOVE(bm, entry);
-		thmap_del(pm->addr_map, &bm->addr, bm->addr_len);
-		kmem_intr_free(bm, sizeof(bitmap_t));
-	}
-	/* Note: the caller ensures there are no active references. */
-	thmap_gc(pm->addr_map, thmap_stage_gc(pm->addr_map));
-}
-
-/*
- * npf_portmap_get: allocate and return a port from the given portmap.
- *
- * => Returns the port value in network byte-order.
- * => Zero indicates a failure.
- */
-in_port_t
-npf_portmap_get(npf_portmap_t *pm, int alen, const npf_addr_t *addr)
-{
-	const unsigned min_port = atomic_load_relaxed(&pm->min_port);
-	const unsigned max_port = atomic_load_relaxed(&pm->max_port);
-	const unsigned port_delta = max_port - min_port + 1;
-	unsigned bit, target;
-	bitmap_t *bm;
-
-	/* Sanity check: the user might set incorrect parameters. */
-	if (__predict_false(min_port > max_port)) {
-		return 0;
-	}
-
-	bm = npf_portmap_autoget(pm, alen, addr);
-	if (__predict_false(bm == NULL)) {
-		/* No memory. */
-		return 0;
-	}
-
-	/* Randomly select a port. */
-	target = min_port + (cprng_fast32() % port_delta);
-	bit = target;
-next:
-	if (bitmap_set(bm, bit)) {
-		/* Success. */
-		return htons(bit);
-	}
-	bit = min_port + ((bit + 1) % port_delta);
-	if (target != bit) {
-		/* Next.. */
-		goto next;
-	}
-	/* No space. */
-	return 0;
-}
-
-/*
- * npf_portmap_take: allocate a specific port in the portmap.
- */
-bool
-npf_portmap_take(npf_portmap_t *pm, int alen,
-    const npf_addr_t *addr, in_port_t port)
-{
-	bitmap_t *bm = npf_portmap_autoget(pm, alen, addr);
-
-	port = ntohs(port);
-	if (!bm || port < pm->min_port || port > pm->max_port) {
-		/* Out of memory / invalid port. */
-		return false;
-	}
-	return bitmap_set(bm, port);
-}
-
-/*
- * npf_portmap_put: release the port, making it available in the portmap.
- *
- * => The port value should be in network byte-order.
- */
-void
-npf_portmap_put(npf_portmap_t *pm, int alen,
-    const npf_addr_t *addr, in_port_t port)
-{
-	bitmap_t *bm;
-
-	bm = npf_portmap_autoget(pm, alen, addr);
-	if (bm) {
-		port = ntohs(port);
-		bitmap_clr(bm, port);
-	}
-}
diff --git a/src/kern/npf_rproc.c b/src/kern/npf_rproc.c
deleted file mode 100644
index e18a226..0000000
--- a/src/kern/npf_rproc.c
+++ /dev/null
@@ -1,387 +0,0 @@
-/*-
- * Copyright (c) 2009-2013 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * This material is based upon work partially supported by The
- * NetBSD Foundation under a contract with Mindaugas Rasiukevicius.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
- * NPF extension and rule procedure interface.
- */
-
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD$");
-
-#include <sys/param.h>
-#include <sys/types.h>
-
-#include <sys/atomic.h>
-#include <sys/kmem.h>
-#include <sys/mutex.h>
-#include <sys/module.h>
-#endif
-
-#include "npf_impl.h"
-
-#define	EXT_NAME_LEN		32
-
-typedef struct npf_ext {
-	char			ext_callname[EXT_NAME_LEN];
-	LIST_ENTRY(npf_ext)	ext_entry;
-	const npf_ext_ops_t *	ext_ops;
-	unsigned		ext_refcnt;
-} npf_ext_t;
-
-struct npf_rprocset {
-	LIST_HEAD(, npf_rproc)	rps_list;
-};
-
-#define	RPROC_NAME_LEN		32
-#define	RPROC_EXT_COUNT		16
-
-struct npf_rproc {
-	/* Flags and reference count. */
-	uint32_t		rp_flags;
-	unsigned		rp_refcnt;
-
-	/* Associated extensions and their metadata . */
-	unsigned		rp_ext_count;
-	npf_ext_t *		rp_ext[RPROC_EXT_COUNT];
-	void *			rp_ext_meta[RPROC_EXT_COUNT];
-
-	/* Name of the procedure and list entry. */
-	char			rp_name[RPROC_NAME_LEN];
-	LIST_ENTRY(npf_rproc)	rp_entry;
-};
-
-void
-npf_ext_init(npf_t *npf)
-{
-	mutex_init(&npf->ext_lock, MUTEX_DEFAULT, IPL_NONE);
-	LIST_INIT(&npf->ext_list);
-}
-
-void
-npf_ext_fini(npf_t *npf)
-{
-	KASSERT(LIST_EMPTY(&npf->ext_list));
-	mutex_destroy(&npf->ext_lock);
-}
-
-/*
- * NPF extension management for the rule procedures.
- */
-
-static const char npf_ext_prefix[] = "npf_ext_";
-#define NPF_EXT_PREFLEN (sizeof(npf_ext_prefix) - 1)
-
-static npf_ext_t *
-npf_ext_lookup(npf_t *npf, const char *name, bool autoload)
-{
-	npf_ext_t *ext;
-	char modname[RPROC_NAME_LEN + NPF_EXT_PREFLEN];
-	int error;
-
-	KASSERT(mutex_owned(&npf->ext_lock));
-
-again:
-	LIST_FOREACH(ext, &npf->ext_list, ext_entry)
-		if (strcmp(ext->ext_callname, name) == 0)
-			break;
-
-	if (ext != NULL || !autoload)
-		return ext;
-
-	mutex_exit(&npf->ext_lock);
-	autoload = false;
-	snprintf(modname, sizeof(modname), "%s%s", npf_ext_prefix, name);
-	error = module_autoload(modname, MODULE_CLASS_MISC);
-	mutex_enter(&npf->ext_lock);
-
-	if (error)
-		return NULL;
-	goto again;
-}
-
-void *
-npf_ext_register(npf_t *npf, const char *name, const npf_ext_ops_t *ops)
-{
-	npf_ext_t *ext;
-
-	ext = kmem_zalloc(sizeof(npf_ext_t), KM_SLEEP);
-	strlcpy(ext->ext_callname, name, EXT_NAME_LEN);
-	ext->ext_ops = ops;
-
-	mutex_enter(&npf->ext_lock);
-	if (npf_ext_lookup(npf, name, false)) {
-		mutex_exit(&npf->ext_lock);
-		kmem_free(ext, sizeof(npf_ext_t));
-		return NULL;
-	}
-	LIST_INSERT_HEAD(&npf->ext_list, ext, ext_entry);
-	mutex_exit(&npf->ext_lock);
-
-	return (void *)ext;
-}
-
-int
-npf_ext_unregister(npf_t *npf, void *extid)
-{
-	npf_ext_t *ext = extid;
-
-	/*
-	 * Check if in-use first (re-check with the lock held).
-	 */
-	if (atomic_load_relaxed(&ext->ext_refcnt)) {
-		return EBUSY;
-	}
-
-	mutex_enter(&npf->ext_lock);
-	if (atomic_load_relaxed(&ext->ext_refcnt)) {
-		mutex_exit(&npf->ext_lock);
-		return EBUSY;
-	}
-	KASSERT(npf_ext_lookup(npf, ext->ext_callname, false));
-	LIST_REMOVE(ext, ext_entry);
-	mutex_exit(&npf->ext_lock);
-
-	kmem_free(ext, sizeof(npf_ext_t));
-	return 0;
-}
-
-int
-npf_ext_construct(npf_t *npf, const char *name,
-    npf_rproc_t *rp, const nvlist_t *params)
-{
-	const npf_ext_ops_t *extops;
-	npf_ext_t *ext;
-	unsigned i;
-	int error;
-
-	if (rp->rp_ext_count >= RPROC_EXT_COUNT) {
-		return ENOSPC;
-	}
-
-	mutex_enter(&npf->ext_lock);
-	ext = npf_ext_lookup(npf, name, true);
-	if (ext) {
-		atomic_inc_uint(&ext->ext_refcnt);
-	}
-	mutex_exit(&npf->ext_lock);
-
-	if (!ext) {
-		return ENOENT;
-	}
-
-	extops = ext->ext_ops;
-	KASSERT(extops != NULL);
-
-	error = extops->ctor(rp, params);
-	if (error) {
-		atomic_dec_uint(&ext->ext_refcnt);
-		return error;
-	}
-	i = rp->rp_ext_count++;
-	rp->rp_ext[i] = ext;
-	return 0;
-}
-
-/*
- * Rule procedure management.
- */
-
-npf_rprocset_t *
-npf_rprocset_create(void)
-{
-	npf_rprocset_t *rpset;
-
-	rpset = kmem_zalloc(sizeof(npf_rprocset_t), KM_SLEEP);
-	LIST_INIT(&rpset->rps_list);
-	return rpset;
-}
-
-void
-npf_rprocset_destroy(npf_rprocset_t *rpset)
-{
-	npf_rproc_t *rp;
-
-	while ((rp = LIST_FIRST(&rpset->rps_list)) != NULL) {
-		LIST_REMOVE(rp, rp_entry);
-		npf_rproc_release(rp);
-	}
-	kmem_free(rpset, sizeof(npf_rprocset_t));
-}
-
-/*
- * npf_rproc_lookup: find a rule procedure by the name.
- */
-npf_rproc_t *
-npf_rprocset_lookup(npf_rprocset_t *rpset, const char *name)
-{
-	npf_rproc_t *rp;
-
-	LIST_FOREACH(rp, &rpset->rps_list, rp_entry) {
-		if (strncmp(rp->rp_name, name, RPROC_NAME_LEN) == 0)
-			break;
-	}
-	return rp;
-}
-
-/*
- * npf_rproc_insert: insert a new rule procedure into the set.
- */
-void
-npf_rprocset_insert(npf_rprocset_t *rpset, npf_rproc_t *rp)
-{
-	LIST_INSERT_HEAD(&rpset->rps_list, rp, rp_entry);
-}
-
-int
-npf_rprocset_export(const npf_rprocset_t *rpset, nvlist_t *nvl)
-{
-	const npf_rproc_t *rp;
-
-	LIST_FOREACH(rp, &rpset->rps_list, rp_entry) {
-		nvlist_t *rproc = nvlist_create(0);
-#if 0 // FIXME/TODO
-		for (unsigned i = 0; i < rp->rp_ext_count; i++) {
-			nvlist_t *meta = rp->rp_ext_meta[i];
-			...
-			nvlist_append_nvlist_array(rproc, "extcalls", meta);
-		}
-#endif
-		nvlist_add_string(rproc, "name", rp->rp_name);
-		nvlist_add_number(rproc, "flags", rp->rp_flags);
-		nvlist_append_nvlist_array(nvl, "rprocs", rproc);
-		nvlist_destroy(rproc);
-	}
-	return 0;
-}
-
-/*
- * npf_rproc_create: construct a new rule procedure, lookup and associate
- * the extension calls with it.
- */
-npf_rproc_t *
-npf_rproc_create(const nvlist_t *rproc)
-{
-	const char *name;
-	npf_rproc_t *rp;
-
-	if ((name = dnvlist_get_string(rproc, "name", NULL)) == NULL) {
-		return NULL;
-	}
-
-	rp = kmem_intr_zalloc(sizeof(npf_rproc_t), KM_SLEEP);
-	rp->rp_refcnt = 1;
-
-	strlcpy(rp->rp_name, name, RPROC_NAME_LEN);
-	rp->rp_flags = dnvlist_get_number(rproc, "flags", 0);
-	return rp;
-}
-
-/*
- * npf_rproc_acquire: acquire the reference on the rule procedure.
- */
-void
-npf_rproc_acquire(npf_rproc_t *rp)
-{
-	atomic_inc_uint(&rp->rp_refcnt);
-}
-
-/*
- * npf_rproc_getname: return the name of the given rproc
- */
-const char *
-npf_rproc_getname(const npf_rproc_t *rp)
-{
-	return rp->rp_name;
-}
-
-/*
- * npf_rproc_release: drop the reference count and destroy the rule
- * procedure on the last reference.
- */
-void
-npf_rproc_release(npf_rproc_t *rp)
-{
-	KASSERT(atomic_load_relaxed(&rp->rp_refcnt) > 0);
-
-	if (atomic_dec_uint_nv(&rp->rp_refcnt) != 0) {
-		return;
-	}
-	/* XXXintr */
-	for (unsigned i = 0; i < rp->rp_ext_count; i++) {
-		npf_ext_t *ext = rp->rp_ext[i];
-		const npf_ext_ops_t *extops = ext->ext_ops;
-
-		extops->dtor(rp, rp->rp_ext_meta[i]);
-		atomic_dec_uint(&ext->ext_refcnt);
-	}
-	kmem_intr_free(rp, sizeof(npf_rproc_t));
-}
-
-void
-npf_rproc_assign(npf_rproc_t *rp, void *params)
-{
-	unsigned i = rp->rp_ext_count;
-
-	/* Note: params may be NULL. */
-	KASSERT(i < RPROC_EXT_COUNT);
-	rp->rp_ext_meta[i] = params;
-}
-
-/*
- * npf_rproc_run: run the rule procedure by executing each extension call.
- *
- * => Reference on the rule procedure must be held.
- */
-bool
-npf_rproc_run(npf_cache_t *npc, npf_rproc_t *rp, const npf_match_info_t *mi,
-    int *decision)
-{
-	const unsigned extcount = rp->rp_ext_count;
-
-	KASSERT(!nbuf_flag_p(npc->npc_nbuf, NBUF_DATAREF_RESET));
-	KASSERT(atomic_load_relaxed(&rp->rp_refcnt) > 0);
-
-	for (unsigned i = 0; i < extcount; i++) {
-		const npf_ext_t *ext = rp->rp_ext[i];
-		const npf_ext_ops_t *extops = ext->ext_ops;
-
-		KASSERT(atomic_load_relaxed(&ext->ext_refcnt) > 0);
-
-		if (!extops->proc(npc, rp->rp_ext_meta[i], mi, decision)) {
-			return false;
-		}
-
-		if (nbuf_flag_p(npc->npc_nbuf, NBUF_DATAREF_RESET)) {
-			npf_recache(npc);
-		}
-	}
-
-	return true;
-}
diff --git a/src/kern/npf_ruleset.c b/src/kern/npf_ruleset.c
deleted file mode 100644
index 131db97..0000000
--- a/src/kern/npf_ruleset.c
+++ /dev/null
@@ -1,966 +0,0 @@
-/*-
- * Copyright (c) 2020 Mindaugas Rasiukevicius <rmind at noxt eu>
- * Copyright (c) 2009-2015 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * This material is based upon work partially supported by The
- * NetBSD Foundation under a contract with Mindaugas Rasiukevicius.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
- * NPF ruleset module.
- */
-
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD$");
-
-#include <sys/param.h>
-#include <sys/types.h>
-
-#include <sys/atomic.h>
-#include <sys/kmem.h>
-#include <sys/queue.h>
-#include <sys/mbuf.h>
-#include <sys/types.h>
-
-#include <net/bpf.h>
-#include <net/bpfjit.h>
-#include <net/pfil.h>
-#include <net/if.h>
-#endif
-
-#include "npf_impl.h"
-
-struct npf_ruleset {
-	/*
-	 * - List of all rules.
-	 * - Dynamic (i.e. named) rules.
-	 * - G/C list for convenience.
-	 */
-	LIST_HEAD(, npf_rule)	rs_all;
-	LIST_HEAD(, npf_rule)	rs_dynamic;
-	LIST_HEAD(, npf_rule)	rs_gc;
-
-	/* Unique ID counter. */
-	uint64_t		rs_idcnt;
-
-	/* Number of array slots and active rules. */
-	unsigned		rs_slots;
-	unsigned		rs_nitems;
-
-	/* Array of ordered rules. */
-	npf_rule_t *		rs_rules[];
-};
-
-struct npf_rule {
-	/* Attributes, interface and skip slot. */
-	uint32_t		r_attr;
-	unsigned		r_ifid;
-	unsigned		r_skip_to;
-
-	/* Code to process, if any. */
-	int			r_type;
-	bpfjit_func_t		r_jcode;
-	void *			r_code;
-	unsigned		r_clen;
-
-	/* NAT policy (optional), rule procedure and subset. */
-	npf_natpolicy_t *	r_natp;
-	npf_rproc_t *		r_rproc;
-
-	union {
-		/*
-		 * Dynamic group: rule subset and a group list entry.
-		 */
-		struct {
-			npf_rule_t *		r_subset;
-			LIST_ENTRY(npf_rule)	r_dentry;
-		};
-
-		/*
-		 * Dynamic rule: priority, parent group and next rule.
-		 */
-		struct {
-			int			r_priority;
-			npf_rule_t *		r_parent;
-			npf_rule_t *		r_next;
-		};
-	};
-
-	/* Rule ID, name and the optional key. */
-	uint64_t		r_id;
-	char			r_name[NPF_RULE_MAXNAMELEN];
-	uint8_t			r_key[NPF_RULE_MAXKEYLEN];
-
-	/* All-list entry and the auxiliary info. */
-	LIST_ENTRY(npf_rule)	r_aentry;
-	nvlist_t *		r_info;
-	size_t			r_info_len;
-};
-
-#define	SKIPTO_ADJ_FLAG		(1U << 31)
-#define	SKIPTO_MASK		(SKIPTO_ADJ_FLAG - 1)
-
-static nvlist_t *	npf_rule_export(npf_t *, const npf_rule_t *);
-
-/*
- * Private attributes - must be in the NPF_RULE_PRIVMASK range.
- */
-#define	NPF_RULE_KEEPNAT	(0x01000000 & NPF_RULE_PRIVMASK)
-
-#define	NPF_DYNAMIC_GROUP_P(attr) \
-    (((attr) & NPF_DYNAMIC_GROUP) == NPF_DYNAMIC_GROUP)
-
-#define	NPF_DYNAMIC_RULE_P(attr) \
-    (((attr) & NPF_DYNAMIC_GROUP) == NPF_RULE_DYNAMIC)
-
-npf_ruleset_t *
-npf_ruleset_create(size_t slots)
-{
-	size_t len = offsetof(npf_ruleset_t, rs_rules[slots]);
-	npf_ruleset_t *rlset;
-
-	rlset = kmem_zalloc(len, KM_SLEEP);
-	LIST_INIT(&rlset->rs_dynamic);
-	LIST_INIT(&rlset->rs_all);
-	LIST_INIT(&rlset->rs_gc);
-	rlset->rs_slots = slots;
-
-	return rlset;
-}
-
-void
-npf_ruleset_destroy(npf_ruleset_t *rlset)
-{
-	size_t len = offsetof(npf_ruleset_t, rs_rules[rlset->rs_slots]);
-	npf_rule_t *rl;
-
-	while ((rl = LIST_FIRST(&rlset->rs_all)) != NULL) {
-		if (NPF_DYNAMIC_GROUP_P(rl->r_attr)) {
-			/*
-			 * Note: r_subset may point to the rules which
-			 * were inherited by a new ruleset.
-			 */
-			rl->r_subset = NULL;
-			LIST_REMOVE(rl, r_dentry);
-		}
-		if (NPF_DYNAMIC_RULE_P(rl->r_attr)) {
-			/* Not removing from r_subset, see above. */
-			KASSERT(rl->r_parent != NULL);
-		}
-		LIST_REMOVE(rl, r_aentry);
-		npf_rule_free(rl);
-	}
-	KASSERT(LIST_EMPTY(&rlset->rs_dynamic));
-
-	npf_ruleset_gc(rlset);
-	KASSERT(LIST_EMPTY(&rlset->rs_gc));
-	kmem_free(rlset, len);
-}
-
-/*
- * npf_ruleset_insert: insert the rule into the specified ruleset.
- */
-void
-npf_ruleset_insert(npf_ruleset_t *rlset, npf_rule_t *rl)
-{
-	unsigned n = rlset->rs_nitems;
-
-	KASSERT(n < rlset->rs_slots);
-
-	LIST_INSERT_HEAD(&rlset->rs_all, rl, r_aentry);
-	if (NPF_DYNAMIC_GROUP_P(rl->r_attr)) {
-		LIST_INSERT_HEAD(&rlset->rs_dynamic, rl, r_dentry);
-	} else {
-		KASSERTMSG(rl->r_parent == NULL, "cannot be dynamic rule");
-		rl->r_attr &= ~NPF_RULE_DYNAMIC;
-	}
-
-	rlset->rs_rules[n] = rl;
-	rlset->rs_nitems++;
-	rl->r_id = ++rlset->rs_idcnt;
-
-	if (rl->r_skip_to < ++n) {
-		rl->r_skip_to = SKIPTO_ADJ_FLAG | n;
-	}
-}
-
-npf_rule_t *
-npf_ruleset_lookup(npf_ruleset_t *rlset, const char *name)
-{
-	npf_rule_t *rl;
-
-	LIST_FOREACH(rl, &rlset->rs_dynamic, r_dentry) {
-		KASSERT(NPF_DYNAMIC_GROUP_P(rl->r_attr));
-		if (strncmp(rl->r_name, name, NPF_RULE_MAXNAMELEN) == 0)
-			break;
-	}
-	return rl;
-}
-
-/*
- * npf_ruleset_add: insert dynamic rule into the (active) ruleset.
- */
-int
-npf_ruleset_add(npf_ruleset_t *rlset, const char *rname, npf_rule_t *rl)
-{
-	npf_rule_t *rg, *it, *target;
-	int priocmd;
-
-	if (!NPF_DYNAMIC_RULE_P(rl->r_attr)) {
-		return EINVAL;
-	}
-	rg = npf_ruleset_lookup(rlset, rname);
-	if (rg == NULL) {
-		return ESRCH;
-	}
-
-	/* Dynamic rule - assign a unique ID and save the parent. */
-	rl->r_id = ++rlset->rs_idcnt;
-	rl->r_parent = rg;
-
-	/*
-	 * Rule priority: (highest) 1, 2 ... n (lowest).
-	 * Negative priority indicates an operation and is reset to zero.
-	 */
-	if ((priocmd = rl->r_priority) < 0) {
-		rl->r_priority = 0;
-	}
-
-	/*
-	 * WARNING: once rg->subset or target->r_next of an *active*
-	 * rule is set, then our rule becomes globally visible and active.
-	 * Must issue a load fence to ensure rl->r_next visibility first.
-	 */
-	switch (priocmd) {
-	case NPF_PRI_LAST:
-	default:
-		target = NULL;
-		it = rg->r_subset;
-		while (it && it->r_priority <= rl->r_priority) {
-			target = it;
-			it = it->r_next;
-		}
-		if (target) {
-			atomic_store_relaxed(&rl->r_next, target->r_next);
-			membar_producer();
-			atomic_store_relaxed(&target->r_next, rl);
-			break;
-		}
-		/* FALLTHROUGH */
-
-	case NPF_PRI_FIRST:
-		atomic_store_relaxed(&rl->r_next, rg->r_subset);
-		membar_producer();
-		atomic_store_relaxed(&rg->r_subset, rl);
-		break;
-	}
-
-	/* Finally, add into the all-list. */
-	LIST_INSERT_HEAD(&rlset->rs_all, rl, r_aentry);
-	return 0;
-}
-
-static void
-npf_ruleset_unlink(npf_rule_t *rl, npf_rule_t *prev)
-{
-	KASSERT(NPF_DYNAMIC_RULE_P(rl->r_attr));
-	if (prev) {
-		prev->r_next = rl->r_next;
-	} else {
-		npf_rule_t *rg = rl->r_parent;
-		rg->r_subset = rl->r_next;
-	}
-	LIST_REMOVE(rl, r_aentry);
-}
-
-/*
- * npf_ruleset_remove: remove the dynamic rule given the rule ID.
- */
-int
-npf_ruleset_remove(npf_ruleset_t *rlset, const char *rname, uint64_t id)
-{
-	npf_rule_t *rg, *prev = NULL;
-
-	if ((rg = npf_ruleset_lookup(rlset, rname)) == NULL) {
-		return ESRCH;
-	}
-	for (npf_rule_t *rl = rg->r_subset; rl; rl = rl->r_next) {
-		KASSERT(rl->r_parent == rg);
-		KASSERT(NPF_DYNAMIC_RULE_P(rl->r_attr));
-
-		/* Compare ID.  On match, remove and return. */
-		if (rl->r_id == id) {
-			npf_ruleset_unlink(rl, prev);
-			LIST_INSERT_HEAD(&rlset->rs_gc, rl, r_aentry);
-			return 0;
-		}
-		prev = rl;
-	}
-	return ENOENT;
-}
-
-/*
- * npf_ruleset_remkey: remove the dynamic rule given the rule key.
- */
-int
-npf_ruleset_remkey(npf_ruleset_t *rlset, const char *rname,
-    const void *key, size_t len)
-{
-	npf_rule_t *rg, *rlast = NULL, *prev = NULL, *lastprev = NULL;
-
-	KASSERT(len && len <= NPF_RULE_MAXKEYLEN);
-
-	if ((rg = npf_ruleset_lookup(rlset, rname)) == NULL) {
-		return ESRCH;
-	}
-
-	/* Compare the key and find the last in the list. */
-	for (npf_rule_t *rl = rg->r_subset; rl; rl = rl->r_next) {
-		KASSERT(rl->r_parent == rg);
-		KASSERT(NPF_DYNAMIC_RULE_P(rl->r_attr));
-		if (memcmp(rl->r_key, key, len) == 0) {
-			lastprev = prev;
-			rlast = rl;
-		}
-		prev = rl;
-	}
-	if (!rlast) {
-		return ENOENT;
-	}
-	npf_ruleset_unlink(rlast, lastprev);
-	LIST_INSERT_HEAD(&rlset->rs_gc, rlast, r_aentry);
-	return 0;
-}
-
-/*
- * npf_ruleset_list: serialise and return the dynamic rules.
- */
-int
-npf_ruleset_list(npf_t *npf, npf_ruleset_t *rlset, const char *rname,
-    nvlist_t *rlset_nvl)
-{
-	const npf_rule_t *rg;
-
-	KASSERT(npf_config_locked_p(npf));
-
-	if ((rg = npf_ruleset_lookup(rlset, rname)) == NULL) {
-		return ESRCH;
-	}
-	for (const npf_rule_t *rl = rg->r_subset; rl; rl = rl->r_next) {
-		nvlist_t *rule;
-
-		KASSERT(rl->r_parent == rg);
-		KASSERT(NPF_DYNAMIC_RULE_P(rl->r_attr));
-
-		if ((rule = npf_rule_export(npf, rl)) == NULL) {
-			return ENOMEM;
-		}
-		nvlist_append_nvlist_array(rlset_nvl, "rules", rule);
-		nvlist_destroy(rule);
-	}
-	return 0;
-}
-
-/*
- * npf_ruleset_flush: flush the dynamic rules in the ruleset by inserting
- * them into the G/C list.
- */
-int
-npf_ruleset_flush(npf_ruleset_t *rlset, const char *rname)
-{
-	npf_rule_t *rg, *rl;
-
-	if ((rg = npf_ruleset_lookup(rlset, rname)) == NULL) {
-		return ESRCH;
-	}
-
-	rl = atomic_swap_ptr(&rg->r_subset, NULL);
-	membar_producer();
-
-	while (rl) {
-		KASSERT(NPF_DYNAMIC_RULE_P(rl->r_attr));
-		KASSERT(rl->r_parent == rg);
-
-		LIST_REMOVE(rl, r_aentry);
-		LIST_INSERT_HEAD(&rlset->rs_gc, rl, r_aentry);
-		rl = rl->r_next;
-	}
-	rlset->rs_idcnt = 0;
-	return 0;
-}
-
-/*
- * npf_ruleset_gc: destroy the rules in G/C list.
- */
-void
-npf_ruleset_gc(npf_ruleset_t *rlset)
-{
-	npf_rule_t *rl;
-
-	while ((rl = LIST_FIRST(&rlset->rs_gc)) != NULL) {
-		LIST_REMOVE(rl, r_aentry);
-		npf_rule_free(rl);
-	}
-}
-
-/*
- * npf_ruleset_export: serialise and return the static rules.
- */
-int
-npf_ruleset_export(npf_t *npf, const npf_ruleset_t *rlset,
-    const char *key, nvlist_t *npf_nv)
-{
-	const unsigned nitems = rlset->rs_nitems;
-	unsigned n = 0;
-	int error = 0;
-
-	KASSERT(npf_config_locked_p(npf));
-
-	while (n < nitems) {
-		const npf_rule_t *rl = rlset->rs_rules[n];
-		const npf_natpolicy_t *natp = rl->r_natp;
-		nvlist_t *rule;
-
-		rule = npf_rule_export(npf, rl);
-		if (!rule) {
-			error = ENOMEM;
-			break;
-		}
-		if (natp && (error = npf_natpolicy_export(natp, rule)) != 0) {
-			nvlist_destroy(rule);
-			break;
-		}
-		nvlist_append_nvlist_array(npf_nv, key, rule);
-		nvlist_destroy(rule);
-		n++;
-	}
-	return error;
-}
-
-/*
- * npf_ruleset_reload: prepare the new ruleset by scanning the active
- * ruleset and: 1) sharing the dynamic rules 2) sharing NAT policies.
- *
- * => The active (old) ruleset should be exclusively locked.
- */
-void
-npf_ruleset_reload(npf_t *npf, npf_ruleset_t *newset,
-    npf_ruleset_t *oldset, bool load)
-{
-	npf_rule_t *rg, *rl;
-	uint64_t nid = 0;
-
-	KASSERT(npf_config_locked_p(npf));
-
-	/*
-	 * Scan the dynamic rules and share (migrate) if needed.
-	 */
-	LIST_FOREACH(rg, &newset->rs_dynamic, r_dentry) {
-		npf_rule_t *active_rgroup;
-
-		/* Look for a dynamic ruleset group with such name. */
-		active_rgroup = npf_ruleset_lookup(oldset, rg->r_name);
-		if (active_rgroup == NULL) {
-			continue;
-		}
-
-		/*
-		 * ATOMICITY: Copy the head pointer of the linked-list,
-		 * but do not remove the rules from the active r_subset.
-		 * This is necessary because the rules are still active
-		 * and therefore are accessible for inspection via the
-		 * old ruleset.
-		 */
-		rg->r_subset = active_rgroup->r_subset;
-
-		/*
-		 * We can safely migrate to the new all-rule list and
-		 * reset the parent rule, though.
-		 */
-		for (rl = rg->r_subset; rl; rl = rl->r_next) {
-			KASSERT(NPF_DYNAMIC_RULE_P(rl->r_attr));
-			LIST_REMOVE(rl, r_aentry);
-			LIST_INSERT_HEAD(&newset->rs_all, rl, r_aentry);
-
-			KASSERT(rl->r_parent == active_rgroup);
-			rl->r_parent = rg;
-		}
-	}
-
-	/*
-	 * If performing the load of connections then NAT policies might
-	 * already have translated connections associated with them and
-	 * we should not share or inherit anything.
-	 */
-	if (load)
-		return;
-
-	/*
-	 * Scan all rules in the new ruleset and inherit the active NAT
-	 * policies if they are the same.  Also, assign a unique ID for
-	 * each policy here.
-	 */
-	LIST_FOREACH(rl, &newset->rs_all, r_aentry) {
-		npf_natpolicy_t *np;
-		npf_rule_t *actrl;
-
-		/* Does the rule have a NAT policy associated? */
-		if ((np = rl->r_natp) == NULL) {
-			continue;
-		}
-
-		/* Does it match with any policy in the active ruleset? */
-		LIST_FOREACH(actrl, &oldset->rs_all, r_aentry) {
-			if (!actrl->r_natp)
-				continue;
-			if ((actrl->r_attr & NPF_RULE_KEEPNAT) != 0)
-				continue;
-			if (npf_natpolicy_cmp(actrl->r_natp, np))
-				break;
-		}
-		if (!actrl) {
-			/* No: just set the ID and continue. */
-			npf_nat_setid(np, ++nid);
-			continue;
-		}
-
-		/* Yes: inherit the matching NAT policy. */
-		rl->r_natp = actrl->r_natp;
-		npf_nat_setid(rl->r_natp, ++nid);
-
-		/*
-		 * Finally, mark the active rule to not destroy its NAT
-		 * policy later as we inherited it (but the rule must be
-		 * kept active for now).  Destroy the new/unused policy.
-		 */
-		actrl->r_attr |= NPF_RULE_KEEPNAT;
-		npf_natpolicy_destroy(np);
-	}
-
-	/* Inherit the ID counter. */
-	newset->rs_idcnt = oldset->rs_idcnt;
-}
-
-/*
- * npf_ruleset_findnat: find a NAT policy in the ruleset by a given ID.
- */
-npf_natpolicy_t *
-npf_ruleset_findnat(npf_ruleset_t *rlset, uint64_t id)
-{
-	npf_rule_t *rl;
-
-	LIST_FOREACH(rl, &rlset->rs_all, r_aentry) {
-		npf_natpolicy_t *np = rl->r_natp;
-		if (np && npf_nat_getid(np) == id) {
-			return np;
-		}
-	}
-	return NULL;
-}
-
-/*
- * npf_ruleset_freealg: inspect the ruleset and disassociate specified
- * ALG from all NAT entries using it.
- */
-void
-npf_ruleset_freealg(npf_ruleset_t *rlset, npf_alg_t *alg)
-{
-	npf_rule_t *rl;
-	npf_natpolicy_t *np;
-
-	LIST_FOREACH(rl, &rlset->rs_all, r_aentry) {
-		if ((np = rl->r_natp) != NULL) {
-			npf_nat_freealg(np, alg);
-		}
-	}
-}
-
-/*
- * npf_rule_alloc: allocate a rule and initialise it.
- */
-npf_rule_t *
-npf_rule_alloc(npf_t *npf, const nvlist_t *rule)
-{
-	npf_rule_t *rl;
-	const char *rname;
-	const void *key, *info;
-	size_t len;
-
-	/* Allocate a rule structure and keep the information. */
-	rl = kmem_zalloc(sizeof(npf_rule_t), KM_SLEEP);
-	info = dnvlist_get_binary(rule, "info", &rl->r_info_len, NULL, 0);
-	if (info) {
-		rl->r_info = kmem_alloc(rl->r_info_len, KM_SLEEP);
-		memcpy(rl->r_info, info, rl->r_info_len);
-	}
-	rl->r_natp = NULL;
-
-	/* Name (optional) */
-	if ((rname = dnvlist_get_string(rule, "name", NULL)) != NULL) {
-		strlcpy(rl->r_name, rname, NPF_RULE_MAXNAMELEN);
-	} else {
-		rl->r_name[0] = '\0';
-	}
-
-	/* Attributes, priority and interface ID (optional). */
-	rl->r_attr = dnvlist_get_number(rule, "attr", 0);
-	rl->r_attr &= ~NPF_RULE_PRIVMASK;
-
-	if (NPF_DYNAMIC_RULE_P(rl->r_attr)) {
-		/* Priority of the dynamic rule. */
-		rl->r_priority = (int)dnvlist_get_number(rule, "prio", 0);
-	} else {
-		/* The skip-to index.  No need to validate it. */
-		rl->r_skip_to = dnvlist_get_number(rule, "skip-to", 0);
-	}
-
-	/* Interface name; register and get the npf-if-id. */
-	if ((rname = dnvlist_get_string(rule, "ifname", NULL)) != NULL) {
-		if ((rl->r_ifid = npf_ifmap_register(npf, rname)) == 0) {
-			kmem_free(rl, sizeof(npf_rule_t));
-			return NULL;
-		}
-	} else {
-		rl->r_ifid = 0;
-	}
-
-	/* Key (optional). */
-	if ((key = dnvlist_get_binary(rule, "key", &len, NULL, 0)) != NULL) {
-		if (len > NPF_RULE_MAXKEYLEN) {
-			kmem_free(rl, sizeof(npf_rule_t));
-			return NULL;
-		}
-		memcpy(rl->r_key, key, len);
-	}
-	return rl;
-}
-
-static nvlist_t *
-npf_rule_export(npf_t *npf, const npf_rule_t *rl)
-{
-	nvlist_t *rule = nvlist_create(0);
-	unsigned skip_to = 0;
-	npf_rproc_t *rp;
-
-	nvlist_add_number(rule, "attr", rl->r_attr);
-	nvlist_add_number(rule, "prio", rl->r_priority);
-	if ((rl->r_skip_to & SKIPTO_ADJ_FLAG) == 0) {
-		skip_to = rl->r_skip_to & SKIPTO_MASK;
-	}
-	nvlist_add_number(rule, "skip-to", skip_to);
-	nvlist_add_number(rule, "code-type", rl->r_type);
-	if (rl->r_code) {
-		nvlist_add_binary(rule, "code", rl->r_code, rl->r_clen);
-	}
-	if (rl->r_ifid) {
-		char ifname[IFNAMSIZ];
-		npf_ifmap_copyname(npf, rl->r_ifid, ifname, sizeof(ifname));
-		nvlist_add_string(rule, "ifname", ifname);
-	}
-	nvlist_add_number(rule, "id", rl->r_id);
-
-	if (rl->r_name[0]) {
-		nvlist_add_string(rule, "name", rl->r_name);
-	}
-	if (NPF_DYNAMIC_RULE_P(rl->r_attr)) {
-		nvlist_add_binary(rule, "key", rl->r_key, NPF_RULE_MAXKEYLEN);
-	}
-	if (rl->r_info) {
-		nvlist_add_binary(rule, "info", rl->r_info, rl->r_info_len);
-	}
-	if ((rp = npf_rule_getrproc(rl)) != NULL) {
-		const char *rname = npf_rproc_getname(rp);
-		nvlist_add_string(rule, "rproc", rname);
-		npf_rproc_release(rp);
-	}
-	return rule;
-}
-
-/*
- * npf_rule_setcode: assign filter code to the rule.
- *
- * => The code must be validated by the caller.
- * => JIT compilation may be performed here.
- */
-void
-npf_rule_setcode(npf_rule_t *rl, const int type, void *code, size_t size)
-{
-	KASSERT(type == NPF_CODE_BPF);
-
-	rl->r_type = type;
-	rl->r_code = code;
-	rl->r_clen = size;
-	rl->r_jcode = npf_bpf_compile(code, size);
-}
-
-/*
- * npf_rule_setrproc: assign a rule procedure and hold a reference on it.
- */
-void
-npf_rule_setrproc(npf_rule_t *rl, npf_rproc_t *rp)
-{
-	npf_rproc_acquire(rp);
-	rl->r_rproc = rp;
-}
-
-/*
- * npf_rule_free: free the specified rule.
- */
-void
-npf_rule_free(npf_rule_t *rl)
-{
-	npf_natpolicy_t *np = rl->r_natp;
-	npf_rproc_t *rp = rl->r_rproc;
-
-	if (np && (rl->r_attr & NPF_RULE_KEEPNAT) == 0) {
-		/* Destroy the NAT policy. */
-		npf_natpolicy_destroy(np);
-	}
-	if (rp) {
-		/* Release rule procedure. */
-		npf_rproc_release(rp);
-	}
-	if (rl->r_code) {
-		/* Free byte-code. */
-		kmem_free(rl->r_code, rl->r_clen);
-	}
-	if (rl->r_jcode) {
-		/* Free JIT code. */
-		bpf_jit_freecode(rl->r_jcode);
-	}
-	if (rl->r_info) {
-		kmem_free(rl->r_info, rl->r_info_len);
-	}
-	kmem_free(rl, sizeof(npf_rule_t));
-}
-
-/*
- * npf_rule_getid: return the unique ID of a rule.
- * npf_rule_getrproc: acquire a reference and return rule procedure, if any.
- * npf_rule_getnat: get NAT policy assigned to the rule.
- */
-
-uint64_t
-npf_rule_getid(const npf_rule_t *rl)
-{
-	KASSERT(NPF_DYNAMIC_RULE_P(rl->r_attr));
-	return rl->r_id;
-}
-
-npf_rproc_t *
-npf_rule_getrproc(const npf_rule_t *rl)
-{
-	npf_rproc_t *rp = rl->r_rproc;
-
-	if (rp) {
-		npf_rproc_acquire(rp);
-	}
-	return rp;
-}
-
-npf_natpolicy_t *
-npf_rule_getnat(const npf_rule_t *rl)
-{
-	return rl->r_natp;
-}
-
-/*
- * npf_rule_setnat: assign NAT policy to the rule and insert into the
- * NAT policy list in the ruleset.
- */
-void
-npf_rule_setnat(npf_rule_t *rl, npf_natpolicy_t *np)
-{
-	KASSERT(rl->r_natp == NULL);
-	rl->r_natp = np;
-}
-
-/*
- * npf_rule_inspect: match the interface, direction and run the filter code.
- * Returns true if rule matches and false otherwise.
- */
-static inline bool
-npf_rule_inspect(const npf_rule_t *rl, bpf_args_t *bc_args,
-    const int di_mask, const unsigned ifid)
-{
-	/* Match the interface. */
-	if (rl->r_ifid && rl->r_ifid != ifid) {
-		return false;
-	}
-
-	/* Match the direction. */
-	if ((rl->r_attr & NPF_RULE_DIMASK) != NPF_RULE_DIMASK) {
-		if ((rl->r_attr & di_mask) == 0)
-			return false;
-	}
-
-	/* Any code? */
-	if (!rl->r_code) {
-		KASSERT(rl->r_jcode == NULL);
-		return true;
-	}
-	KASSERT(rl->r_type == NPF_CODE_BPF);
-	return npf_bpf_filter(bc_args, rl->r_code, rl->r_jcode) != 0;
-}
-
-/*
- * npf_rule_reinspect: re-inspect the dynamic rule by iterating its list.
- * This is only for the dynamic rules.  Subrules cannot have nested rules.
- */
-static inline npf_rule_t *
-npf_rule_reinspect(const npf_rule_t *rg, bpf_args_t *bc_args,
-    const int di_mask, const unsigned ifid)
-{
-	npf_rule_t *final_rl = NULL, *rl;
-
-	KASSERT(NPF_DYNAMIC_GROUP_P(rg->r_attr));
-
-	rl = atomic_load_relaxed(&rg->r_subset);
-	for (; rl; rl = atomic_load_relaxed(&rl->r_next)) {
-		KASSERT(!final_rl || rl->r_priority >= final_rl->r_priority);
-		if (!npf_rule_inspect(rl, bc_args, di_mask, ifid)) {
-			continue;
-		}
-		if (rl->r_attr & NPF_RULE_FINAL) {
-			return rl;
-		}
-		final_rl = rl;
-	}
-	return final_rl;
-}
-
-/*
- * npf_ruleset_inspect: inspect the packet against the given ruleset.
- *
- * Loop through the rules in the set and run the byte-code of each rule
- * against the packet (nbuf chain).  If sub-ruleset is found, inspect it.
- */
-npf_rule_t *
-npf_ruleset_inspect(npf_cache_t *npc, const npf_ruleset_t *rlset,
-    const int di, const int layer)
-{
-	nbuf_t *nbuf = npc->npc_nbuf;
-	const int di_mask = (di & PFIL_IN) ? NPF_RULE_IN : NPF_RULE_OUT;
-	const unsigned nitems = rlset->rs_nitems;
-	const unsigned ifid = nbuf->nb_ifid;
-	npf_rule_t *final_rl = NULL;
-	bpf_args_t bc_args;
-	unsigned n = 0;
-
-	KASSERT(((di & PFIL_IN) != 0) ^ ((di & PFIL_OUT) != 0));
-
-	/*
-	 * Prepare the external memory store and the arguments for
-	 * the BPF programs to be executed.  Reset mbuf before taking
-	 * any pointers for the BPF.
-	 */
-	uint32_t bc_words[NPF_BPF_NWORDS];
-
-	nbuf_reset(nbuf);
-	npf_bpf_prepare(npc, &bc_args, bc_words);
-
-	while (n < nitems) {
-		npf_rule_t *rl = rlset->rs_rules[n];
-		const unsigned skip_to = rl->r_skip_to & SKIPTO_MASK;
-		const uint32_t attr = rl->r_attr;
-
-		KASSERT(!nbuf_flag_p(nbuf, NBUF_DATAREF_RESET));
-		KASSERT(n < skip_to);
-
-		/* Group is a barrier: return a matching if found any. */
-		if ((attr & NPF_RULE_GROUP) != 0 && final_rl) {
-			break;
-		}
-
-		/* Main inspection of the rule. */
-		if (!npf_rule_inspect(rl, &bc_args, di_mask, ifid)) {
-			n = skip_to;
-			continue;
-		}
-
-		if (NPF_DYNAMIC_GROUP_P(attr)) {
-			/*
-			 * If this is a dynamic rule, re-inspect the subrules.
-			 * If it has any matching rule, then it is final.
-			 */
-			rl = npf_rule_reinspect(rl, &bc_args, di_mask, ifid);
-			if (rl != NULL) {
-				final_rl = rl;
-				break;
-			}
-		} else if ((attr & NPF_RULE_GROUP) == 0) {
-			/*
-			 * Groups themselves are not matching.
-			 */
-			final_rl = rl;
-		}
-
-		/* Set the matching rule and check for "final". */
-		if (attr & NPF_RULE_FINAL) {
-			break;
-		}
-		n++;
-	}
-
-	KASSERT(!nbuf_flag_p(nbuf, NBUF_DATAREF_RESET));
-	return final_rl;
-}
-
-/*
- * npf_rule_conclude: return decision and the flags for conclusion.
- *
- * => Returns ENETUNREACH if "block" and 0 if "pass".
- */
-int
-npf_rule_conclude(const npf_rule_t *rl, npf_match_info_t *mi)
-{
-	/* If not passing - drop the packet. */
-	mi->mi_retfl = rl->r_attr;
-	mi->mi_rid = rl->r_id;
-	return (rl->r_attr & NPF_RULE_PASS) ? 0 : ENETUNREACH;
-}
-
-
-#if defined(DDB) || defined(_NPF_TESTING)
-
-void
-npf_ruleset_dump(npf_t *npf, const char *name)
-{
-	npf_ruleset_t *rlset = npf_config_ruleset(npf);
-	npf_rule_t *rg, *rl;
-
-	LIST_FOREACH(rg, &rlset->rs_dynamic, r_dentry) {
-		printf("ruleset '%s':\n", rg->r_name);
-		for (rl = rg->r_subset; rl; rl = rl->r_next) {
-			printf("\tid %"PRIu64", key: ", rl->r_id);
-			for (unsigned i = 0; i < NPF_RULE_MAXKEYLEN; i++)
-				printf("%x", rl->r_key[i]);
-			printf("\n");
-		}
-	}
-}
-
-#endif
diff --git a/src/kern/npf_sendpkt.c b/src/kern/npf_sendpkt.c
deleted file mode 100644
index 3e6688d..0000000
--- a/src/kern/npf_sendpkt.c
+++ /dev/null
@@ -1,258 +0,0 @@
-/*-
- * Copyright (c) 2010-2011 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * This material is based upon work partially supported by The
- * NetBSD Foundation under a contract with Mindaugas Rasiukevicius.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
- * NPF module for packet construction routines.
- */
-
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD$");
-
-#include <sys/param.h>
-#include <sys/types.h>
-
-#include <netinet/in_systm.h>
-#include <netinet/in.h>
-#include <netinet/ip.h>
-#include <netinet/ip_icmp.h>
-#include <netinet/ip_var.h>
-#include <netinet/tcp.h>
-#include <netinet/ip6.h>
-#include <netinet/icmp6.h>
-#include <netinet6/ip6_var.h>
-#include <netinet6/scope6_var.h>
-#include <sys/mbuf.h>
-#endif
-
-#include "npf_impl.h"
-
-#define	DEFAULT_IP_TTL		(ip_defttl)
-
-#if defined(_NPF_STANDALONE)
-#define	m_gethdr(t, f)		(npf)->mbufops->alloc((npf), 0, 0)
-#define	m_freem(m)		(npc)->npc_ctx->mbufops->free(m)
-#define	mtod(m,t)		((t)((npc)->npc_ctx->mbufops->getdata(m)))
-#endif
-
-#if !defined(INET6) || defined(_NPF_STANDALONE)
-#define	in6_cksum(...)		0
-#define	ip6_output(...)		0
-#define	icmp6_error(m, ...)	m_freem(m)
-#define	npf_ip6_setscope(n, i)	((void)(i), 0)
-#endif
-
-#if defined(INET6)
-static int
-npf_ip6_setscope(const npf_cache_t *npc, struct ip6_hdr *ip6)
-{
-	const struct ifnet *rcvif = npc->npc_nbuf->nb_ifp;
-
-	if (in6_clearscope(&ip6->ip6_src) || in6_clearscope(&ip6->ip6_dst)) {
-		return EINVAL;
-	}
-	if (in6_setscope(&ip6->ip6_src, rcvif, NULL) ||
-	    in6_setscope(&ip6->ip6_dst, rcvif, NULL)) {
-		return EINVAL;
-	}
-	return 0;
-}
-#endif
-
-/*
- * npf_return_tcp: return a TCP reset (RST) packet.
- */
-static int
-npf_return_tcp(npf_cache_t *npc)
-{
-	npf_t *npf = npc->npc_ctx;
-	struct mbuf *m;
-	struct ip *ip = NULL;
-	struct ip6_hdr *ip6 = NULL;
-	struct tcphdr *oth, *th;
-	tcp_seq seq, ack;
-	int tcpdlen, len;
-	uint32_t win;
-
-	/* Fetch relevant data. */
-	KASSERT(npf_iscached(npc, NPC_IP46));
-	KASSERT(npf_iscached(npc, NPC_LAYER4));
-	tcpdlen = npf_tcpsaw(npc, &seq, &ack, &win);
-	oth = npc->npc_l4.tcp;
-
-	if (oth->th_flags & TH_RST) {
-		return 0;
-	}
-
-	/* Create and setup a network buffer. */
-	if (npf_iscached(npc, NPC_IP4)) {
-		len = sizeof(struct ip) + sizeof(struct tcphdr);
-	} else if (npf_iscached(npc, NPC_IP6)) {
-		len = sizeof(struct ip6_hdr) + sizeof(struct tcphdr);
-	} else {
-		return EINVAL;
-	}
-
-	m = m_gethdr(M_DONTWAIT, MT_HEADER);
-	if (m == NULL) {
-		return ENOMEM;
-	}
-#if !defined(_NPF_STANDALONE)
-	m->m_data += max_linkhdr;
-	m->m_len = len;
-	m->m_pkthdr.len = len;
-	(void)npf;
-#endif
-	if (npf_iscached(npc, NPC_IP4)) {
-		struct ip *oip = npc->npc_ip.v4;
-
-		ip = mtod(m, struct ip *);
-		memset(ip, 0, len);
-
-		/*
-		 * First, partially fill IPv4 header for TCP checksum.
-		 * Note: IP length contains TCP header length.
-		 */
-		ip->ip_p = IPPROTO_TCP;
-		ip->ip_src.s_addr = oip->ip_dst.s_addr;
-		ip->ip_dst.s_addr = oip->ip_src.s_addr;
-		ip->ip_len = htons(sizeof(struct tcphdr));
-
-		th = (struct tcphdr *)(ip + 1);
-	} else {
-		struct ip6_hdr *oip = npc->npc_ip.v6;
-
-		KASSERT(npf_iscached(npc, NPC_IP6));
-		ip6 = mtod(m, struct ip6_hdr *);
-		memset(ip6, 0, len);
-
-		ip6->ip6_nxt = IPPROTO_TCP;
-		ip6->ip6_hlim = IPV6_DEFHLIM;
-		memcpy(&ip6->ip6_src, &oip->ip6_dst, sizeof(struct in6_addr));
-		memcpy(&ip6->ip6_dst, &oip->ip6_src, sizeof(struct in6_addr));
-		ip6->ip6_plen = htons(len);
-		ip6->ip6_vfc = IPV6_VERSION;
-
-		th = (struct tcphdr *)(ip6 + 1);
-	}
-
-	/*
-	 * Construct TCP header and compute the checksum.
-	 */
-	th->th_sport = oth->th_dport;
-	th->th_dport = oth->th_sport;
-	th->th_seq = htonl(ack);
-	if (oth->th_flags & TH_SYN) {
-		tcpdlen++;
-	}
-	th->th_ack = htonl(seq + tcpdlen);
-	th->th_off = sizeof(struct tcphdr) >> 2;
-	th->th_flags = TH_ACK | TH_RST;
-
-	if (npf_iscached(npc, NPC_IP4)) {
-		th->th_sum = in_cksum(m, len);
-
-		/*
-		 * Second, fill the rest of IPv4 header and correct IP length.
-		 */
-		ip->ip_v = IPVERSION;
-		ip->ip_hl = sizeof(struct ip) >> 2;
-		ip->ip_tos = IPTOS_LOWDELAY;
-		ip->ip_len = htons(len);
-		ip->ip_ttl = DEFAULT_IP_TTL;
-	} else {
-		KASSERT(npf_iscached(npc, NPC_IP6));
-		th->th_sum = in6_cksum(m, IPPROTO_TCP, sizeof(struct ip6_hdr),
-		    sizeof(struct tcphdr));
-
-		/* Handle IPv6 scopes */
-		if (npf_ip6_setscope(npc, ip6) != 0) {
-			goto bad;
-		}
-	}
-
-	/* Pass to IP layer. */
-	if (npf_iscached(npc, NPC_IP4)) {
-		return ip_output(m, NULL, NULL, IP_FORWARDING, NULL, NULL);
-	}
-	return ip6_output(m, NULL, NULL, IPV6_FORWARDING, NULL, NULL, NULL);
-bad:
-	m_freem(m);
-	return EINVAL;
-}
-
-/*
- * npf_return_icmp: return an ICMP error.
- */
-static int
-npf_return_icmp(const npf_cache_t *npc)
-{
-	struct mbuf *m = nbuf_head_mbuf(npc->npc_nbuf);
-
-	if (npf_iscached(npc, NPC_IP4)) {
-		icmp_error(m, ICMP_UNREACH, ICMP_UNREACH_ADMIN_PROHIBIT, 0, 0);
-		return 0;
-	} else if (npf_iscached(npc, NPC_IP6)) {
-		/* Handle IPv6 scopes */
-		struct ip6_hdr *ip6 = mtod(m, struct ip6_hdr *);
-
-		if (npf_ip6_setscope(npc, ip6) != 0) {
-			return EINVAL;
-		}
-		icmp6_error(m, ICMP6_DST_UNREACH, ICMP6_DST_UNREACH_ADMIN, 0);
-		return 0;
-	}
-	return EINVAL;
-}
-
-/*
- * npf_return_block: return TCP reset or ICMP host unreachable packet.
- *
- * => Returns true if the buffer was consumed (freed) and false otherwise.
- */
-bool
-npf_return_block(npf_cache_t *npc, const int retfl)
-{
-	if (!npf_iscached(npc, NPC_IP46) || !npf_iscached(npc, NPC_LAYER4)) {
-		return false;
-	}
-	switch (npc->npc_proto) {
-	case IPPROTO_TCP:
-		if (retfl & NPF_RULE_RETRST) {
-			(void)npf_return_tcp(npc);
-		}
-		break;
-	case IPPROTO_UDP:
-		if (retfl & NPF_RULE_RETICMP)
-			if (npf_return_icmp(npc) == 0)
-				return true;
-		break;
-	}
-	return false;
-}
diff --git a/src/kern/npf_state.c b/src/kern/npf_state.c
deleted file mode 100644
index 891c25d..0000000
--- a/src/kern/npf_state.c
+++ /dev/null
@@ -1,266 +0,0 @@
-/*-
- * Copyright (c) 2010-2012 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * This material is based upon work partially supported by The
- * NetBSD Foundation under a contract with Mindaugas Rasiukevicius.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
- * NPF state engine to track connection.
- */
-
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD$");
-
-#include <sys/param.h>
-#include <sys/systm.h>
-#include <sys/mutex.h>
-#endif
-
-#include "npf_impl.h"
-
-/*
- * Generic connection states and timeout table.
- *
- * Note: used for connection-less protocols.
- */
-
-#define	NPF_ANY_CONN_CLOSED		0
-#define	NPF_ANY_CONN_NEW		1
-#define	NPF_ANY_CONN_ESTABLISHED	2
-#define	NPF_ANY_CONN_NSTATES		3
-
-/*
- * Parameters.
- */
-typedef struct {
-	int		timeouts[NPF_ANY_CONN_NSTATES];
-	int		gre_timeout;
-} npf_state_params_t;
-
-/*
- * Generic FSM.
- */
-static const uint8_t npf_generic_fsm[NPF_ANY_CONN_NSTATES][2] = {
-	[NPF_ANY_CONN_CLOSED] = {
-		[NPF_FLOW_FORW]		= NPF_ANY_CONN_NEW,
-	},
-	[NPF_ANY_CONN_NEW] = {
-		[NPF_FLOW_FORW]		= NPF_ANY_CONN_NEW,
-		[NPF_FLOW_BACK]		= NPF_ANY_CONN_ESTABLISHED,
-	},
-	[NPF_ANY_CONN_ESTABLISHED] = {
-		[NPF_FLOW_FORW]		= NPF_ANY_CONN_ESTABLISHED,
-		[NPF_FLOW_BACK]		= NPF_ANY_CONN_ESTABLISHED,
-	},
-};
-
-/*
- * State sampler for debugging.
- */
-#if defined(_NPF_TESTING)
-static void (*npf_state_sample)(npf_state_t *, bool) = NULL;
-#define	NPF_STATE_SAMPLE(n, r) if (npf_state_sample) (*npf_state_sample)(n, r);
-#else
-#define	NPF_STATE_SAMPLE(n, r)
-#endif
-
-void
-npf_state_sysinit(npf_t *npf)
-{
-	npf_state_params_t *params = npf_param_allocgroup(npf,
-	    NPF_PARAMS_GENERIC_STATE, sizeof(npf_state_params_t));
-	npf_param_t param_map[] = {
-		/*
-		 * Generic timeout (in seconds).
-		 */
-		{
-			"state.generic.timeout.closed",
-			&params->timeouts[NPF_ANY_CONN_CLOSED],
-			.default_val = 0,
-			.min = 0, .max = INT_MAX
-		},
-		{
-			"state.generic.timeout.new",
-			&params->timeouts[NPF_ANY_CONN_NEW],
-			.default_val = 30,
-			.min = 0, .max = INT_MAX
-		},
-		{
-			"state.generic.timeout.established",
-			&params->timeouts[NPF_ANY_CONN_ESTABLISHED],
-			.default_val = 60,
-			.min = 0, .max = INT_MAX
-		},
-		{
-			"state.generic.timeout.gre",
-			&params->gre_timeout,
-			.default_val = 24 * 60 * 60,
-			.min = 0, .max = INT_MAX
-		},
-	};
-	npf_param_register(npf, param_map, __arraycount(param_map));
-	npf_state_tcp_sysinit(npf);
-}
-
-void
-npf_state_sysfini(npf_t *npf)
-{
-	const size_t len = sizeof(npf_state_params_t);
-	npf_param_freegroup(npf, NPF_PARAMS_GENERIC_STATE, len);
-	npf_state_tcp_sysfini(npf);
-}
-
-/*
- * npf_state_init: initialise the state structure.
- *
- * Should normally be called on a first packet, which also determines the
- * direction in a case of connection-orientated protocol.  Returns true on
- * success and false otherwise (e.g. if protocol is not supported).
- */
-bool
-npf_state_init(npf_cache_t *npc, npf_state_t *nst)
-{
-	const int proto = npc->npc_proto;
-	bool ret;
-
-	KASSERT(npf_iscached(npc, NPC_IP46));
-	KASSERT(npf_iscached(npc, NPC_LAYER4));
-
-	memset(nst, 0, sizeof(npf_state_t));
-
-	switch (proto) {
-	case IPPROTO_TCP:
-		/* Pass to TCP state tracking engine. */
-		ret = npf_state_tcp(npc, nst, NPF_FLOW_FORW);
-		break;
-	case IPPROTO_UDP:
-	case IPPROTO_ICMP:
-	case IPPROTO_GRE:
-		/* Generic. */
-		nst->nst_state = npf_generic_fsm[nst->nst_state][NPF_FLOW_FORW];
-		ret = true;
-		break;
-	default:
-		ret = false;
-	}
-	NPF_STATE_SAMPLE(nst, ret);
-	return ret;
-}
-
-void
-npf_state_destroy(npf_state_t *nst)
-{
-	nst->nst_state = 0;
-}
-
-/*
- * npf_state_inspect: inspect the packet according to the protocol state.
- *
- * Return true if packet is considered to match the state (e.g. for TCP,
- * the packet belongs to the tracked connection) and false otherwise.
- */
-bool
-npf_state_inspect(npf_cache_t *npc, npf_state_t *nst, const npf_flow_t flow)
-{
-	const int proto = npc->npc_proto;
-	bool ret;
-
-	switch (proto) {
-	case IPPROTO_TCP:
-		/* Pass to TCP state tracking engine. */
-		ret = npf_state_tcp(npc, nst, flow);
-		break;
-	case IPPROTO_UDP:
-	case IPPROTO_ICMP:
-	case IPPROTO_GRE:
-		/* Generic. */
-		nst->nst_state = npf_generic_fsm[nst->nst_state][flow];
-		ret = true;
-		break;
-	default:
-		ret = false;
-	}
-	NPF_STATE_SAMPLE(nst, ret);
-
-	return ret;
-}
-
-/*
- * npf_state_etime: return the expiration time depending on the state.
- */
-int
-npf_state_etime(npf_t *npf, const npf_state_t *nst, const int proto)
-{
-	const npf_state_params_t *params;
-	const unsigned state = nst->nst_state;
-	int timeout = 0;
-
-	switch (proto) {
-	case IPPROTO_TCP:
-		/* Pass to TCP state tracking engine. */
-		timeout = npf_state_tcp_timeout(npf, nst);
-		break;
-	case IPPROTO_UDP:
-	case IPPROTO_ICMP:
-		/* Generic. */
-		params = npf->params[NPF_PARAMS_GENERIC_STATE];
-		timeout = params->timeouts[state];
-		break;
-	case IPPROTO_GRE:
-		params = npf->params[NPF_PARAMS_GENERIC_STATE];
-		timeout = params->gre_timeout;
-		break;
-	default:
-		KASSERT(false);
-	}
-	return timeout;
-}
-
-void
-npf_state_dump(const npf_state_t *nst)
-{
-#if defined(DDB) || defined(_NPF_TESTING)
-	const npf_tcpstate_t *fst = &nst->nst_tcpst[0];
-	const npf_tcpstate_t *tst = &nst->nst_tcpst[1];
-
-	printf("\tstate (%p) %d:\n\t\t"
-	    "F { end %u maxend %u mwin %u wscale %u }\n\t\t"
-	    "T { end %u maxend %u mwin %u wscale %u }\n",
-	    nst, nst->nst_state,
-	    fst->nst_end, fst->nst_maxend, fst->nst_maxwin, fst->nst_wscale,
-	    tst->nst_end, tst->nst_maxend, tst->nst_maxwin, tst->nst_wscale
-	);
-#endif
-}
-
-#if defined(_NPF_TESTING)
-void
-npf_state_setsampler(void (*func)(npf_state_t *, bool))
-{
-	npf_state_sample = func;
-}
-#endif
diff --git a/src/kern/npf_state_tcp.c b/src/kern/npf_state_tcp.c
deleted file mode 100644
index 55bed01..0000000
--- a/src/kern/npf_state_tcp.c
+++ /dev/null
@@ -1,592 +0,0 @@
-/*-
- * Copyright (c) 2010-2012 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * This material is based upon work partially supported by The
- * NetBSD Foundation under a contract with Mindaugas Rasiukevicius.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
- * NPF TCP state engine for connection tracking.
- */
-
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD$");
-
-#include <sys/param.h>
-#include <sys/types.h>
-
-#include <netinet/in.h>
-#include <netinet/tcp.h>
-#endif
-
-#include "npf_impl.h"
-
-/*
- * NPF TCP states.  Note: these states are different from the TCP FSM
- * states of RFC 793.  The packet filter is a man-in-the-middle.
- */
-#define	NPF_TCPS_OK		255
-#define	NPF_TCPS_CLOSED		0
-#define	NPF_TCPS_SYN_SENT	1
-#define	NPF_TCPS_SIMSYN_SENT	2
-#define	NPF_TCPS_SYN_RECEIVED	3
-#define	NPF_TCPS_ESTABLISHED	4
-#define	NPF_TCPS_FIN_SENT	5
-#define	NPF_TCPS_FIN_RECEIVED	6
-#define	NPF_TCPS_CLOSE_WAIT	7
-#define	NPF_TCPS_FIN_WAIT	8
-#define	NPF_TCPS_CLOSING	9
-#define	NPF_TCPS_LAST_ACK	10
-#define	NPF_TCPS_TIME_WAIT	11
-
-#define	NPF_TCP_NSTATES		12
-
-/* Timeouts */
-#define	NPF_TCPT_NEW		0
-#define	NPF_TCPT_ESTABLISHED	1
-#define	NPF_TCPT_HALFCLOSE	2
-#define	NPF_TCPT_CLOSE		3
-#define	NPF_TCPT_TIMEWAIT	4
-#define	NPF_TCPT_COUNT		5
-
-/*
- * Parameters.
- */
-typedef struct {
-	int		max_ack_win;
-	int		strict_order_rst;
-	int		timeouts[NPF_TCPT_COUNT];
-} npf_state_tcp_params_t;
-
-/*
- * Helpers.
- */
-#define	SEQ_LT(a,b)		((int)((a)-(b)) < 0)
-#define	SEQ_LEQ(a,b)		((int)((a)-(b)) <= 0)
-#define	SEQ_GT(a,b)		((int)((a)-(b)) > 0)
-#define	SEQ_GEQ(a,b)		((int)((a)-(b)) >= 0)
-
-/*
- * List of TCP flag cases and conversion of flags to a case (index).
- */
-
-#define	TCPFC_INVALID		0
-#define	TCPFC_SYN		1
-#define	TCPFC_SYNACK		2
-#define	TCPFC_ACK		3
-#define	TCPFC_FIN		4
-#define	TCPFC_COUNT		5
-
-static inline unsigned
-npf_tcpfl2case(const unsigned tcpfl)
-{
-	unsigned i, c;
-
-	CTASSERT(TH_FIN == 0x01);
-	CTASSERT(TH_SYN == 0x02);
-	CTASSERT(TH_ACK == 0x10);
-
-	/*
-	 * Flags are shifted to use three least significant bits, thus each
-	 * flag combination has a unique number ranging from 0 to 7, e.g.
-	 * TH_SYN | TH_ACK has number 6, since (0x02 | (0x10 >> 2)) == 6.
-	 * However, the requirement is to have number 0 for invalid cases,
-	 * such as TH_SYN | TH_FIN, and to have the same number for TH_FIN
-	 * and TH_FIN|TH_ACK cases.  Thus, we generate a mask assigning 3
-	 * bits for each number, which contains the actual case numbers:
-	 *
-	 * TCPFC_SYNACK	<< (6 << 2) == 0x2000000 (6 - SYN,ACK)
-	 * TCPFC_FIN	<< (5 << 2) == 0x0400000 (5 - FIN,ACK)
-	 * ...
-	 *
-	 * Hence, OR'ed mask value is 0x2430140.
-	 */
-	i = (tcpfl & (TH_SYN | TH_FIN)) | ((tcpfl & TH_ACK) >> 2);
-	c = (0x2430140 >> (i << 2)) & 7;
-
-	KASSERT(c < TCPFC_COUNT);
-	return c;
-}
-
-/*
- * NPF transition table of a tracked TCP connection.
- *
- * There is a single state, which is changed in the following way:
- *
- * new_state = npf_tcp_fsm[old_state][direction][npf_tcpfl2case(tcp_flags)];
- *
- * Note that this state is different from the state in each end (host).
- */
-
-static const uint8_t npf_tcp_fsm[NPF_TCP_NSTATES][2][TCPFC_COUNT] = {
-	[NPF_TCPS_CLOSED] = {
-		[NPF_FLOW_FORW] = {
-			/* Handshake (1): initial SYN. */
-			[TCPFC_SYN]	= NPF_TCPS_SYN_SENT,
-		},
-	},
-	[NPF_TCPS_SYN_SENT] = {
-		[NPF_FLOW_FORW] = {
-			/* SYN may be retransmitted. */
-			[TCPFC_SYN]	= NPF_TCPS_OK,
-		},
-		[NPF_FLOW_BACK] = {
-			/* Handshake (2): SYN-ACK is expected. */
-			[TCPFC_SYNACK]	= NPF_TCPS_SYN_RECEIVED,
-			/* Simultaneous initiation - SYN. */
-			[TCPFC_SYN]	= NPF_TCPS_SIMSYN_SENT,
-		},
-	},
-	[NPF_TCPS_SIMSYN_SENT] = {
-		[NPF_FLOW_FORW] = {
-			/* Original SYN re-transmission. */
-			[TCPFC_SYN]	= NPF_TCPS_OK,
-			/* SYN-ACK response to simultaneous SYN. */
-			[TCPFC_SYNACK]	= NPF_TCPS_SYN_RECEIVED,
-		},
-		[NPF_FLOW_BACK] = {
-			/* Simultaneous SYN re-transmission.*/
-			[TCPFC_SYN]	= NPF_TCPS_OK,
-			/* SYN-ACK response to original SYN. */
-			[TCPFC_SYNACK]	= NPF_TCPS_SYN_RECEIVED,
-			/* FIN may occur early. */
-			[TCPFC_FIN]	= NPF_TCPS_FIN_RECEIVED,
-		},
-	},
-	[NPF_TCPS_SYN_RECEIVED] = {
-		[NPF_FLOW_FORW] = {
-			/* Handshake (3): ACK is expected. */
-			[TCPFC_ACK]	= NPF_TCPS_ESTABLISHED,
-			/* FIN may be sent early. */
-			[TCPFC_FIN]	= NPF_TCPS_FIN_SENT,
-			/* Late SYN re-transmission. */
-			[TCPFC_SYN]	= NPF_TCPS_OK,
-		},
-		[NPF_FLOW_BACK] = {
-			/* SYN-ACK may be retransmitted. */
-			[TCPFC_SYNACK]	= NPF_TCPS_OK,
-			/* XXX: ACK of late SYN in simultaneous case? */
-			[TCPFC_ACK]	= NPF_TCPS_OK,
-			/* FIN may occur early. */
-			[TCPFC_FIN]	= NPF_TCPS_FIN_RECEIVED,
-		},
-	},
-	[NPF_TCPS_ESTABLISHED] = {
-		/*
-		 * Regular ACKs (data exchange) or FIN.
-		 * FIN packets may have ACK set.
-		 */
-		[NPF_FLOW_FORW] = {
-			[TCPFC_ACK]	= NPF_TCPS_OK,
-			/* FIN by the sender. */
-			[TCPFC_FIN]	= NPF_TCPS_FIN_SENT,
-		},
-		[NPF_FLOW_BACK] = {
-			[TCPFC_ACK]	= NPF_TCPS_OK,
-			/* FIN by the receiver. */
-			[TCPFC_FIN]	= NPF_TCPS_FIN_RECEIVED,
-		},
-	},
-	[NPF_TCPS_FIN_SENT] = {
-		[NPF_FLOW_FORW] = {
-			/* FIN may be re-transmitted.  Late ACK as well. */
-			[TCPFC_ACK]	= NPF_TCPS_OK,
-			[TCPFC_FIN]	= NPF_TCPS_OK,
-		},
-		[NPF_FLOW_BACK] = {
-			/* If ACK, connection is half-closed now. */
-			[TCPFC_ACK]	= NPF_TCPS_FIN_WAIT,
-			/* FIN or FIN-ACK race - immediate closing. */
-			[TCPFC_FIN]	= NPF_TCPS_CLOSING,
-		},
-	},
-	[NPF_TCPS_FIN_RECEIVED] = {
-		/*
-		 * FIN was received.  Equivalent scenario to sent FIN.
-		 */
-		[NPF_FLOW_FORW] = {
-			[TCPFC_ACK]	= NPF_TCPS_CLOSE_WAIT,
-			[TCPFC_FIN]	= NPF_TCPS_CLOSING,
-		},
-		[NPF_FLOW_BACK] = {
-			[TCPFC_ACK]	= NPF_TCPS_OK,
-			[TCPFC_FIN]	= NPF_TCPS_OK,
-		},
-	},
-	[NPF_TCPS_CLOSE_WAIT] = {
-		/* Sender has sent the FIN and closed its end. */
-		[NPF_FLOW_FORW] = {
-			[TCPFC_ACK]	= NPF_TCPS_OK,
-			[TCPFC_FIN]	= NPF_TCPS_LAST_ACK,
-		},
-		[NPF_FLOW_BACK] = {
-			[TCPFC_ACK]	= NPF_TCPS_OK,
-			[TCPFC_FIN]	= NPF_TCPS_LAST_ACK,
-		},
-	},
-	[NPF_TCPS_FIN_WAIT] = {
-		/* Receiver has closed its end. */
-		[NPF_FLOW_FORW] = {
-			[TCPFC_ACK]	= NPF_TCPS_OK,
-			[TCPFC_FIN]	= NPF_TCPS_LAST_ACK,
-		},
-		[NPF_FLOW_BACK] = {
-			[TCPFC_ACK]	= NPF_TCPS_OK,
-			[TCPFC_FIN]	= NPF_TCPS_LAST_ACK,
-		},
-	},
-	[NPF_TCPS_CLOSING] = {
-		/* Race of FINs - expecting ACK. */
-		[NPF_FLOW_FORW] = {
-			[TCPFC_ACK]	= NPF_TCPS_LAST_ACK,
-		},
-		[NPF_FLOW_BACK] = {
-			[TCPFC_ACK]	= NPF_TCPS_LAST_ACK,
-		},
-	},
-	[NPF_TCPS_LAST_ACK] = {
-		/* FINs exchanged - expecting last ACK. */
-		[NPF_FLOW_FORW] = {
-			[TCPFC_ACK]	= NPF_TCPS_TIME_WAIT,
-		},
-		[NPF_FLOW_BACK] = {
-			[TCPFC_ACK]	= NPF_TCPS_TIME_WAIT,
-		},
-	},
-	[NPF_TCPS_TIME_WAIT] = {
-		/* May re-open the connection as per RFC 1122. */
-		[NPF_FLOW_FORW] = {
-			[TCPFC_SYN]	= NPF_TCPS_SYN_SENT,
-		},
-	},
-};
-
-/*
- * npf_tcp_inwindow: determine whether the packet is in the TCP window
- * and thus part of the connection we are tracking.
- */
-static bool
-npf_tcp_inwindow(npf_cache_t *npc, npf_state_t *nst, const npf_flow_t flow)
-{
-	const npf_state_tcp_params_t *params;
-	const struct tcphdr * const th = npc->npc_l4.tcp;
-	const int tcpfl = th->th_flags;
-	npf_tcpstate_t *fstate, *tstate;
-	int tcpdlen, ackskew;
-	tcp_seq seq, ack, end;
-	uint32_t win;
-
-	params = npc->npc_ctx->params[NPF_PARAMS_TCP_STATE];
-	KASSERT(npf_iscached(npc, NPC_TCP));
-
-	/*
-	 * Perform SEQ/ACK numbers check against boundaries.  Reference:
-	 *
-	 *	Rooij G., "Real stateful TCP packet filtering in IP Filter",
-	 *	10th USENIX Security Symposium invited talk, Aug. 2001.
-	 *
-	 * There are four boundaries defined as following:
-	 *	I)   SEQ + LEN	<= MAX { SND.ACK + MAX(SND.WIN, 1) }
-	 *	II)  SEQ	>= MAX { SND.SEQ + SND.LEN - MAX(RCV.WIN, 1) }
-	 *	III) ACK	<= MAX { RCV.SEQ + RCV.LEN }
-	 *	IV)  ACK	>= MAX { RCV.SEQ + RCV.LEN } - MAXACKWIN
-	 *
-	 * Let these members of npf_tcpstate_t be the maximum seen values of:
-	 *	nst_end		- SEQ + LEN
-	 *	nst_maxend	- ACK + MAX(WIN, 1)
-	 *	nst_maxwin	- MAX(WIN, 1)
-	 */
-
-	tcpdlen = npf_tcpsaw(__UNCONST(npc), &seq, &ack, &win);
-	end = seq + tcpdlen;
-	if (tcpfl & TH_SYN) {
-		end++;
-	}
-	if (tcpfl & TH_FIN) {
-		end++;
-	}
-
-	fstate = &nst->nst_tcpst[flow];
-	tstate = &nst->nst_tcpst[!flow];
-	win = win ? (win << fstate->nst_wscale) : 1;
-
-	/*
-	 * Initialise if the first packet.
-	 * Note: only case when nst_maxwin is zero.
-	 */
-	if (__predict_false(fstate->nst_maxwin == 0)) {
-		/*
-		 * Normally, it should be the first SYN or a re-transmission
-		 * of SYN.  The state of the other side will get set with a
-		 * SYN-ACK reply (see below).
-		 */
-		fstate->nst_end = end;
-		fstate->nst_maxend = end;
-		fstate->nst_maxwin = win;
-		tstate->nst_end = 0;
-		tstate->nst_maxend = 0;
-		tstate->nst_maxwin = 1;
-
-		/*
-		 * Handle TCP Window Scaling (RFC 1323).  Both sides may
-		 * send this option in their SYN packets.
-		 */
-		fstate->nst_wscale = 0;
-		(void)npf_fetch_tcpopts(npc, NULL, &fstate->nst_wscale);
-
-		tstate->nst_wscale = 0;
-
-		/* Done. */
-		return true;
-	}
-
-	if (fstate->nst_end == 0) {
-		/*
-		 * Should be a SYN-ACK reply to SYN.  If SYN is not set,
-		 * then we are in the middle of connection and lost tracking.
-		 */
-		fstate->nst_end = end;
-		fstate->nst_maxend = end + 1;
-		fstate->nst_maxwin = win;
-		fstate->nst_wscale = 0;
-
-		/* Handle TCP Window Scaling (must be ignored if no SYN). */
-		if (tcpfl & TH_SYN) {
-			(void)npf_fetch_tcpopts(npc, NULL, &fstate->nst_wscale);
-		}
-	}
-
-	if ((tcpfl & TH_ACK) == 0) {
-		/* Pretend that an ACK was sent. */
-		ack = tstate->nst_end;
-	} else if ((tcpfl & (TH_ACK|TH_RST)) == (TH_ACK|TH_RST) && ack == 0) {
-		/* Workaround for some TCP stacks. */
-		ack = tstate->nst_end;
-	}
-
-	if (__predict_false(tcpfl & TH_RST)) {
-		/* RST to the initial SYN may have zero SEQ - fix it up. */
-		if (seq == 0 && nst->nst_state == NPF_TCPS_SYN_SENT) {
-			end = fstate->nst_end;
-			seq = end;
-		}
-
-		/* Strict in-order sequence for RST packets (RFC 5961). */
-		if (params->strict_order_rst && (fstate->nst_end - seq) > 1) {
-			return false;
-		}
-	}
-
-	/*
-	 * Determine whether the data is within previously noted window,
-	 * that is, upper boundary for valid data (I).
-	 */
-	if (!SEQ_LEQ(end, fstate->nst_maxend)) {
-		npf_stats_inc(npc->npc_ctx, NPF_STAT_INVALID_STATE_TCP1);
-		return false;
-	}
-
-	/* Lower boundary (II), which is no more than one window back. */
-	if (!SEQ_GEQ(seq, fstate->nst_end - tstate->nst_maxwin)) {
-		npf_stats_inc(npc->npc_ctx, NPF_STAT_INVALID_STATE_TCP2);
-		return false;
-	}
-
-	/*
-	 * Boundaries for valid acknowledgments (III, IV) - one predicted
-	 * window up or down, since packets may be fragmented.
-	 */
-	ackskew = tstate->nst_end - ack;
-	if (ackskew < -(int)params->max_ack_win ||
-	    ackskew > ((int)params->max_ack_win << fstate->nst_wscale)) {
-		npf_stats_inc(npc->npc_ctx, NPF_STAT_INVALID_STATE_TCP3);
-		return false;
-	}
-
-	/*
-	 * Packet has been passed.
-	 *
-	 * Negative ackskew might be due to fragmented packets.  Since the
-	 * total length of the packet is unknown - bump the boundary.
-	 */
-
-	if (ackskew < 0) {
-		tstate->nst_end = ack;
-	}
-	/* Keep track of the maximum window seen. */
-	if (fstate->nst_maxwin < win) {
-		fstate->nst_maxwin = win;
-	}
-	if (SEQ_GT(end, fstate->nst_end)) {
-		fstate->nst_end = end;
-	}
-	/* Note the window for upper boundary. */
-	if (SEQ_GEQ(ack + win, tstate->nst_maxend)) {
-		tstate->nst_maxend = ack + win;
-	}
-	return true;
-}
-
-/*
- * npf_state_tcp: inspect TCP segment, determine whether it belongs to
- * the connection and track its state.
- */
-bool
-npf_state_tcp(npf_cache_t *npc, npf_state_t *nst, npf_flow_t flow)
-{
-	const struct tcphdr * const th = npc->npc_l4.tcp;
-	const unsigned tcpfl = th->th_flags, state = nst->nst_state;
-	unsigned nstate;
-
-	KASSERT(nst->nst_state < NPF_TCP_NSTATES);
-
-	/* Look for a transition to a new state. */
-	if (__predict_true((tcpfl & TH_RST) == 0)) {
-		const u_int flagcase = npf_tcpfl2case(tcpfl);
-		nstate = npf_tcp_fsm[state][flow][flagcase];
-	} else if (state == NPF_TCPS_TIME_WAIT) {
-		/* Prevent TIME-WAIT assassination (RFC 1337). */
-		nstate = NPF_TCPS_OK;
-	} else {
-		nstate = NPF_TCPS_CLOSED;
-	}
-
-	/* Determine whether TCP packet really belongs to this connection. */
-	if (!npf_tcp_inwindow(npc, nst, flow)) {
-		return false;
-	}
-	if (__predict_true(nstate == NPF_TCPS_OK)) {
-		return true;
-	}
-
-	nst->nst_state = nstate;
-	return true;
-}
-
-int
-npf_state_tcp_timeout(npf_t *npf, const npf_state_t *nst)
-{
-	static const uint8_t state_timeout_idx[NPF_TCP_NSTATES] = {
-		[NPF_TCPS_CLOSED]	= NPF_TCPT_CLOSE,
-		/* Unsynchronised states. */
-		[NPF_TCPS_SYN_SENT]	= NPF_TCPT_NEW,
-		[NPF_TCPS_SIMSYN_SENT]	= NPF_TCPT_NEW,
-		[NPF_TCPS_SYN_RECEIVED]	= NPF_TCPT_NEW,
-		/* Established (synchronised state). */
-		[NPF_TCPS_ESTABLISHED]	= NPF_TCPT_ESTABLISHED,
-		/* Half-closed cases. */
-		[NPF_TCPS_FIN_SENT]	= NPF_TCPT_HALFCLOSE,
-		[NPF_TCPS_FIN_RECEIVED]	= NPF_TCPT_HALFCLOSE,
-		[NPF_TCPS_CLOSE_WAIT]	= NPF_TCPT_HALFCLOSE,
-		[NPF_TCPS_FIN_WAIT]	= NPF_TCPT_HALFCLOSE,
-		/* Full close cases. */
-		[NPF_TCPS_CLOSING]	= NPF_TCPT_CLOSE,
-		[NPF_TCPS_LAST_ACK]	= NPF_TCPT_CLOSE,
-		[NPF_TCPS_TIME_WAIT]	= NPF_TCPT_TIMEWAIT,
-	};
-	const npf_state_tcp_params_t *params;
-	const unsigned state = nst->nst_state;
-
-	KASSERT(state < NPF_TCP_NSTATES);
-	params = npf->params[NPF_PARAMS_TCP_STATE];
-	return params->timeouts[state_timeout_idx[state]];
-}
-
-void
-npf_state_tcp_sysinit(npf_t *npf)
-{
-	npf_state_tcp_params_t *params = npf_param_allocgroup(npf,
-	    NPF_PARAMS_TCP_STATE, sizeof(npf_state_tcp_params_t));
-	npf_param_t param_map[] = {
-		/*
-		 * TCP connection timeout table (in seconds).
-		 */
-
-		/* Unsynchronised states. */
-		{
-			"state.tcp.timeout.new",
-			&params->timeouts[NPF_TCPT_NEW],
-			.default_val = 30,
-			.min = 0, .max = INT_MAX
-		},
-		/* Established. */
-		{
-			"state.tcp.timeout.established",
-			&params->timeouts[NPF_TCPT_ESTABLISHED],
-			.default_val = 60 * 60 * 24,
-			.min = 0, .max = INT_MAX
-		},
-		/* Half-closed cases. */
-		{
-			"state.tcp.timeout.half_close",
-			&params->timeouts[NPF_TCPT_HALFCLOSE],
-			.default_val = 60 * 60 * 6,
-			.min = 0, .max = INT_MAX
-		},
-		/* Full close cases. */
-		{
-			"state.tcp.timeout.close",
-			&params->timeouts[NPF_TCPT_CLOSE],
-			.default_val = 10,
-			.min = 0, .max = INT_MAX
-		},
-		/* TCP time-wait (2 * MSL). */
-		{
-			"state.tcp.timeout.time_wait",
-			&params->timeouts[NPF_TCPT_TIMEWAIT],
-			.default_val = 60 * 2 * 2,
-			.min = 0, .max = INT_MAX
-		},
-
-		/*
-		 * Enforce strict order RST.
-		 */
-		{
-			"state.tcp.strict_order_rst",
-			&params->strict_order_rst,
-			.default_val = 1, // true
-			.min = 0, .max = 1
-		},
-
-		/*
-		 * TCP state tracking: maximum allowed ACK window.
-		 */
-		{
-			"state.tcp.max_ack_win",
-			&params->max_ack_win,
-			.default_val = 66000,
-			.min = 0, .max = INT_MAX
-		},
-	};
-	npf_param_register(npf, param_map, __arraycount(param_map));
-}
-
-void
-npf_state_tcp_sysfini(npf_t *npf)
-{
-	const size_t len = sizeof(npf_state_tcp_params_t);
-	npf_param_freegroup(npf, NPF_PARAMS_TCP_STATE, len);
-}
diff --git a/src/kern/npf_tableset.c b/src/kern/npf_tableset.c
deleted file mode 100644
index 67d845c..0000000
--- a/src/kern/npf_tableset.c
+++ /dev/null
@@ -1,872 +0,0 @@
-/*-
- * Copyright (c) 2009-2019 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * This material is based upon work partially supported by The
- * NetBSD Foundation under a contract with Mindaugas Rasiukevicius.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
- * NPF tableset module.
- *
- * Notes
- *
- *	The tableset is an array of tables.  After the creation, the array
- *	is immutable.  The caller is responsible to synchronise the access
- *	to the tableset.
- *
- * Warning (not applicable for the userspace npfkern):
- *
- *	The thmap_put()/thmap_del() are not called from the interrupt
- *	context and are protected by an IPL_NET mutex(9), therefore they
- *	do not need SPL wrappers -- see the comment at the top of the
- *	npf_conndb.c source file.
- */
-
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD$");
-
-#include <sys/param.h>
-#include <sys/types.h>
-
-#include <sys/atomic.h>
-#include <sys/cdbr.h>
-#include <sys/kmem.h>
-#include <sys/pool.h>
-#include <sys/queue.h>
-#include <sys/mutex.h>
-#include <sys/thmap.h>
-
-#include "lpm.h"
-#endif
-
-#include "npf_impl.h"
-
-typedef struct npf_tblent {
-	LIST_ENTRY(npf_tblent)	te_listent;
-	uint16_t		te_preflen;
-	uint16_t		te_alen;
-	npf_addr_t		te_addr;
-} npf_tblent_t;
-
-#define	NPF_ADDRLEN2IDX(alen)	((alen) >> 4)
-#define	NPF_ADDR_SLOTS		(2)
-
-struct npf_table {
-	/*
-	 * The storage type can be: a) hashmap b) LPM c) cdb.
-	 * There are separate trees for IPv4 and IPv6.
-	 */
-	union {
-		struct {
-			thmap_t *	t_map;
-			LIST_HEAD(, npf_tblent) t_gc;
-		};
-		lpm_t *			t_lpm;
-		struct {
-			void *		t_blob;
-			size_t		t_bsize;
-			struct cdbr *	t_cdb;
-		};
-		struct {
-			npf_tblent_t **	t_elements[NPF_ADDR_SLOTS];
-			unsigned	t_allocated[NPF_ADDR_SLOTS];
-			unsigned	t_used[NPF_ADDR_SLOTS];
-		};
-	} /* C11 */;
-	LIST_HEAD(, npf_tblent)		t_list;
-	unsigned			t_nitems;
-
-	/*
-	 * Table ID, type and lock.  The ID may change during the
-	 * config reload, it is protected by the npf_config_lock.
-	 */
-	int			t_type;
-	unsigned		t_id;
-	kmutex_t		t_lock;
-
-	/* Reference count and table name. */
-	unsigned		t_refcnt;
-	char			t_name[NPF_TABLE_MAXNAMELEN];
-};
-
-struct npf_tableset {
-	unsigned		ts_nitems;
-	npf_table_t *		ts_map[];
-};
-
-#define	NPF_TABLESET_SIZE(n)	\
-    (offsetof(npf_tableset_t, ts_map[n]) * sizeof(npf_table_t *))
-
-#define	NPF_IFADDR_STEP		4
-
-static pool_cache_t		tblent_cache	__read_mostly;
-
-/*
- * npf_table_sysinit: initialise tableset structures.
- */
-void
-npf_tableset_sysinit(void)
-{
-	tblent_cache = pool_cache_init(sizeof(npf_tblent_t), 0,
-	    0, 0, "npftblpl", NULL, IPL_NONE, NULL, NULL, NULL);
-}
-
-void
-npf_tableset_sysfini(void)
-{
-	pool_cache_destroy(tblent_cache);
-}
-
-npf_tableset_t *
-npf_tableset_create(u_int nitems)
-{
-	npf_tableset_t *ts = kmem_zalloc(NPF_TABLESET_SIZE(nitems), KM_SLEEP);
-	ts->ts_nitems = nitems;
-	return ts;
-}
-
-void
-npf_tableset_destroy(npf_tableset_t *ts)
-{
-	/*
-	 * Destroy all tables (no references should be held, since the
-	 * ruleset should be destroyed before).
-	 */
-	for (u_int tid = 0; tid < ts->ts_nitems; tid++) {
-		npf_table_t *t = ts->ts_map[tid];
-
-		if (t && atomic_dec_uint_nv(&t->t_refcnt) == 0) {
-			npf_table_destroy(t);
-		}
-	}
-	kmem_free(ts, NPF_TABLESET_SIZE(ts->ts_nitems));
-}
-
-/*
- * npf_tableset_insert: insert the table into the specified tableset.
- *
- * => Returns 0 on success.  Fails and returns error if ID is already used.
- */
-int
-npf_tableset_insert(npf_tableset_t *ts, npf_table_t *t)
-{
-	const u_int tid = t->t_id;
-	int error;
-
-	KASSERT((u_int)tid < ts->ts_nitems);
-
-	if (ts->ts_map[tid] == NULL) {
-		atomic_inc_uint(&t->t_refcnt);
-		ts->ts_map[tid] = t;
-		error = 0;
-	} else {
-		error = EEXIST;
-	}
-	return error;
-}
-
-npf_table_t *
-npf_tableset_swap(npf_tableset_t *ts, npf_table_t *newt)
-{
-	const u_int tid = newt->t_id;
-	npf_table_t *oldt = ts->ts_map[tid];
-
-	KASSERT(tid < ts->ts_nitems);
-	KASSERT(oldt->t_id == newt->t_id);
-
-	newt->t_refcnt = oldt->t_refcnt;
-	oldt->t_refcnt = 0;
-	membar_producer();
-
-	return atomic_swap_ptr(&ts->ts_map[tid], newt);
-}
-
-/*
- * npf_tableset_getbyname: look for a table in the set given the name.
- */
-npf_table_t *
-npf_tableset_getbyname(npf_tableset_t *ts, const char *name)
-{
-	npf_table_t *t;
-
-	for (u_int tid = 0; tid < ts->ts_nitems; tid++) {
-		if ((t = ts->ts_map[tid]) == NULL)
-			continue;
-		if (strcmp(name, t->t_name) == 0)
-			return t;
-	}
-	return NULL;
-}
-
-npf_table_t *
-npf_tableset_getbyid(npf_tableset_t *ts, unsigned tid)
-{
-	if (__predict_true(tid < ts->ts_nitems)) {
-		return atomic_load_relaxed(&ts->ts_map[tid]);
-	}
-	return NULL;
-}
-
-/*
- * npf_tableset_reload: iterate all tables and if the new table is of the
- * same type and has no items, then we preserve the old one and its entries.
- *
- * => The caller is responsible for providing synchronisation.
- */
-void
-npf_tableset_reload(npf_t *npf, npf_tableset_t *nts, npf_tableset_t *ots)
-{
-	for (u_int tid = 0; tid < nts->ts_nitems; tid++) {
-		npf_table_t *t, *ot;
-
-		if ((t = nts->ts_map[tid]) == NULL) {
-			continue;
-		}
-
-		/* If our table has entries, just load it. */
-		if (t->t_nitems) {
-			continue;
-		}
-
-		/* Look for a currently existing table with such name. */
-		ot = npf_tableset_getbyname(ots, t->t_name);
-		if (ot == NULL) {
-			/* Not found: we have a new table. */
-			continue;
-		}
-
-		/* Found.  Did the type change? */
-		if (t->t_type != ot->t_type) {
-			/* Yes, load the new. */
-			continue;
-		}
-
-		/*
-		 * Preserve the current table.  Acquire a reference since
-		 * we are keeping it in the old table set.  Update its ID.
-		 */
-		atomic_inc_uint(&ot->t_refcnt);
-		nts->ts_map[tid] = ot;
-
-		KASSERT(npf_config_locked_p(npf));
-		ot->t_id = tid;
-
-		/* Destroy the new table (we hold the only reference). */
-		t->t_refcnt--;
-		npf_table_destroy(t);
-	}
-}
-
-int
-npf_tableset_export(npf_t *npf, const npf_tableset_t *ts, nvlist_t *nvl)
-{
-	const npf_table_t *t;
-
-	KASSERT(npf_config_locked_p(npf));
-
-	for (u_int tid = 0; tid < ts->ts_nitems; tid++) {
-		nvlist_t *table;
-
-		if ((t = ts->ts_map[tid]) == NULL) {
-			continue;
-		}
-		table = nvlist_create(0);
-		nvlist_add_string(table, "name", t->t_name);
-		nvlist_add_number(table, "type", t->t_type);
-		nvlist_add_number(table, "id", tid);
-
-		nvlist_append_nvlist_array(nvl, "tables", table);
-		nvlist_destroy(table);
-	}
-	return 0;
-}
-
-/*
- * Few helper routines.
- */
-
-static void
-table_ipset_flush(npf_table_t *t)
-{
-	npf_tblent_t *ent;
-
-	while ((ent = LIST_FIRST(&t->t_list)) != NULL) {
-		thmap_del(t->t_map, &ent->te_addr, ent->te_alen);
-		LIST_REMOVE(ent, te_listent);
-		pool_cache_put(tblent_cache, ent);
-	}
-	t->t_nitems = 0;
-}
-
-static void
-table_tree_flush(npf_table_t *t)
-{
-	npf_tblent_t *ent;
-
-	while ((ent = LIST_FIRST(&t->t_list)) != NULL) {
-		LIST_REMOVE(ent, te_listent);
-		pool_cache_put(tblent_cache, ent);
-	}
-	lpm_clear(t->t_lpm, NULL, NULL);
-	t->t_nitems = 0;
-}
-
-static void
-table_ifaddr_flush(npf_table_t *t)
-{
-	npf_tblent_t *ent;
-
-	for (unsigned i = 0; i < NPF_ADDR_SLOTS; i++) {
-		size_t len;
-
-		if (!t->t_allocated[i]) {
-			KASSERT(t->t_elements[i] == NULL);
-			continue;
-		}
-		len = t->t_allocated[i] * sizeof(npf_tblent_t *);
-		kmem_free(t->t_elements[i], len);
-		t->t_elements[i] = NULL;
-		t->t_allocated[i] = 0;
-		t->t_used[i] = 0;
-	}
-	while ((ent = LIST_FIRST(&t->t_list)) != NULL) {
-		LIST_REMOVE(ent, te_listent);
-		pool_cache_put(tblent_cache, ent);
-	}
-	t->t_nitems = 0;
-}
-
-/*
- * npf_table_create: create table with a specified ID.
- */
-npf_table_t *
-npf_table_create(const char *name, u_int tid, int type,
-    const void *blob, size_t size)
-{
-	npf_table_t *t;
-
-	t = kmem_zalloc(sizeof(npf_table_t), KM_SLEEP);
-	strlcpy(t->t_name, name, NPF_TABLE_MAXNAMELEN);
-
-	switch (type) {
-	case NPF_TABLE_LPM:
-		t->t_lpm = lpm_create();
-		if (t->t_lpm == NULL) {
-			goto out;
-		}
-		LIST_INIT(&t->t_list);
-		break;
-	case NPF_TABLE_IPSET:
-		t->t_map = thmap_create(0, NULL, THMAP_NOCOPY);
-		if (t->t_map == NULL) {
-			goto out;
-		}
-		break;
-	case NPF_TABLE_CONST:
-		t->t_blob = kmem_alloc(size, KM_SLEEP);
-		if (t->t_blob == NULL) {
-			goto out;
-		}
-		memcpy(t->t_blob, blob, size);
-		t->t_bsize = size;
-
-		t->t_cdb = cdbr_open_mem(t->t_blob, size,
-		    CDBR_DEFAULT, NULL, NULL);
-		if (t->t_cdb == NULL) {
-			kmem_free(t->t_blob, t->t_bsize);
-			goto out;
-		}
-		t->t_nitems = cdbr_entries(t->t_cdb);
-		break;
-	case NPF_TABLE_IFADDR:
-		break;
-	default:
-		KASSERT(false);
-	}
-	mutex_init(&t->t_lock, MUTEX_DEFAULT, IPL_NET);
-	t->t_type = type;
-	t->t_id = tid;
-	return t;
-out:
-	kmem_free(t, sizeof(npf_table_t));
-	return NULL;
-}
-
-/*
- * npf_table_destroy: free all table entries and table itself.
- */
-void
-npf_table_destroy(npf_table_t *t)
-{
-	KASSERT(t->t_refcnt == 0);
-
-	switch (t->t_type) {
-	case NPF_TABLE_IPSET:
-		table_ipset_flush(t);
-		npf_table_gc(NULL, t);
-		thmap_destroy(t->t_map);
-		break;
-	case NPF_TABLE_LPM:
-		table_tree_flush(t);
-		lpm_destroy(t->t_lpm);
-		break;
-	case NPF_TABLE_CONST:
-		cdbr_close(t->t_cdb);
-		kmem_free(t->t_blob, t->t_bsize);
-		break;
-	case NPF_TABLE_IFADDR:
-		table_ifaddr_flush(t);
-		break;
-	default:
-		KASSERT(false);
-	}
-	mutex_destroy(&t->t_lock);
-	kmem_free(t, sizeof(npf_table_t));
-}
-
-u_int
-npf_table_getid(npf_table_t *t)
-{
-	return t->t_id;
-}
-
-/*
- * npf_table_check: validate the name, ID and type.
- */
-int
-npf_table_check(npf_tableset_t *ts, const char *name, uint64_t tid,
-    uint64_t type, bool replacing)
-{
-	const npf_table_t *t;
-
-	if (tid >= ts->ts_nitems) {
-		return EINVAL;
-	}
-	if (!replacing && ts->ts_map[tid] != NULL) {
-		return EEXIST;
-	}
-	switch (type) {
-	case NPF_TABLE_LPM:
-	case NPF_TABLE_IPSET:
-	case NPF_TABLE_CONST:
-	case NPF_TABLE_IFADDR:
-		break;
-	default:
-		return EINVAL;
-	}
-	if (strlen(name) >= NPF_TABLE_MAXNAMELEN) {
-		return ENAMETOOLONG;
-	}
-	if ((t = npf_tableset_getbyname(ts, name)) != NULL) {
-		if (!replacing || t->t_id != tid) {
-			return EEXIST;
-		}
-	}
-	return 0;
-}
-
-static int
-table_ifaddr_insert(npf_table_t *t, const int alen, npf_tblent_t *ent)
-{
-	const unsigned aidx = NPF_ADDRLEN2IDX(alen);
-	const unsigned allocated = t->t_allocated[aidx];
-	const unsigned used = t->t_used[aidx];
-
-	/*
-	 * No need to check for duplicates.
-	 */
-	if (allocated <= used) {
-		npf_tblent_t **old_elements = t->t_elements[aidx];
-		npf_tblent_t **elements;
-		size_t toalloc, newsize;
-
-		toalloc = roundup2(allocated + 1, NPF_IFADDR_STEP);
-		newsize = toalloc * sizeof(npf_tblent_t *);
-
-		elements = kmem_zalloc(newsize, KM_NOSLEEP);
-		if (elements == NULL) {
-			return ENOMEM;
-		}
-		for (unsigned i = 0; i < used; i++) {
-			elements[i] = old_elements[i];
-		}
-		if (allocated) {
-			const size_t len = allocated * sizeof(npf_tblent_t *);
-			KASSERT(old_elements != NULL);
-			kmem_free(old_elements, len);
-		}
-		t->t_elements[aidx] = elements;
-		t->t_allocated[aidx] = toalloc;
-	}
-	t->t_elements[aidx][used] = ent;
-	t->t_used[aidx]++;
-	return 0;
-}
-
-/*
- * npf_table_insert: add an IP CIDR entry into the table.
- */
-int
-npf_table_insert(npf_table_t *t, const int alen,
-    const npf_addr_t *addr, const npf_netmask_t mask)
-{
-	npf_tblent_t *ent;
-	int error;
-
-	error = npf_netmask_check(alen, mask);
-	if (error) {
-		return error;
-	}
-	ent = pool_cache_get(tblent_cache, PR_WAITOK);
-	memcpy(&ent->te_addr, addr, alen);
-	ent->te_alen = alen;
-	ent->te_preflen = 0;
-
-	/*
-	 * Insert the entry.  Return an error on duplicate.
-	 */
-	mutex_enter(&t->t_lock);
-	switch (t->t_type) {
-	case NPF_TABLE_IPSET:
-		/*
-		 * Hashmap supports only IPs.
-		 *
-		 * Note: the key must be already persistent, since we
-		 * use THMAP_NOCOPY.
-		 */
-		if (mask != NPF_NO_NETMASK) {
-			error = EINVAL;
-			break;
-		}
-		if (thmap_put(t->t_map, &ent->te_addr, alen, ent) == ent) {
-			LIST_INSERT_HEAD(&t->t_list, ent, te_listent);
-			t->t_nitems++;
-		} else {
-			error = EEXIST;
-		}
-		break;
-	case NPF_TABLE_LPM: {
-		const unsigned preflen =
-		    (mask == NPF_NO_NETMASK) ? (alen * 8) : mask;
-		ent->te_preflen = preflen;
-
-		if (lpm_lookup(t->t_lpm, addr, alen) == NULL &&
-		    lpm_insert(t->t_lpm, addr, alen, preflen, ent) == 0) {
-			LIST_INSERT_HEAD(&t->t_list, ent, te_listent);
-			t->t_nitems++;
-			error = 0;
-		} else {
-			error = EEXIST;
-		}
-		break;
-	}
-	case NPF_TABLE_CONST:
-		error = EINVAL;
-		break;
-	case NPF_TABLE_IFADDR:
-		if ((error = table_ifaddr_insert(t, alen, ent)) != 0) {
-			break;
-		}
-		LIST_INSERT_HEAD(&t->t_list, ent, te_listent);
-		t->t_nitems++;
-		break;
-	default:
-		KASSERT(false);
-	}
-	mutex_exit(&t->t_lock);
-
-	if (error) {
-		pool_cache_put(tblent_cache, ent);
-	}
-	return error;
-}
-
-/*
- * npf_table_remove: remove the IP CIDR entry from the table.
- */
-int
-npf_table_remove(npf_table_t *t, const int alen,
-    const npf_addr_t *addr, const npf_netmask_t mask)
-{
-	npf_tblent_t *ent = NULL;
-	int error;
-
-	error = npf_netmask_check(alen, mask);
-	if (error) {
-		return error;
-	}
-
-	mutex_enter(&t->t_lock);
-	switch (t->t_type) {
-	case NPF_TABLE_IPSET:
-		ent = thmap_del(t->t_map, addr, alen);
-		if (__predict_true(ent != NULL)) {
-			LIST_REMOVE(ent, te_listent);
-			LIST_INSERT_HEAD(&t->t_gc, ent, te_listent);
-			ent = NULL; // to be G/C'ed
-			t->t_nitems--;
-		} else {
-			error = ENOENT;
-		}
-		break;
-	case NPF_TABLE_LPM:
-		ent = lpm_lookup(t->t_lpm, addr, alen);
-		if (__predict_true(ent != NULL)) {
-			LIST_REMOVE(ent, te_listent);
-			lpm_remove(t->t_lpm, &ent->te_addr,
-			    ent->te_alen, ent->te_preflen);
-			t->t_nitems--;
-		} else {
-			error = ENOENT;
-		}
-		break;
-	case NPF_TABLE_CONST:
-	case NPF_TABLE_IFADDR:
-		error = EINVAL;
-		break;
-	default:
-		KASSERT(false);
-		ent = NULL;
-	}
-	mutex_exit(&t->t_lock);
-
-	if (ent) {
-		pool_cache_put(tblent_cache, ent);
-	}
-	return error;
-}
-
-/*
- * npf_table_lookup: find the table according to ID, lookup and match
- * the contents with the specified IP address.
- */
-int
-npf_table_lookup(npf_table_t *t, const int alen, const npf_addr_t *addr)
-{
-	const void *data;
-	size_t dlen;
-	bool found;
-	int error;
-
-	error = npf_netmask_check(alen, NPF_NO_NETMASK);
-	if (error) {
-		return error;
-	}
-
-	switch (t->t_type) {
-	case NPF_TABLE_IPSET:
-		/* Note: the caller is in the npf_config_read_enter(). */
-		found = thmap_get(t->t_map, addr, alen) != NULL;
-		break;
-	case NPF_TABLE_LPM:
-		mutex_enter(&t->t_lock);
-		found = lpm_lookup(t->t_lpm, addr, alen) != NULL;
-		mutex_exit(&t->t_lock);
-		break;
-	case NPF_TABLE_CONST:
-		if (cdbr_find(t->t_cdb, addr, alen, &data, &dlen) == 0) {
-			found = dlen == (unsigned)alen &&
-			    memcmp(addr, data, dlen) == 0;
-		} else {
-			found = false;
-		}
-		break;
-	case NPF_TABLE_IFADDR: {
-		const unsigned aidx = NPF_ADDRLEN2IDX(alen);
-
-		found = false;
-		for (unsigned i = 0; i < t->t_used[aidx]; i++) {
-			const npf_tblent_t *elm = t->t_elements[aidx][i];
-
-			KASSERT(elm->te_alen == alen);
-
-			if (memcmp(&elm->te_addr, addr, alen) == 0) {
-				found = true;
-				break;
-			}
-		}
-		break;
-	}
-	default:
-		KASSERT(false);
-		found = false;
-	}
-
-	return found ? 0 : ENOENT;
-}
-
-npf_addr_t *
-npf_table_getsome(npf_table_t *t, const int alen, unsigned idx)
-{
-	const unsigned aidx = NPF_ADDRLEN2IDX(alen);
-	npf_tblent_t *elm;
-	unsigned nitems;
-
-	KASSERT(t->t_type == NPF_TABLE_IFADDR);
-	KASSERT(aidx < NPF_ADDR_SLOTS);
-
-	nitems = t->t_used[aidx];
-	if (nitems == 0) {
-		return NULL;
-	}
-
-	/*
-	 * No need to acquire the lock, since the table is immutable.
-	 */
-	elm = t->t_elements[aidx][idx % nitems];
-	return &elm->te_addr;
-}
-
-static int
-table_ent_copyout(const npf_addr_t *addr, const int alen, npf_netmask_t mask,
-    void *ubuf, size_t len, size_t *off)
-{
-	void *ubufp = (uint8_t *)ubuf + *off;
-	npf_ioctl_ent_t uent;
-
-	if ((*off += sizeof(npf_ioctl_ent_t)) > len) {
-		return ENOMEM;
-	}
-	uent.alen = alen;
-	memcpy(&uent.addr, addr, sizeof(npf_addr_t));
-	uent.mask = mask;
-
-	return copyout(&uent, ubufp, sizeof(npf_ioctl_ent_t));
-}
-
-static int
-table_generic_list(const npf_table_t *t, void *ubuf, size_t len)
-{
-	npf_tblent_t *ent;
-	size_t off = 0;
-	int error = 0;
-
-	LIST_FOREACH(ent, &t->t_list, te_listent) {
-		error = table_ent_copyout(&ent->te_addr,
-		    ent->te_alen, ent->te_preflen, ubuf, len, &off);
-		if (error)
-			break;
-	}
-	return error;
-}
-
-static int
-table_cdb_list(npf_table_t *t, void *ubuf, size_t len)
-{
-	size_t off = 0, dlen;
-	const void *data;
-	int error = 0;
-
-	for (size_t i = 0; i < t->t_nitems; i++) {
-		if (cdbr_get(t->t_cdb, i, &data, &dlen) != 0) {
-			return EINVAL;
-		}
-		error = table_ent_copyout(data, dlen, 0, ubuf, len, &off);
-		if (error)
-			break;
-	}
-	return error;
-}
-
-/*
- * npf_table_list: copy a list of all table entries into a userspace buffer.
- */
-int
-npf_table_list(npf_table_t *t, void *ubuf, size_t len)
-{
-	int error = 0;
-
-	mutex_enter(&t->t_lock);
-	switch (t->t_type) {
-	case NPF_TABLE_IPSET:
-		error = table_generic_list(t, ubuf, len);
-		break;
-	case NPF_TABLE_LPM:
-		error = table_generic_list(t, ubuf, len);
-		break;
-	case NPF_TABLE_CONST:
-		error = table_cdb_list(t, ubuf, len);
-		break;
-	case NPF_TABLE_IFADDR:
-		error = table_generic_list(t, ubuf, len);
-		break;
-	default:
-		KASSERT(false);
-	}
-	mutex_exit(&t->t_lock);
-
-	return error;
-}
-
-/*
- * npf_table_flush: remove all table entries.
- */
-int
-npf_table_flush(npf_table_t *t)
-{
-	int error = 0;
-
-	mutex_enter(&t->t_lock);
-	switch (t->t_type) {
-	case NPF_TABLE_IPSET:
-		table_ipset_flush(t);
-		break;
-	case NPF_TABLE_LPM:
-		table_tree_flush(t);
-		break;
-	case NPF_TABLE_CONST:
-	case NPF_TABLE_IFADDR:
-		error = EINVAL;
-		break;
-	default:
-		KASSERT(false);
-	}
-	mutex_exit(&t->t_lock);
-	return error;
-}
-
-void
-npf_table_gc(npf_t *npf, npf_table_t *t)
-{
-	npf_tblent_t *ent;
-	void *ref;
-
-	if (t->t_type != NPF_TABLE_IPSET || LIST_EMPTY(&t->t_gc)) {
-		return;
-	}
-
-	ref = thmap_stage_gc(t->t_map);
-	if (npf) {
-		npf_config_locked_p(npf);
-		npf_config_sync(npf);
-	}
-	thmap_gc(t->t_map, ref);
-
-	while ((ent = LIST_FIRST(&t->t_gc)) != NULL) {
-		LIST_REMOVE(ent, te_listent);
-		pool_cache_put(tblent_cache, ent);
-	}
-}
diff --git a/src/kern/npf_worker.c b/src/kern/npf_worker.c
deleted file mode 100644
index 472db4e..0000000
--- a/src/kern/npf_worker.c
+++ /dev/null
@@ -1,303 +0,0 @@
-/*-
- * Copyright (c) 2010-2020 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * This material is based upon work partially supported by The
- * NetBSD Foundation under a contract with Mindaugas Rasiukevicius.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifdef _KERNEL
-#include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD$");
-
-#include <sys/param.h>
-#include <sys/types.h>
-
-#include <sys/mutex.h>
-#include <sys/kmem.h>
-#include <sys/kernel.h>
-#include <sys/kthread.h>
-#include <sys/cprng.h>
-#endif
-
-#include "npf_impl.h"
-
-typedef struct npf_worker {
-	kmutex_t		lock;
-	kcondvar_t		cv;
-	kcondvar_t		exit_cv;
-	bool			exit;
-	LIST_HEAD(, npf)	instances;
-	unsigned		worker_count;
-	lwp_t *			worker[];
-} npf_workerinfo_t;
-
-#define	NPF_GC_MINWAIT		(10)		// 10 ms
-#define	NPF_GC_MAXWAIT		(10 * 1000)	// 10 sec
-
-/*
- * Flags for the npf_t::worker_flags field.
- */
-#define	WFLAG_ACTIVE		0x01	// instance enqueued for workers
-#define	WFLAG_INITED		0x02	// worker setup the instance
-#define	WFLAG_REMOVE		0x04	// remove the instance
-
-static void			npf_worker(void *)	__dead;
-static npf_workerinfo_t *	worker_info		__read_mostly;
-
-int
-npf_worker_sysinit(unsigned nworkers)
-{
-	const size_t len = offsetof(npf_workerinfo_t, worker[nworkers]);
-	npf_workerinfo_t *winfo;
-
-	KASSERT(worker_info == NULL);
-
-	if (!nworkers) {
-		return 0;
-	}
-
-	winfo = kmem_zalloc(len, KM_SLEEP);
-	winfo->worker_count = nworkers;
-	mutex_init(&winfo->lock, MUTEX_DEFAULT, IPL_SOFTNET);
-	cv_init(&winfo->exit_cv, "npfgcx");
-	cv_init(&winfo->cv, "npfgcw");
-	LIST_INIT(&winfo->instances);
-	worker_info = winfo;
-
-	for (unsigned i = 0; i < nworkers; i++) {
-		if (kthread_create(PRI_NONE, KTHREAD_MPSAFE | KTHREAD_MUSTJOIN,
-		    NULL, npf_worker, winfo, &winfo->worker[i], "npfgc%u", i)) {
-			npf_worker_sysfini();
-			return ENOMEM;
-		}
-	}
-	return 0;
-}
-
-void
-npf_worker_sysfini(void)
-{
-	npf_workerinfo_t *winfo = worker_info;
-	unsigned nworkers;
-
-	if (!winfo) {
-		return;
-	}
-
-	/* Notify the workers to exit. */
-	mutex_enter(&winfo->lock);
-	winfo->exit = true;
-	cv_broadcast(&winfo->cv);
-	mutex_exit(&winfo->lock);
-
-	/* Wait for them to finish and then destroy. */
-	nworkers = winfo->worker_count;
-	for (unsigned i = 0; i < nworkers; i++) {
-		lwp_t *worker;
-
-		if ((worker = winfo->worker[i]) != NULL) {
-			kthread_join(worker);
-		}
-	}
-	cv_destroy(&winfo->cv);
-	cv_destroy(&winfo->exit_cv);
-	mutex_destroy(&winfo->lock);
-	kmem_free(winfo, offsetof(npf_workerinfo_t, worker[nworkers]));
-	worker_info = NULL;
-}
-
-int
-npf_worker_addfunc(npf_t *npf, npf_workfunc_t work)
-{
-	KASSERTMSG(npf->worker_flags == 0,
-	    "the task must be added before the npf_worker_enlist() call");
-
-	for (unsigned i = 0; i < NPF_MAX_WORKS; i++) {
-		if (npf->worker_funcs[i] == NULL) {
-			npf->worker_funcs[i] = work;
-			return 0;
-		}
-	}
-	return -1;
-}
-
-void
-npf_worker_signal(npf_t *npf)
-{
-	npf_workerinfo_t *winfo = worker_info;
-
-	if ((npf->worker_flags & WFLAG_ACTIVE) == 0) {
-		return;
-	}
-	KASSERT(winfo != NULL);
-
-	mutex_enter(&winfo->lock);
-	cv_signal(&winfo->cv);
-	mutex_exit(&winfo->lock);
-}
-
-/*
- * npf_worker_enlist: add the NPF instance for worker(s) to process.
- */
-void
-npf_worker_enlist(npf_t *npf)
-{
-	npf_workerinfo_t *winfo = worker_info;
-
-	KASSERT(npf->worker_flags == 0);
-	if (!winfo) {
-		return;
-	}
-
-	mutex_enter(&winfo->lock);
-	LIST_INSERT_HEAD(&winfo->instances, npf, worker_entry);
-	npf->worker_flags |= WFLAG_ACTIVE;
-	mutex_exit(&winfo->lock);
-}
-
-/*
- * npf_worker_discharge: remove the NPF instance the list for workers.
- *
- * => May block waiting for a worker to finish processing the instance.
- */
-void
-npf_worker_discharge(npf_t *npf)
-{
-	npf_workerinfo_t *winfo = worker_info;
-
-	if ((npf->worker_flags & WFLAG_ACTIVE) == 0) {
-		return;
-	}
-	KASSERT(winfo != NULL);
-
-	/*
-	 * Notify the worker(s) that we are removing this instance.
-	 */
-	mutex_enter(&winfo->lock);
-	KASSERT(npf->worker_flags & WFLAG_ACTIVE);
-	npf->worker_flags |= WFLAG_REMOVE;
-	cv_broadcast(&winfo->cv);
-
-	/* Wait for a worker to process this request. */
-	while (npf->worker_flags & WFLAG_ACTIVE) {
-		cv_wait(&winfo->exit_cv, &winfo->lock);
-	}
-	mutex_exit(&winfo->lock);
-	KASSERT(npf->worker_flags == 0);
-}
-
-static void
-remove_npf_instance(npf_workerinfo_t *winfo, npf_t *npf)
-{
-	KASSERT(mutex_owned(&winfo->lock));
-	KASSERT(npf->worker_flags & WFLAG_ACTIVE);
-	KASSERT(npf->worker_flags & WFLAG_REMOVE);
-
-	/*
-	 * Remove the NPF instance:
-	 * - Release any structures owned by the worker.
-	 * - Remove the instance from the list.
-	 * - Notify any thread waiting for removal to complete.
-	 */
-	if (npf->worker_flags & WFLAG_INITED) {
-		npfk_thread_unregister(npf);
-	}
-	LIST_REMOVE(npf, worker_entry);
-	npf->worker_flags = 0;
-	cv_broadcast(&winfo->exit_cv);
-}
-
-static unsigned
-process_npf_instance(npf_workerinfo_t *winfo, npf_t *npf)
-{
-	npf_workfunc_t work;
-
-	KASSERT(mutex_owned(&winfo->lock));
-
-	if (npf->worker_flags & WFLAG_REMOVE) {
-		remove_npf_instance(winfo, npf);
-		return NPF_GC_MAXWAIT;
-	}
-
-	if ((npf->worker_flags & WFLAG_INITED) == 0) {
-		npfk_thread_register(npf);
-		npf->worker_flags |= WFLAG_INITED;
-	}
-
-	/* Run the jobs. */
-	for (unsigned i = 0; i < NPF_MAX_WORKS; i++) {
-		if ((work = npf->worker_funcs[i]) == NULL) {
-			break;
-		}
-		work(npf);
-	}
-
-	return MAX(MIN(npf->worker_wait_time, NPF_GC_MAXWAIT), NPF_GC_MINWAIT);
-}
-
-/*
- * npf_worker: the main worker loop, processing enlisted NPF instances.
- *
- * XXX: Currently, npf_workerinfo_t::lock would serialize all workers,
- * so there is no point to have more than one worker; but there might
- * not be much point anyway.
- */
-static void
-npf_worker(void *arg)
-{
-	npf_workerinfo_t *winfo = arg;
-	npf_t *npf;
-
-	mutex_enter(&winfo->lock);
-	while (!winfo->exit) {
-		unsigned wait_time = NPF_GC_MAXWAIT;
-
-		/*
-		 * Iterate all instances.  We do not use LIST_FOREACH here,
-		 * since the instance can be removed.
-		 */
-		npf = LIST_FIRST(&winfo->instances);
-		while (npf) {
-			npf_t *next = LIST_NEXT(npf, worker_entry);
-			unsigned i_wait_time = process_npf_instance(winfo, npf);
-			wait_time = MIN(wait_time, i_wait_time);
-			npf = next;
-		}
-
-		/*
-		 * Sleep and periodically wake up, unless we get notified.
-		 */
-		if (winfo->exit) {
-			break;
-		}
-		cv_timedwait(&winfo->cv, &winfo->lock, mstohz(wait_time));
-	}
-	mutex_exit(&winfo->lock);
-
-	KASSERTMSG(LIST_EMPTY(&winfo->instances),
-	    "NPF instances must be discharged before the npfk_sysfini() call");
-
-	kthread_exit(0);
-}
diff --git a/src/kern/npfkern.3 b/src/kern/npfkern.3
deleted file mode 100644
index e4ec378..0000000
--- a/src/kern/npfkern.3
+++ /dev/null
@@ -1,266 +0,0 @@
-.\"
-.\" Copyright (c) 2015-2020 Mindaugas Rasiukevicius <rmind at netbsd org>
-.\" All rights reserved.
-.\"
-.\" Redistribution and use in source and binary forms, with or without
-.\" modification, are permitted provided that the following conditions
-.\" are met:
-.\" 1. Redistributions of source code must retain the above copyright
-.\"    notice, this list of conditions and the following disclaimer.
-.\" 2. Redistributions in binary form must reproduce the above copyright
-.\"    notice, this list of conditions and the following disclaimer in the
-.\"    documentation and/or other materials provided with the distribution.
-.\"
-.\" THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
-.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
-.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
-.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
-.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
-.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
-.\" SUCH DAMAGE.
-.\"
-.Dd May 13, 2020
-.Dt libnpfkern 3
-.Os
-.Sh NAME
-.Nm libnpfkern
-.Nd standalone NPF packet filter (kernel component) as library
-.Sh LIBRARY
-.Lb libnpfkern
-.Sh SYNOPSIS
-.In net/npf.h
-.In net/npfkern.h
-.\" ---
-.Ft int
-.Fn npfk_sysinit "unsigned nworkers"
-.Ft void
-.Fn npfk_sysfini "void"
-.Ft npf_t *
-.Fn npfk_create "int flags" "const npf_mbufops_t *mbufops" \
-"const npf_ifops_t *ifops" "void *arg"
-.Ft int
-.Fn npfk_load "npf_t *npf" "void *ref" "npf_error_t *err"
-.Ft int
-.Fn npfk_socket_load "npf_t *npf" "int sock"
-.Ft void
-.Fn npfk_gc "npf_t *npf"
-.Ft void
-.Fn npfk_destroy "npf_t *npf"
-.Ft void
-.Fn npfk_thread_register "npf_t *npf"
-.Ft void
-.Fn npfk_thread_unregister "npf_t *npf"
-.Ft int
-.Fn npfk_packet_handler "npf_t *npf" "struct mbuf **mp" \
-"struct ifnet *ifp" "int di"
-.Ft void
-.Fn npfk_ifmap_attach "npf_t *npf" "struct ifnet *ifp"
-.Ft void
-.Fn npfk_ifmap_detach "npf_t *npf" "struct ifnet *ifp"
-.Ft int
-.Fn npfk_param_get "npf_t *npf" "const char *name" "int64_t *val"
-.Ft int
-.Fn npfk_param_set "npf_t *npf" "const char *name" "int64_t val"
-.Ft void
-.Fn npfk_stats "npf_t *npf" "uint64_t *buf"
-.Ft void
-.Fn npfk_stats_clear "npf_t *npf"
-.\" -----
-.Sh DESCRIPTION
-The
-.Nm
-library provides an interface to kernel component of the NPF packet filter.
-.\" -----
-.Sh FUNCTIONS
-.Bl -tag -width 4n
-.\" ---
-.It Fn npfk_sysinit "nworkers"
-Initialize the NPF kernel component system.
-This must be called before starting the use of
-.Nm
-library.
-The
-.Fa nworkers
-parameter specifies how many worker threads should be spawned.
-The workers perform such operations as connection expiration and destruction
-amongst all the instances.
-.Pp
-Returns zero on success and the error number on failure.
-.\" ---
-.It Fn npfk_sysfini
-Destroy any resources used by the
-.Fm
-library, e.g. stop and exit the worker threads.
-This function must be called once finished using the component.
-.\" ---
-.It Fn npfk_create "flags" "mbufops" "ifops" "arg"
-Construct and return a new instance of the NPF kernel component.
-The parameter
-.Fa flags
-should be 0 or
-.Dv NPF_NO_GC .
-The
-.Dv NPF_NO_GC
-flag disables garbage collection of connections and other objects.
-.Pp
-The parameters
-.Fa mbufops
-and
-.Fa ifops
-specify the operation vectors, that is, structures containing the set of
-functions required to operate a network buffer (mbuf) or a network interface.
-This functions abstract the real representation and shall be provided by
-the caller.
-.Pp
-The
-.Fa arg
-parameter can be used to associate an arbitrary user context with an NPF
-instance, so that this value could later be obtained by the functions in
-the operation vectors.
-.Pp
-Returns a reference (pointer) to the instance on success and
-.Dv NULL
-on failure.
-.\" ---
-.It Fn npfk_gc "npf"
-Perform the garbage collection of connection and/or any other objects
-related to the specified NPF instance.
-This routine should only be used if the instance was created with
-.Dv NPF_NO_GC
-flag.
-.\" ---
-.It Fn npfk_destroy "npf"
-Destroy the instance of the NPF kernel component, freeing all resources
-used by it.
-.\" ---
-.It Fn npfk_load "npf" "ref" "err"
-Load a new configuration into the NPF instance.
-The new configuration is specified by the
-.Fa ref
-parameter.
-It is a reference to the configuration built by the
-.Fn npf_config_build
-function from the
-.Xr libnpf 3
-library.
-.Pp
-Returns zero on success and error number on failure.
-The configuration structure referenced by
-.Fa ref
-will be left unmodified.
-In a case of failure, additionally returns extra information in a
-structure specified by the
-.Fa err
-parameter.
-.\" ---
-.It Fn npfk_socket_load "npf" "sock"
-Load a new configuration into the NPF instance.
-The new configuration should be passed through a socket, specified by the
-.Fa sock
-parameter.
-It should be sent using the
-.Fn npf_config_submit
-function (with file descriptor being a socket) from the
-.Xr libnpf 3
-library.
-Returns zero on success and -1 on failure.
-.\" ---
-.It Fn npfk_thread_register "npf"
-Register a "processing context" i.e. a thread which will perform the
-.Fn npfk_packet_handler
-calls.
-All threads processing packets (invoking the handler) must register;
-all registered threads must also remove themselves from the register
-using before exit using the
-.Fa npfk_thread_unregister
-routine.
-Failure to register may result in undefined behaviour.
-.\" ---
-.It Fn npfk_thread_unregister "npf"
-Remove the thread from the register of threads which process the packets.
-.\" ---
-.It Fn npfk_packet_handler "npf" "mp" "ifp" "di"
-Inspect the packet, matching and processing it against the configuration
-loaded in the specified NPF instance.
-This is the main routine performing packet filtering (as well as any other
-operations).
-.Pp
-The packet is specified by the
-.Fa mp
-parameter.
-The NPF instance may destroy the packet and set this parameter to
-.Dv NULL .
-This is done on block, but may also be done on other operations (e.g.
-if the rule procedure decides to consume the packet).
-The network interface packet is passing-through is specified by the
-.Fa ifp
-parameter.
-The packet direction is specified by the
-.Fa di
-parameter and may be either
-.Dv PFIL_IN
-or
-.Dv PFIL_OUT .
-.Pp
-This function returns zero if the packet was "passed" and error number
-otherwise.
-A regular "block" is indicated by the
-.Dv ENETUNREACH
-error number.
-.\" ---
-.It Fn npfk_ifmap_attach "npf" "ifp"
-Attach the virtual network interface to the NPF instance.
-This indicates that the packets on this interface shall be processed.
-.It Fn npfk_ifmap_detach "npf" "ifp"
-Detach the virtual network interface from the NPF instance.
-.\" ---
-.It Fn npfk_param_get "npf" "name" "valp"
-Get the parameter value of the given NPF instance.
-On success, the function returns zero and the parameter value stored in
-.Fa valp .
-On failure, if the parameter does not exist, the function returns
-.Dv ENOENT .
-.\" ---
-.It Fn npfk_param_set "npf" "name" "val"
-Set the parameter vale for the given NPF instance.
-Returns zero on success or
-.Dv ENOENT
-if the parameter does not exist.
-.\" ---
-.It Fn npfk_stats "npf" "buf"
-Get the statistics of the NPF instance into the buffer specified by the
-.Fa buf
-parameter.
-.Pp
-The buffer should be an array of
-.Dv uint64_t
-integers having at least
-.Dv NPF_STATS_COUNT
-number of elements (or
-.Dv NPF_STATS_SIZE
-in bytes).
-.\" ---
-.It Fn npfk_stats_clear "npf"
-Clear (by resetting to zero) the statistics of the given NPF instance.
-.\" ---
-.El
-.\" -----
-.Sh SEE ALSO
-.Xr libnpf 3 ,
-.Xr bpf 4 ,
-.Xr bpfjit 4 ,
-.Xr npf.conf 5 ,
-.Xr pcap-filter 7 ,
-.Xr npfctl 8
-.Sh HISTORY
-NPF
-first appeared in
-.Nx 6.0 .
-.Sh AUTHORS
-NPF
-was designed and implemented by
-.An Mindaugas Rasiukevicius .
diff --git a/src/kern/npfkern.h b/src/kern/npfkern.h
deleted file mode 100644
index f9b518e..0000000
--- a/src/kern/npfkern.h
+++ /dev/null
@@ -1,113 +0,0 @@
-/*-
- * Copyright (c) 2015-2020 Mindaugas Rasiukevicius <rmind at netbsd org>
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#ifndef _NPFKERN_H_
-#define _NPFKERN_H_
-
-#ifndef _KERNEL
-#include <stdbool.h>
-#include <inttypes.h>
-#endif
-
-struct mbuf;
-struct ifnet;
-
-#if defined(_NPF_STANDALONE) || !defined(__NetBSD__)
-#define PFIL_IN		0x00000001	// incoming packet
-#define PFIL_OUT	0x00000002	// outgoing packet
-#endif
-
-#define	NPF_NO_GC	0x01
-
-typedef struct {
-	const char *	(*getname)(npf_t *, struct ifnet *);
-	struct ifnet *	(*lookup)(npf_t *, const char *);
-	void		(*flush)(npf_t *, void *);
-	void *		(*getmeta)(npf_t *, const struct ifnet *);
-	void		(*setmeta)(npf_t *, struct ifnet *, void *);
-} npf_ifops_t;
-
-typedef struct {
-	struct mbuf *	(*alloc)(npf_t *, unsigned, size_t);
-	void		(*free)(struct mbuf *);
-	void *		(*getdata)(const struct mbuf *);
-	struct mbuf *	(*getnext)(struct mbuf *);
-	size_t		(*getlen)(const struct mbuf *);
-	size_t		(*getchainlen)(const struct mbuf *);
-	bool		(*ensure_contig)(struct mbuf **, size_t);
-	bool		(*ensure_writable)(struct mbuf **, size_t);
-	int		(*get_tag)(const struct mbuf *, uint32_t *);
-	int		(*set_tag)(struct mbuf *, uint32_t);
-} npf_mbufops_t;
-
-int	npfk_sysinit(unsigned);
-void	npfk_sysfini(void);
-
-npf_t *	npfk_create(int, const npf_mbufops_t *, const npf_ifops_t *, void *);
-int	npfk_load(npf_t *, const void *, npf_error_t *);
-int	npfk_socket_load(npf_t *, int);
-void	npfk_gc(npf_t *);
-void	npfk_destroy(npf_t *);
-void *	npfk_getarg(npf_t *);
-
-void	npfk_thread_register(npf_t *);
-void	npfk_thread_unregister(npf_t *);
-
-int	npfk_packet_handler(npf_t *, struct mbuf **, struct ifnet *, int);
-
-void	npfk_ifmap_attach(npf_t *, struct ifnet *);
-void	npfk_ifmap_detach(npf_t *, struct ifnet *);
-
-int	npfk_param_get(npf_t *, const char *, int *);
-int	npfk_param_set(npf_t *, const char *, int);
-
-void	npfk_stats(npf_t *, uint64_t *);
-void	npfk_stats_clear(npf_t *);
-
-/*
- * Extensions.
- */
-
-int	npf_ext_log_init(npf_t *);
-int	npf_ext_log_fini(npf_t *);
-
-int	npf_ext_normalize_init(npf_t *);
-int	npf_ext_normalize_fini(npf_t *);
-
-int	npf_ext_rndblock_init(npf_t *);
-int	npf_ext_rndblock_fini(npf_t *);
-
-/*
- * ALGs.
- */
-
-int	npf_alg_icmp_init(npf_t *);
-int	npf_alg_icmp_fini(npf_t *);
-
-int	npf_alg_pptp_init(npf_t *);
-int	npf_alg_pptp_fini(npf_t *);
-
-#endif
diff --git a/src/kern/stand/bpf_filter.c b/src/kern/stand/bpf_filter.c
deleted file mode 100644
index d2487a2..0000000
--- a/src/kern/stand/bpf_filter.c
+++ /dev/null
@@ -1,851 +0,0 @@
-/*	$NetBSD: bpf_filter.c,v 1.70 2015/02/11 12:53:15 alnsn Exp $	*/
-
-/*-
- * Copyright (c) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from the Stanford/CMU enet packet filter,
- * (net/enet.c) distributed as part of 4.3BSD, and code contributed
- * to Berkeley by Steven McCanne and Van Jacobson both of Lawrence
- * Berkeley Laboratory.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- *	@(#)bpf_filter.c	8.1 (Berkeley) 6/10/93
- */
-
-#include <sys/cdefs.h>
-#if 0
-__KERNEL_RCSID(0, "$NetBSD: bpf_filter.c,v 1.70 2015/02/11 12:53:15 alnsn Exp $");
-
-#if !(defined(lint) || defined(KERNEL))
-static const char rcsid[] =
-    "@(#) Header: bpf_filter.c,v 1.33 97/04/26 13:37:18 leres Exp  (LBL)";
-#endif
-
-#include <sys/param.h>
-#include <sys/time.h>
-#include <sys/kmem.h>
-#include <sys/endian.h>
-#endif
-
-#define	__BPF_PRIVATE
-#include <net/bpf.h>
-
-/*
- * Provide the kernel API.
- */
-#include "npf_stand.h"
-
-#define	BPF_COP_EXTMEM_RELEASE
-#include <bpfjit.h>
-
-#if defined(_KERNEL) || defined(_NPF_STANDALONE)
-
-bpf_ctx_t *
-bpf_create(void)
-{
-	return kmem_zalloc(sizeof(bpf_ctx_t), KM_SLEEP);
-}
-
-void
-bpf_destroy(bpf_ctx_t *bc)
-{
-	kmem_free(bc, sizeof(bpf_ctx_t));
-}
-
-int
-bpf_set_cop(bpf_ctx_t *bc, const bpf_copfunc_t *funcs, size_t n)
-{
-	bc->copfuncs = funcs;
-	bc->nfuncs = n;
-	return 0;
-}
-
-int
-bpf_set_extmem(bpf_ctx_t *bc, size_t nwords, bpf_memword_init_t preinited)
-{
-	if (nwords > BPF_MAX_MEMWORDS || (preinited >> nwords) != 0) {
-		return EINVAL;
-	}
-	bc->extwords = nwords;
-	bc->preinited = preinited;
-	return 0;
-}
-
-bpfjit_func_t
-bpf_jit_generate(bpf_ctx_t *bc, void *code, size_t size)
-{
-	return bpfjit_generate_code(bc, code, size);
-}
-
-void
-bpf_jit_freecode(bpfjit_func_t func)
-{
-	bpfjit_free_code(func);
-}
-
-#endif
-
-#ifndef __NetBSD__
-static inline uint16_t
-be16dec(const void *buf)
-{
-	const uint8_t *p = (const uint8_t *)buf;
-
-	return ((p[0] << 8) | p[1]);
-}
-
-static inline uint32_t
-be32dec(const void *buf)
-{
-	const uint8_t *p = (const uint8_t *)buf;
-
-	return ((p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3]);
-}
-#endif
-
-#define EXTRACT_SHORT(p)	be16dec(p)
-#define EXTRACT_LONG(p)		be32dec(p)
-
-#ifdef _KERNEL
-#if 0
-#include <sys/mbuf.h>
-#endif
-#define MINDEX(len, m, k) 		\
-{					\
-	len = m->m_len; 		\
-	while (k >= (uint32_t)len) {	\
-		k -= len; 		\
-		m = m->m_next; 		\
-		if (m == 0) 		\
-			return 0; 	\
-		len = m->m_len; 	\
-	}				\
-}
-
-uint32_t m_xword(const struct mbuf *, uint32_t, int *);
-uint32_t m_xhalf(const struct mbuf *, uint32_t, int *);
-uint32_t m_xbyte(const struct mbuf *, uint32_t, int *);
-
-#define xword(p, k, err) m_xword((const struct mbuf *)(p), (k), (err))
-#define xhalf(p, k, err) m_xhalf((const struct mbuf *)(p), (k), (err))
-#define xbyte(p, k, err) m_xbyte((const struct mbuf *)(p), (k), (err))
-
-uint32_t
-m_xword(const struct mbuf *m, uint32_t k, int *err)
-{
-	int len;
-	u_char *cp, *np;
-	struct mbuf *m0;
-
-	*err = 1;
-	MINDEX(len, m, k);
-	cp = mtod(m, u_char *) + k;
-	if (len - k >= 4) {
-		*err = 0;
-		return EXTRACT_LONG(cp);
-	}
-	m0 = m->m_next;
-	if (m0 == 0 || (len - k) + m0->m_len < 4)
-		return 0;
-	*err = 0;
-	np = mtod(m0, u_char *);
-
-	switch (len - k) {
-	case 1:
-		return (cp[0] << 24) | (np[0] << 16) | (np[1] << 8) | np[2];
-	case 2:
-		return (cp[0] << 24) | (cp[1] << 16) | (np[0] << 8) | np[1];
-	default:
-		return (cp[0] << 24) | (cp[1] << 16) | (cp[2] << 8) | np[0];
-	}
-}
-
-uint32_t
-m_xhalf(const struct mbuf *m, uint32_t k, int *err)
-{
-	int len;
-	u_char *cp;
-	struct mbuf *m0;
-
-	*err = 1;
-	MINDEX(len, m, k);
-	cp = mtod(m, u_char *) + k;
-	if (len - k >= 2) {
-		*err = 0;
-		return EXTRACT_SHORT(cp);
-	}
-	m0 = m->m_next;
-	if (m0 == 0)
-		return 0;
-	*err = 0;
-	return (cp[0] << 8) | mtod(m0, u_char *)[0];
-}
-
-uint32_t
-m_xbyte(const struct mbuf *m, uint32_t k, int *err)
-{
-	int len;
-
-	*err = 1;
-	MINDEX(len, m, k);
-	*err = 0;
-	return mtod(m, u_char *)[k];
-}
-#else /* _KERNEL */
-#include <stdlib.h>
-#endif /* !_KERNEL */
-
-#include <net/bpf.h>
-
-/*
- * Execute the filter program starting at pc on the packet p
- * wirelen is the length of the original packet
- * buflen is the amount of data present
- */
-#if defined(_KERNEL) || defined(_NPF_STANDALONE)
-
-u_int
-bpf_filter(const struct bpf_insn *pc, const u_char *p, u_int wirelen,
-    u_int buflen)
-{
-	uint32_t mem[BPF_MEMWORDS];
-	bpf_args_t args = {
-		.pkt = p,
-		.wirelen = wirelen,
-		.buflen = buflen,
-		.mem = mem,
-		.arg = NULL
-	};
-
-	return bpf_filter_ext(NULL, pc, &args);
-}
-
-u_int
-bpf_filter_ext(const bpf_ctx_t *bc, const struct bpf_insn *pc, bpf_args_t *args)
-#else
-u_int
-bpf_filter(const struct bpf_insn *pc, const u_char *p, u_int wirelen,
-    u_int buflen)
-#endif
-{
-	uint32_t A, X, k;
-#if !defined(_KERNEL) && !defined(_NPF_STANDALONE)
-	uint32_t mem[BPF_MEMWORDS];
-	bpf_args_t args_store = {
-		.pkt = p,
-		.wirelen = wirelen,
-		.buflen = buflen,
-		.mem = mem,
-		.arg = NULL
-	};
-	bpf_args_t * const args = &args_store;
-#else
-	const uint8_t * const p = args->pkt;
-#endif
-	if (pc == 0) {
-		/*
-		 * No filter means accept all.
-		 */
-		return (u_int)-1;
-	}
-
-	/*
-	 * Note: safe to leave memwords uninitialised, as the validation
-	 * step ensures that it will not be read, if it was not written.
-	 */
-	A = 0;
-	X = 0;
-	--pc;
-
-	for (;;) {
-		++pc;
-		switch (pc->code) {
-
-		default:
-#ifdef _KERNEL
-			return 0;
-#else
-			abort();
-			/*NOTREACHED*/
-#endif
-		case BPF_RET|BPF_K:
-			return (u_int)pc->k;
-
-		case BPF_RET|BPF_A:
-			return (u_int)A;
-
-		case BPF_LD|BPF_W|BPF_ABS:
-			k = pc->k;
-			if (k > args->buflen ||
-			    sizeof(int32_t) > args->buflen - k) {
-#ifdef _KERNEL
-				int merr;
-
-				if (args->buflen != 0)
-					return 0;
-				A = xword(args->pkt, k, &merr);
-				if (merr != 0)
-					return 0;
-				continue;
-#else
-				return 0;
-#endif
-			}
-			A = EXTRACT_LONG(&p[k]);
-			continue;
-
-		case BPF_LD|BPF_H|BPF_ABS:
-			k = pc->k;
-			if (k > args->buflen ||
-			    sizeof(int16_t) > args->buflen - k) {
-#ifdef _KERNEL
-				int merr;
-
-				if (args->buflen != 0)
-					return 0;
-				A = xhalf(args->pkt, k, &merr);
-				if (merr != 0)
-					return 0;
-				continue;
-#else
-				return 0;
-#endif
-			}
-			A = EXTRACT_SHORT(&p[k]);
-			continue;
-
-		case BPF_LD|BPF_B|BPF_ABS:
-			k = pc->k;
-			if (k >= args->buflen) {
-#ifdef _KERNEL
-				int merr;
-
-				if (args->buflen != 0)
-					return 0;
-				A = xbyte(args->pkt, k, &merr);
-				if (merr != 0)
-					return 0;
-				continue;
-#else
-				return 0;
-#endif
-			}
-			A = p[k];
-			continue;
-
-		case BPF_LD|BPF_W|BPF_LEN:
-			A = args->wirelen;
-			continue;
-
-		case BPF_LDX|BPF_W|BPF_LEN:
-			X = args->wirelen;
-			continue;
-
-		case BPF_LD|BPF_W|BPF_IND:
-			k = X + pc->k;
-			if (k < X || k >= args->buflen ||
-			    sizeof(int32_t) > args->buflen - k) {
-#ifdef _KERNEL
-				int merr;
-
-				if (k < X || args->buflen != 0)
-					return 0;
-				A = xword(args->pkt, k, &merr);
-				if (merr != 0)
-					return 0;
-				continue;
-#else
-				return 0;
-#endif
-			}
-			A = EXTRACT_LONG(&p[k]);
-			continue;
-
-		case BPF_LD|BPF_H|BPF_IND:
-			k = X + pc->k;
-			if (k < X || k >= args->buflen ||
-			    sizeof(int16_t) > args->buflen - k) {
-#ifdef _KERNEL
-				int merr;
-
-				if (k < X || args->buflen != 0)
-					return 0;
-				A = xhalf(args->pkt, k, &merr);
-				if (merr != 0)
-					return 0;
-				continue;
-#else
-				return 0;
-#endif
-			}
-			A = EXTRACT_SHORT(&p[k]);
-			continue;
-
-		case BPF_LD|BPF_B|BPF_IND:
-			k = X + pc->k;
-			if (k < X || k >= args->buflen) {
-#ifdef _KERNEL
-				int merr;
-
-				if (k < X || args->buflen != 0)
-					return 0;
-				A = xbyte(args->pkt, k, &merr);
-				if (merr != 0)
-					return 0;
-				continue;
-#else
-				return 0;
-#endif
-			}
-			A = p[k];
-			continue;
-
-		case BPF_LDX|BPF_MSH|BPF_B:
-			k = pc->k;
-			if (k >= args->buflen) {
-#ifdef _KERNEL
-				int merr;
-
-				if (args->buflen != 0)
-					return 0;
-				X = (xbyte(args->pkt, k, &merr) & 0xf) << 2;
-				if (merr != 0)
-					return 0;
-				continue;
-#else
-				return 0;
-#endif
-			}
-			X = (p[pc->k] & 0xf) << 2;
-			continue;
-
-		case BPF_LD|BPF_IMM:
-			A = pc->k;
-			continue;
-
-		case BPF_LDX|BPF_IMM:
-			X = pc->k;
-			continue;
-
-		case BPF_LD|BPF_MEM:
-			A = args->mem[pc->k];
-			continue;
-
-		case BPF_LDX|BPF_MEM:
-			X = args->mem[pc->k];
-			continue;
-
-		case BPF_ST:
-			args->mem[pc->k] = A;
-			continue;
-
-		case BPF_STX:
-			args->mem[pc->k] = X;
-			continue;
-
-		case BPF_JMP|BPF_JA:
-			pc += pc->k;
-			continue;
-
-		case BPF_JMP|BPF_JGT|BPF_K:
-			pc += (A > pc->k) ? pc->jt : pc->jf;
-			continue;
-
-		case BPF_JMP|BPF_JGE|BPF_K:
-			pc += (A >= pc->k) ? pc->jt : pc->jf;
-			continue;
-
-		case BPF_JMP|BPF_JEQ|BPF_K:
-			pc += (A == pc->k) ? pc->jt : pc->jf;
-			continue;
-
-		case BPF_JMP|BPF_JSET|BPF_K:
-			pc += (A & pc->k) ? pc->jt : pc->jf;
-			continue;
-
-		case BPF_JMP|BPF_JGT|BPF_X:
-			pc += (A > X) ? pc->jt : pc->jf;
-			continue;
-
-		case BPF_JMP|BPF_JGE|BPF_X:
-			pc += (A >= X) ? pc->jt : pc->jf;
-			continue;
-
-		case BPF_JMP|BPF_JEQ|BPF_X:
-			pc += (A == X) ? pc->jt : pc->jf;
-			continue;
-
-		case BPF_JMP|BPF_JSET|BPF_X:
-			pc += (A & X) ? pc->jt : pc->jf;
-			continue;
-
-		case BPF_ALU|BPF_ADD|BPF_X:
-			A += X;
-			continue;
-
-		case BPF_ALU|BPF_SUB|BPF_X:
-			A -= X;
-			continue;
-
-		case BPF_ALU|BPF_MUL|BPF_X:
-			A *= X;
-			continue;
-
-		case BPF_ALU|BPF_DIV|BPF_X:
-			if (X == 0)
-				return 0;
-			A /= X;
-			continue;
-
-		case BPF_ALU|BPF_MOD|BPF_X:
-			if (X == 0)
-				return 0;
-			A %= X;
-			continue;
-
-		case BPF_ALU|BPF_AND|BPF_X:
-			A &= X;
-			continue;
-
-		case BPF_ALU|BPF_OR|BPF_X:
-			A |= X;
-			continue;
-
-		case BPF_ALU|BPF_XOR|BPF_X:
-			A ^= X;
-			continue;
-
-		case BPF_ALU|BPF_LSH|BPF_X:
-			A <<= X;
-			continue;
-
-		case BPF_ALU|BPF_RSH|BPF_X:
-			A >>= X;
-			continue;
-
-		case BPF_ALU|BPF_ADD|BPF_K:
-			A += pc->k;
-			continue;
-
-		case BPF_ALU|BPF_SUB|BPF_K:
-			A -= pc->k;
-			continue;
-
-		case BPF_ALU|BPF_MUL|BPF_K:
-			A *= pc->k;
-			continue;
-
-		case BPF_ALU|BPF_DIV|BPF_K:
-			A /= pc->k;
-			continue;
-
-		case BPF_ALU|BPF_MOD|BPF_K:
-			A %= pc->k;
-			continue;
-
-		case BPF_ALU|BPF_AND|BPF_K:
-			A &= pc->k;
-			continue;
-
-		case BPF_ALU|BPF_OR|BPF_K:
-			A |= pc->k;
-			continue;
-
-		case BPF_ALU|BPF_XOR|BPF_K:
-			A ^= pc->k;
-			continue;
-
-		case BPF_ALU|BPF_LSH|BPF_K:
-			A <<= pc->k;
-			continue;
-
-		case BPF_ALU|BPF_RSH|BPF_K:
-			A >>= pc->k;
-			continue;
-
-		case BPF_ALU|BPF_NEG:
-			A = -A;
-			continue;
-
-		case BPF_MISC|BPF_TAX:
-			X = A;
-			continue;
-
-		case BPF_MISC|BPF_TXA:
-			A = X;
-			continue;
-
-		case BPF_MISC|BPF_COP:
-#if defined(_KERNEL) || defined(_NPF_STANDALONE)
-			if (pc->k < bc->nfuncs) {
-				const bpf_copfunc_t fn = bc->copfuncs[pc->k];
-				A = fn(bc, args, A);
-				continue;
-			}
-#endif
-			return 0;
-
-		case BPF_MISC|BPF_COPX:
-#if defined(_KERNEL) || defined(_NPF_STANDALONE)
-			if (X < bc->nfuncs) {
-				const bpf_copfunc_t fn = bc->copfuncs[X];
-				A = fn(bc, args, A);
-				continue;
-			}
-#endif
-			return 0;
-		}
-	}
-}
-
-/*
- * Return true if the 'fcode' is a valid filter program.
- * The constraints are that each jump be forward and to a valid
- * code, that memory accesses are within valid ranges (to the
- * extent that this can be checked statically; loads of packet
- * data have to be, and are, also checked at run time), and that
- * the code terminates with either an accept or reject.
- *
- * The kernel needs to be able to verify an application's filter code.
- * Otherwise, a bogus program could easily crash the system.
- */
-
-#if defined(KERNEL) || defined(_KERNEL) || defined(_NPF_STANDALONE)
-
-int
-bpf_validate(const struct bpf_insn *f, int signed_len)
-{
-	return bpf_validate_ext(NULL, f, signed_len);
-}
-
-int
-bpf_validate_ext(const bpf_ctx_t *bc, const struct bpf_insn *f, int signed_len)
-#else
-int
-bpf_validate(const struct bpf_insn *f, int signed_len)
-#endif
-{
-	u_int i, from, len, ok = 0;
-	const struct bpf_insn *p;
-#if defined(KERNEL) || defined(_KERNEL) || defined(_NPF_STANDALONE)
-	bpf_memword_init_t *mem, invalid;
-	size_t size;
-	const size_t extwords = bc ? bc->extwords : 0;
-	const size_t memwords = extwords ? extwords : BPF_MEMWORDS;
-	const bpf_memword_init_t preinited = extwords ? bc->preinited : 0;
-#else
-	const size_t memwords = BPF_MEMWORDS;
-#endif
-
-	len = (u_int)signed_len;
-	if (len < 1)
-		return 0;
-#if defined(KERNEL) || defined(_KERNEL) || defined(_NPF_STANDALONE)
-	if (len > BPF_MAXINSNS)
-		return 0;
-#endif
-	if (f[len - 1].code != (BPF_RET|BPF_K) &&
-	    f[len - 1].code != (BPF_RET|BPF_A)) {
-		return 0;
-	}
-
-#if defined(KERNEL) || defined(_KERNEL) || defined(_NPF_STANDALONE)
-	/* Note: only the pre-initialised is valid on startup */
-	mem = kmem_zalloc(size = sizeof(*mem) * len, KM_SLEEP);
-	invalid = ~preinited;
-#endif
-
-	for (i = 0; i < len; ++i) {
-#if defined(KERNEL) || defined(_KERNEL) || defined(_NPF_STANDALONE)
-		/* blend in any invalid bits for current pc */
-		invalid |= mem[i];
-#endif
-		p = &f[i];
-		switch (BPF_CLASS(p->code)) {
-		/*
-		 * Check that memory operations use valid addresses.
-		 */
-		case BPF_LD:
-		case BPF_LDX:
-			switch (BPF_MODE(p->code)) {
-			case BPF_MEM:
-				/*
-				 * There's no maximum packet data size
-				 * in userland.  The runtime packet length
-				 * check suffices.
-				 */
-#if defined(KERNEL) || defined(_KERNEL) || defined(_NPF_STANDALONE)
-				/*
-				 * More strict check with actual packet length
-				 * is done runtime.
-				 */
-				if (p->k >= memwords)
-					goto out;
-				/* check for current memory invalid */
-				if (invalid & BPF_MEMWORD_INIT(p->k))
-					goto out;
-#endif
-				break;
-			case BPF_ABS:
-			case BPF_IND:
-			case BPF_MSH:
-			case BPF_IMM:
-			case BPF_LEN:
-				break;
-			default:
-				goto out;
-			}
-			break;
-		case BPF_ST:
-		case BPF_STX:
-			if (p->k >= memwords)
-				goto out;
-#if defined(KERNEL) || defined(_KERNEL) || defined(_NPF_STANDALONE)
-			/* validate the memory word */
-			invalid &= ~BPF_MEMWORD_INIT(p->k);
-#endif
-			break;
-		case BPF_ALU:
-			switch (BPF_OP(p->code)) {
-			case BPF_ADD:
-			case BPF_SUB:
-			case BPF_MUL:
-			case BPF_OR:
-			case BPF_XOR:
-			case BPF_AND:
-			case BPF_LSH:
-			case BPF_RSH:
-			case BPF_NEG:
-				break;
-			case BPF_DIV:
-			case BPF_MOD:
-				/*
-				 * Check for constant division by 0.
-				 */
-				if (BPF_SRC(p->code) == BPF_K && p->k == 0)
-					goto out;
-				break;
-			default:
-				goto out;
-			}
-			break;
-		case BPF_JMP:
-			/*
-			 * Check that jumps are within the code block,
-			 * and that unconditional branches don't go
-			 * backwards as a result of an overflow.
-			 * Unconditional branches have a 32-bit offset,
-			 * so they could overflow; we check to make
-			 * sure they don't.  Conditional branches have
-			 * an 8-bit offset, and the from address is <=
-			 * BPF_MAXINSNS, and we assume that BPF_MAXINSNS
-			 * is sufficiently small that adding 255 to it
-			 * won't overflow.
-			 *
-			 * We know that len is <= BPF_MAXINSNS, and we
-			 * assume that BPF_MAXINSNS is < the maximum size
-			 * of a u_int, so that i + 1 doesn't overflow.
-			 *
-			 * For userland, we don't know that the from
-			 * or len are <= BPF_MAXINSNS, but we know that
-			 * from <= len, and, except on a 64-bit system,
-			 * it's unlikely that len, if it truly reflects
-			 * the size of the program we've been handed,
-			 * will be anywhere near the maximum size of
-			 * a u_int.  We also don't check for backward
-			 * branches, as we currently support them in
-			 * userland for the protochain operation.
-			 */
-			from = i + 1;
-			switch (BPF_OP(p->code)) {
-			case BPF_JA:
-				if (from + p->k >= len)
-					goto out;
-#if defined(KERNEL) || defined(_KERNEL) || defined(_NPF_STANDALONE)
-				if (from + p->k < from)
-					goto out;
-				/*
-				 * mark the currently invalid bits for the
-				 * destination
-				 */
-				mem[from + p->k] |= invalid;
-				invalid = 0;
-#endif
-				break;
-			case BPF_JEQ:
-			case BPF_JGT:
-			case BPF_JGE:
-			case BPF_JSET:
-				if (from + p->jt >= len || from + p->jf >= len)
-					goto out;
-#if defined(KERNEL) || defined(_KERNEL) || defined(_NPF_STANDALONE)
-				/*
-				 * mark the currently invalid bits for both
-				 * possible jump destinations
-				 */
-				mem[from + p->jt] |= invalid;
-				mem[from + p->jf] |= invalid;
-				invalid = 0;
-#endif
-				break;
-			default:
-				goto out;
-			}
-			break;
-		case BPF_RET:
-			break;
-		case BPF_MISC:
-			switch (BPF_MISCOP(p->code)) {
-			case BPF_COP:
-			case BPF_COPX:
-				/* In-kernel COP use only. */
-#if defined(KERNEL) || defined(_KERNEL) || defined(_NPF_STANDALONE)
-				if (bc == NULL || bc->copfuncs == NULL)
-					goto out;
-				if (BPF_MISCOP(p->code) == BPF_COP &&
-				    p->k >= bc->nfuncs) {
-					goto out;
-				}
-				break;
-#else
-				goto out;
-#endif
-			default:
-				break;
-			}
-			break;
-		default:
-			goto out;
-		}
-	}
-	ok = 1;
-out:
-#if defined(KERNEL) || defined(_KERNEL) || defined(_NPF_STANDALONE)
-	kmem_free(mem, size);
-#endif
-	return ok;
-}
diff --git a/src/kern/stand/ebr_wrappers.c b/src/kern/stand/ebr_wrappers.c
deleted file mode 100644
index 65a0bb6..0000000
--- a/src/kern/stand/ebr_wrappers.c
+++ /dev/null
@@ -1,87 +0,0 @@
-/*-
- * Copyright (c) 2019 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include <sys/cdefs.h>
-#include <stdbool.h>
-#include <assert.h>
-
-#include <qsbr/ebr.h>
-
-#include "../npf_impl.h"
-
-/*
- * Epoch-Based Reclamation (EBR) wrappers.
- */
-
-ebr_t *
-npf_ebr_create(void)
-{
-	return ebr_create();
-}
-
-void
-npf_ebr_destroy(ebr_t *ebr)
-{
-	return ebr_destroy(ebr);
-}
-
-void
-npf_ebr_register(ebr_t *ebr)
-{
-	ebr_register(ebr);
-}
-
-void
-npf_ebr_unregister(ebr_t *ebr)
-{
-	ebr_unregister(ebr);
-}
-
-int
-npf_ebr_enter(ebr_t *ebr)
-{
-	ebr_enter(ebr);
-	return NPF_DIAG_MAGIC_VAL;
-}
-
-void
-npf_ebr_exit(ebr_t *ebr, int s)
-{
-	assert(s == NPF_DIAG_MAGIC_VAL);
-	ebr_exit(ebr);
-}
-
-void
-npf_ebr_full_sync(ebr_t *ebr)
-{
-	ebr_full_sync(ebr, 1);
-}
-
-bool
-npf_ebr_incrit_p(ebr_t *ebr)
-{
-	return ebr_incrit_p(ebr);
-}
diff --git a/src/kern/stand/murmurhash.c b/src/kern/stand/murmurhash.c
deleted file mode 100644
index a5b2312..0000000
--- a/src/kern/stand/murmurhash.c
+++ /dev/null
@@ -1,97 +0,0 @@
-/*	$NetBSD: murmurhash.c,v 1.6 2013/10/26 21:06:38 rmind Exp $	*/
-
-/*
- * MurmurHash2 -- from the original code:
- *
- * "MurmurHash2 was written by Austin Appleby, and is placed in the public
- * domain. The author hereby disclaims copyright to this source code."
- *
- * References:
- *	http://code.google.com/p/smhasher/
- *	https://sites.google.com/site/murmurhash/
- */
-
-#include <sys/cdefs.h>
-#include <sys/types.h>
-#include <endian.h>
-
-#include "npf_stand.h"
-
-#ifndef ALIGNED_POINTER
-#define	ALIGNED_POINTER(p,t)	((((uintptr_t)(p)) & (sizeof(t) - 1)) == 0)
-#endif
-
-uint32_t
-murmurhash2(const void *key, size_t len, uint32_t seed)
-{
-	/*
-	 * Note: 'm' and 'r' are mixing constants generated offline.
-	 * They're not really 'magic', they just happen to work well.
-	 * Initialize the hash to a 'random' value.
-	 */
-	const uint32_t m = 0x5bd1e995;
-	const int r = 24;
-
-	const uint8_t *data = key;
-	uint32_t h = seed ^ (uint32_t)len;
-
-	if (__predict_true(ALIGNED_POINTER(key, uint32_t))) {
-		while (len >= sizeof(uint32_t)) {
-			uint32_t k = *(const uint32_t *)(const void *)data;
-
-			k = htole32(k);
-
-			k *= m;
-			k ^= k >> r;
-			k *= m;
-
-			h *= m;
-			h ^= k;
-
-			data += sizeof(uint32_t);
-			len -= sizeof(uint32_t);
-		}
-	} else {
-		while (len >= sizeof(uint32_t)) {
-			uint32_t k;
-
-			k  = data[0];
-			k |= data[1] << 8;
-			k |= data[2] << 16;
-			k |= data[3] << 24;
-
-			k *= m;
-			k ^= k >> r;
-			k *= m;
-
-			h *= m;
-			h ^= k;
-
-			data += sizeof(uint32_t);
-			len -= sizeof(uint32_t);
-		}
-	}
-
-	/* Handle the last few bytes of the input array. */
-	switch (len) {
-	case 3:
-		h ^= data[2] << 16;
-		/* FALLTHROUGH */
-	case 2:
-		h ^= data[1] << 8;
-		/* FALLTHROUGH */
-	case 1:
-		h ^= data[0];
-		h *= m;
-	}
-
-	/*
-	 * Do a few final mixes of the hash to ensure the last few
-	 * bytes are well-incorporated.
-	 */
-	h ^= h >> 13;
-	h *= m;
-	h ^= h >> 15;
-
-	return h;
-}
diff --git a/src/kern/stand/net/bpf.h b/src/kern/stand/net/bpf.h
deleted file mode 100644
index e69de29..0000000
diff --git a/src/kern/stand/npf_stand.h b/src/kern/stand/npf_stand.h
index fac55cb..7c0b9d3 100644
--- a/src/kern/stand/npf_stand.h
+++ b/src/kern/stand/npf_stand.h
@@ -54,16 +54,11 @@
 #include <netinet/udp.h>
 #include <netinet/tcp.h>
 #include <arpa/inet.h>
-#if defined(__linux__)
 #include <net/ethernet.h>
-#endif
 
 #include <dnv.h>
 #include <nv.h>
 
-#include <qsbr/ebr.h>
-#include <thmap.h>
-#include <lpm.h>
 #include <cdbr.h>
 
 #include "cext.h"
@@ -482,10 +477,8 @@ typedef int modcmd_t;
 
 struct cpu_info { unsigned id; };
 
-#ifndef _IOWR
 #define	_IOR(g,n,t)		((n) - 100)
 #define	_IOW(g,n,t)		((n) - 100)
 #define	_IOWR(g,n,t)		((n) - 100)
-#endif
 
 #endif
diff --git a/src/kern/stand/npfkern.c b/src/kern/stand/npfkern.c
deleted file mode 100644
index 614578c..0000000
--- a/src/kern/stand/npfkern.c
+++ /dev/null
@@ -1,75 +0,0 @@
-/*-
- * Copyright (c) 2020 Mindaugas Rasiukevicius <rmind at netbsd org>
- * Copyright (c) 2015 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include <sys/types.h>
-#include <stdbool.h>
-#include <inttypes.h>
-
-#include "../npf_impl.h"
-#include "../npfkern.h"
-
-struct npf;
-
-/*
- * npfk_socket_load: receive the NPF configuration change request
- * and process it (e.g. (re)load the active configuration).
- *
- * => Returns 0 on success and -1 on error.
- * => Assumes a blocking socket.
- */
-__dso_public int
-npfk_socket_load(npf_t *npf, int sock)
-{
-	nvlist_t *req, *resp;
-	uint64_t op;
-	int error;
-
-	req = nvlist_recv(sock, 0);
-	if (__predict_false(req == NULL)) {
-		return -1;
-	}
-	resp = nvlist_create(0);
-	op = dnvlist_get_number(req, "operation", UINT64_MAX);
-	(void)npfctl_run_op(npf, op, req, resp);
-	nvlist_destroy(req);
-
-	error = nvlist_send(sock, resp);
-	nvlist_destroy(resp);
-	return error;
-}
-
-bool
-npf_active_p(void)
-{
-	return true;
-}
-
-void
-npf_ifaddr_syncall(struct npf *npf)
-{
-	(void)npf;
-}
diff --git a/src/kern/stand/tls_pth.c b/src/kern/stand/tls_pth.c
deleted file mode 100644
index c375c27..0000000
--- a/src/kern/stand/tls_pth.c
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Copyright (c) 2014 Mindaugas Rasiukevicius <rmind at noxt eu>
- * All rights reserved.
- *
- * Use is subject to license terms, as specified in the LICENSE file.
- */
-
-/*
- * Thread-local storage - a wrapper around the system interface.  See
- * tls.c source file for details.  This is as an alternative based on
- * the TLS support provided by the pthread(3) API.
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <pthread.h>
-
-#include "tls.h"
-#include "cext.h"
-
-struct tls_key {
-	pthread_key_t	key;
-	unsigned	size;
-};
-
-tls_key_t *
-tls_create(size_t size)
-{
-	tls_key_t *tk;
-
-	if ((tk = zalloc(sizeof(tls_key_t))) == NULL) {
-		return NULL;
-	}
-	if (pthread_key_create(&tk->key, free) != 0) {
-		free(tk);
-		return NULL;
-	}
-	ASSERT(size > 0);
-	tk->size = size;
-	return tk;
-}
-
-void *
-tls_get(tls_key_t *tk)
-{
-	void *obj;
-
-	obj = pthread_getspecific(tk->key);
-	if (__predict_false(obj == NULL)) {
-		obj = zalloc(tk->size);
-		pthread_setspecific(tk->key, obj);
-	}
-	return obj;
-}
-
-void
-tls_destroy(tls_key_t *tk)
-{
-	pthread_key_delete(tk->key);
-	free(tk);
-}
diff --git a/src/lib/Makefile b/src/lib/Makefile
deleted file mode 100644
index 869be3b..0000000
--- a/src/lib/Makefile
+++ /dev/null
@@ -1,16 +0,0 @@
-all:
-	make -C ext_log
-	make -C ext_normalize
-	make -C ext_rndblock
-
-install:
-	make -C ext_log install
-	make -C ext_normalize install
-	make -C ext_rndblock install
-
-clean:
-	make -C ext_log clean
-	make -C ext_normalize clean
-	make -C ext_rndblock clean
-
-.PHONY: all install clean
diff --git a/src/lib/ext.mk b/src/lib/ext.mk
deleted file mode 100644
index 54de011..0000000
--- a/src/lib/ext.mk
+++ /dev/null
@@ -1,76 +0,0 @@
-#
-# Generic Makefile for NPF extensions (npfctl part).
-# This file is in the Public Domain.
-#
-
-CFLAGS+=	-std=c99 -O2 -g -Wall -Wextra -Werror
-CFLAGS+=	-D_POSIX_C_SOURCE=200809L
-CFLAGS+=	-D_GNU_SOURCE -D_DEFAULT_SOURCE
-CFLAGS+=	-I. -D__RCSID\(x\)=
-
-CFLAGS+=	-I . -I ../../kern/stand -D__KERNEL_RCSID\(x,y\)=
-CFLAGS+=	-I ../../libnpf -D_NPF_STANDALONE
-
-#
-# Extended warning flags.
-#
-CFLAGS+=	-Wno-unknown-warning-option # gcc vs clang
-CFLAGS+=	-Wstrict-prototypes -Wmissing-prototypes -Wpointer-arith
-CFLAGS+=	-Wmissing-declarations -Wredundant-decls -Wnested-externs
-CFLAGS+=	-Wshadow -Wcast-qual -Wcast-align -Wwrite-strings
-CFLAGS+=	-Wold-style-definition
-CFLAGS+=	-Wsuggest-attribute=noreturn #-Wjump-misses-init
-CFLAGS+=	-Wduplicated-cond -Wmisleading-indentation -Wnull-dereference
-CFLAGS+=	-Wduplicated-branches -Wrestrict
-
-#
-# Standard vs debug build flags.
-#
-ifeq ($(DEBUG),1)
-CFLAGS+=	-Og -DDEBUG -fno-omit-frame-pointer
-CFLAGS+=	-fsanitize=address -fsanitize=undefined
-LDFLAGS+=	-fsanitize=address -fsanitize=undefined
-else
-CFLAGS+=	-DNDEBUG
-endif
-
-#
-# Linker flags.
-#
-
-LDFLAGS+=	-module
-LDFLAGS+=	-lnpf
-
-#
-# Flags for the library target
-#
-
-$(LIB).la:	LDFLAGS+=	-rpath $(LIBDIR) -version-info $(LIBVER)
-install/%.la:	ILIBDIR=	$(DESTDIR)/$(LIBDIR)/npf
-
-#
-# Targets
-#
-
-obj: $(OBJS)
-
-lib: $(LIB).la
-
-%.lo: %.c
-	libtool --mode=compile --tag CC $(CC) $(CFLAGS) -c $<
-
-$(LIB).la: $(shell echo $(OBJS) | sed 's/\.o/\.lo/g')
-	libtool --mode=link --tag CC $(CC) $(LDFLAGS) -o $@ $(notdir $^)
-
-install/%.la: %.la
-	mkdir -p $(ILIBDIR)
-	libtool --mode=install install -c $(notdir $@) $(ILIBDIR)/$(notdir $@)
-
-install: $(addprefix install/,$(LIB).la)
-	libtool --mode=finish $(LIBDIR)
-
-clean:
-	libtool --mode=clean rm
-	@ rm -rf .libs *.o *.lo *.la
-
-.PHONY: all obj lib install clean
diff --git a/src/lib/ext_log/Makefile b/src/lib/ext_log/Makefile
deleted file mode 100644
index 6ab339e..0000000
--- a/src/lib/ext_log/Makefile
+++ /dev/null
@@ -1,9 +0,0 @@
-#
-# This file is in the Public Domain.
-#
-
-LIB=		ext_log
-OBJS=		npfext_log.o
-LIBVER=		1:0:0
-
-include ../ext.mk
diff --git a/src/lib/ext_log/npfext_log.c b/src/lib/ext_log/npfext_log.c
deleted file mode 100644
index d47e6cd..0000000
--- a/src/lib/ext_log/npfext_log.c
+++ /dev/null
@@ -1,116 +0,0 @@
-/*-
- * Copyright (c) 2012 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * This code is derived from software contributed to The NetBSD Foundation
- * by Mindaugas Rasiukevicius.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include <sys/cdefs.h>
-__RCSID("$NetBSD$");
-
-#include <sys/types.h>
-#include <sys/socket.h>
-#include <sys/ioctl.h>
-#include <net/if.h>
-
-#include <stdio.h>
-#include <stdbool.h>
-#include <string.h>
-#include <assert.h>
-#include <errno.h>
-#include <err.h>
-#include <unistd.h>
-
-#include <npf.h>
-
-int		npfext_log_init(void);
-nl_ext_t *	npfext_log_construct(const char *);
-int		npfext_log_param(nl_ext_t *, const char *, const char *);
-
-int
-npfext_log_init(void)
-{
-	/* Nothing to initialise. */
-	return 0;
-}
-
-nl_ext_t *
-npfext_log_construct(const char *name)
-{
-	assert(strcmp(name, "log") == 0);
-	return npf_ext_construct(name);
-}
-
-int
-npfext_log_param(nl_ext_t *ext, const char *param, const char *val __unused)
-{
-	unsigned int if_idx;
-
-	assert(param != NULL);
-
-	if_idx = if_nametoindex(param);
-	if (if_idx == 0) {
-		int s;
-		struct ifreq ifr;
-		struct ifconf ifc;
-
-		if ((s = socket(PF_INET, SOCK_DGRAM, 0)) == -1) {
-			warn("Can't create datagram socket for `%s'", param);
-			return errno;
-		}
-
-#if defined(SIOCIFCREATE)
-		memset(&ifr, 0, sizeof(ifr));
-		strlcpy(ifr.ifr_name, param, sizeof(ifr.ifr_name));
-		if (ioctl(s, SIOCIFCREATE, &ifr) == -1) {
-			warn("Can't SIOCIFCREATE `%s'", param);
-			close(s);
-			return errno;
-		}
-#endif
-
-		memset(&ifc, 0, sizeof(ifc));
-		strlcpy(ifr.ifr_name, param, sizeof(ifr.ifr_name));
-		if (ioctl(s, SIOCGIFFLAGS, &ifr) == -1) {
-			warn("Can't SIOCGIFFLAGS `%s'", param);
-			close(s);
-			return errno;
-		}
-
-		ifr.ifr_flags |= IFF_UP;
-		if (ioctl(s, SIOCSIFFLAGS, &ifr) == -1) {
-			warn("Can't SIOCSIFFLAGS `%s'", param);
-			close(s);
-			return errno;
-		}
-		close(s);
-
-		if_idx = if_nametoindex(param);
-		if (if_idx == 0)
-			return EINVAL;
-	}
-	npf_ext_param_u32(ext, "log-interface", if_idx);
-	return 0;
-}
diff --git a/src/lib/ext_normalize/Makefile b/src/lib/ext_normalize/Makefile
deleted file mode 100644
index 0b4289a..0000000
--- a/src/lib/ext_normalize/Makefile
+++ /dev/null
@@ -1,9 +0,0 @@
-#
-# This file is in the Public Domain.
-#
-
-LIB=		ext_normalize
-OBJS=		npfext_normalize.o
-LIBVER=		1:0:0
-
-include ../ext.mk
diff --git a/src/lib/ext_normalize/npfext_normalize.c b/src/lib/ext_normalize/npfext_normalize.c
deleted file mode 100644
index d16bca3..0000000
--- a/src/lib/ext_normalize/npfext_normalize.c
+++ /dev/null
@@ -1,99 +0,0 @@
-/*-
- * Copyright (c) 2012 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include <sys/cdefs.h>
-__RCSID("$NetBSD$");
-
-#include <stdlib.h>
-#include <stdbool.h>
-#include <string.h>
-#include <assert.h>
-#include <errno.h>
-
-#include <npf.h>
-
-int		npfext_normalize_init(void);
-nl_ext_t *	npfext_normalize_construct(const char *);
-int		npfext_normalize_param(nl_ext_t *, const char *, const char *);
-
-int
-npfext_normalize_init(void)
-{
-	/* Nothing to initialize. */
-	return 0;
-}
-
-nl_ext_t *
-npfext_normalize_construct(const char *name)
-{
-	assert(strcmp(name, "normalize") == 0);
-	return npf_ext_construct(name);
-}
-
-int
-npfext_normalize_param(nl_ext_t *ext, const char *param, const char *val)
-{
-	enum ptype {
-		PARAM_BOOL,
-		PARAM_U32
-	};
-	static const struct param {
-		const char *	name;
-		enum ptype	type;
-		bool		reqval;
-	} params[] = {
-		{ "random-id",	PARAM_BOOL,	false	},
-		{ "no-df",	PARAM_BOOL,	false	},
-		{ "min-ttl",	PARAM_U32,	true	},
-		{ "max-mss",	PARAM_U32,	true	},
-	};
-
-	for (unsigned i = 0; i < __arraycount(params); i++) {
-		const char *name = params[i].name;
-
-		if (strcmp(name, param) != 0) {
-			continue;
-		}
-		if (val == NULL && params[i].reqval) {
-			return EINVAL;
-		}
-
-		switch (params[i].type) {
-		case PARAM_BOOL:
-			npf_ext_param_bool(ext, name, true);
-			break;
-		case PARAM_U32:
-			npf_ext_param_u32(ext, name, atol(val));
-			break;
-		default:
-			assert(false);
-		}
-		return 0;
-	}
-
-	/* Invalid parameter, if not found. */
-	return EINVAL;
-}
diff --git a/src/lib/ext_rndblock/Makefile b/src/lib/ext_rndblock/Makefile
deleted file mode 100644
index 84bfe93..0000000
--- a/src/lib/ext_rndblock/Makefile
+++ /dev/null
@@ -1,9 +0,0 @@
-#
-# This file is in the Public Domain.
-#
-
-LIB=		ext_rndblock
-OBJS=		npfext_rndblock.o
-LIBVER=		1:0:0
-
-include ../ext.mk
diff --git a/src/lib/ext_rndblock/npfext_rndblock.c b/src/lib/ext_rndblock/npfext_rndblock.c
deleted file mode 100644
index ea48cbf..0000000
--- a/src/lib/ext_rndblock/npfext_rndblock.c
+++ /dev/null
@@ -1,96 +0,0 @@
-/*-
- * Copyright (c) 2012 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include <sys/cdefs.h>
-__RCSID("$NetBSD$");
-
-#include <stdlib.h>
-#include <stdbool.h>
-#include <string.h>
-#include <assert.h>
-#include <errno.h>
-
-#include <npf.h>
-
-int		npfext_rndblock_init(void);
-nl_ext_t *	npfext_rndblock_construct(const char *);
-int		npfext_rndblock_param(nl_ext_t *, const char *, const char *);
-
-int
-npfext_rndblock_init(void)
-{
-	/* Nothing to initialise. */
-	return 0;
-}
-
-nl_ext_t *
-npfext_rndblock_construct(const char *name)
-{
-	assert(strcmp(name, "rndblock") == 0);
-	return npf_ext_construct(name);
-}
-
-int
-npfext_rndblock_param(nl_ext_t *ext, const char *param, const char *val)
-{
-	enum ptype { PARAM_U32 };
-	static const struct param {
-		const char *	name;
-		enum ptype	type;
-		signed long	min;
-		signed long	max;
-	} params[] = {
-		{ "mod",	PARAM_U32,	1,	LONG_MAX	},
-		{ "percentage",	PARAM_U32,	1,	9999		},
-	};
-
-	if (val == NULL) {
-		return EINVAL;
-	}
-	for (unsigned i = 0; i < __arraycount(params); i++) {
-		const char *name = params[i].name;
-		long ival;
-
-		if (strcmp(name, param) != 0) {
-			continue;
-		}
-
-		/*
-		 * Note: multiply by 100 and convert floating point to
-		 * an integer, as 100% is based on 10000 in the kernel.
-		 */
-		ival = (i == 1) ? atof(val) * 100 : atol(val);
-		if (ival < params[i].min || ival > params[i].max) {
-			return EINVAL;
-		}
-		assert(params[i].type == PARAM_U32);
-		npf_ext_param_u32(ext, name, ival);
-		return 0;
-	}
-
-	/* Invalid parameter, if not found. */
-	return EINVAL;
-}
diff --git a/src/libnpf/.gitignore b/src/libnpf/.gitignore
new file mode 100644
index 0000000..c5efd1f
--- /dev/null
+++ b/src/libnpf/.gitignore
@@ -0,0 +1,2 @@
+*.o
+libnpf.a
diff --git a/src/libnpf/Makefile b/src/libnpf/Makefile
index ef26ab6..3a99dff 100644
--- a/src/libnpf/Makefile
+++ b/src/libnpf/Makefile
@@ -3,13 +3,17 @@
 # This file is in the Public Domain.
 #
 
-CFLAGS+=	-std=c99 -O2 -g -Wall -Wextra -Werror
+CFLAGS+=	-std=c11 -Os -g -Wall -Wextra -Werror
 CFLAGS+=	-D_POSIX_C_SOURCE=200809L
 CFLAGS+=	-D_GNU_SOURCE -D_DEFAULT_SOURCE
 
-CFLAGS+=	-I . -I ../kern/stand -D__KERNEL_RCSID\(x,y\)=
+CFLAGS+=	-I . -I ../kern/stand
 CFLAGS+=	-D_NPF_STANDALONE
 
+CFLAGS+=    -I ../../../external
+CFLAGS+=    -I ../../../nvlist/src
+CFLAGS+=    -I ../../../libcdb/src
+
 #
 # Extended warning flags.
 #
@@ -21,68 +25,23 @@ CFLAGS+=	-Wshadow -Wcast-qual -Wcast-align -Wwrite-strings
 CFLAGS+=	-Wold-style-definition
 CFLAGS+=	-Wsuggest-attribute=noreturn #-Wjump-misses-init
 
-# New GCC 6/7 flags:
-#CFLAGS+=	-Wduplicated-cond -Wmisleading-indentation -Wnull-dereference
-#CFLAGS+=	-Wduplicated-branches -Wrestrict
-
-ifeq ($(DEBUG),1)
-CFLAGS+=	-Og -DDEBUG -fno-omit-frame-pointer
-CFLAGS+=	-fsanitize=address -fsanitize=undefined
-LDFLAGS+=	-fsanitize=address -fsanitize=undefined
-else
 CFLAGS+=	-DNDEBUG
-endif
-
-LDFLAGS=	-lnv -lcdb
 
-#
-# Objects to compile
-#
-
-ILIBDIR=	$(DESTDIR)/$(LIBDIR)
-IINCDIR=	$(DESTDIR)/$(INCDIR)
+#LDFLAGS=	-lnv -lcdb
 
 OBJS=		npf.o
-
-#
-# Flags for the library target
-#
-
 LIB=		libnpf
+DEPS=		npf.h
 
-INCS=		npf.h
-MANS=		libnpf.3
-
-$(LIB).la:	LDFLAGS+=	-rpath $(LIBDIR) -version-info 1:0:0
-install/%.la:	ILIBDIR=	$(DESTDIR)/$(LIBDIR)
-install:	IINCDIR=	$(DESTDIR)/$(INCDIR)
-install:	IMANDIR=	$(DESTDIR)/$(MANDIR)/man3/
-
-#
-# Targets
-#
+LDFLAGS+=	-version-info 1:0:0
 
-obj: $(OBJS)
+%.o: %.c $(DEPS)
+	$(CC) -c -o $@ $< $(CFLAGS)
 
-lib: $(LIB).la
+$(LIB).a: $(OBJS)
+	$(AR) rcs $(LIB).a $^
 
-%.lo: %.c
-	libtool --mode=compile --tag CC $(CC) $(CFLAGS) -c $<
-
-$(LIB).la: $(shell echo $(OBJS) | sed 's/\.o/\.lo/g')
-	libtool --mode=link --tag CC $(CC) $(LDFLAGS) -o $@ $(notdir $^)
-
-install/%.la: %.la
-	mkdir -p $(ILIBDIR)
-	libtool --mode=install install -c $(notdir $@) $(ILIBDIR)/$(notdir $@)
-
-install: $(addprefix install/,$(LIB).la)
-	libtool --mode=finish $(LIBDIR)
-	mkdir -p $(IINCDIR) && install -c $(INCS) $(IINCDIR)
-	mkdir -p $(IMANDIR) && install -c $(MANS) $(IMANDIR)
+lib: $(LIB).a
 
 clean:
-	libtool --mode=clean rm
-	@ rm -rf .libs *.o *.lo *.la
-
-.PHONY: all obj lib install clean
+	rm -rf *.o *.a
diff --git a/src/libnpf/npf.c b/src/libnpf/npf.c
index 34e7087..56bf21b 100644
--- a/src/libnpf/npf.c
+++ b/src/libnpf/npf.c
@@ -28,14 +28,10 @@
  */
 
 #include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD$");
 
 #include <sys/types.h>
 #include <sys/mman.h>
 #include <sys/stat.h>
-#if !defined(_NPF_STANDALONE)
-#include <sys/ioctl.h>
-#endif
 #include <netinet/in_systm.h>
 #include <netinet/in.h>
 #include <net/if.h>
@@ -229,6 +225,81 @@ _npf_extract_error(nvlist_t *resp, npf_error_t *errinfo)
 	return error;
 }
 
+
+
+
+
+#include <emscripten.h>
+
+EMSCRIPTEN_KEEPALIVE
+static int
+_npf_bstgw_post(const char *path, unsigned long cmd, nvlist_t *req, nvlist_t **resp)
+{
+	if (path == NULL) goto bstgwerr;
+
+	/*
+	 * Set the NPF version and operation.
+	 */
+	if (!nvlist_exists(req, "version")) {
+		nvlist_add_number(req, "version", NPF_VERSION);
+	}
+	nvlist_add_number(req, "operation", cmd);
+
+	if((nvlist_bstgw_post(path, req, resp, 0) == -1) || ((resp) && (*resp == NULL))) {
+		goto bstgwerr;
+	}
+
+	return 0;
+bstgwerr:
+	return errno ? errno : EIO;
+}
+
+static int
+_npf_bstgw_post_errno(const char *fd, unsigned long cmd, nvlist_t *req)
+{
+	nvlist_t *resp;
+	int error;
+
+	error = _npf_bstgw_post(fd, cmd, req, &resp);
+	if (error) {
+		return error;
+	}
+	error = _npf_extract_error(resp, NULL);
+	nvlist_destroy(resp);
+	return error;
+}
+
+
+
+/* bstgw_netif_list_retrieve: request description of netifs from NPF
+ *
+ * Returns the response nvlist on success.
+ * Returns NULL on failure.
+ */
+EMSCRIPTEN_KEEPALIVE
+nvlist_t *
+bstgw_netif_list_retrieve(const char *fd)
+{
+	assert(fd);
+
+	nvlist_t *req, *resp = NULL;
+	int error;
+
+	req = nvlist_create(0);
+	error = _npf_bstgw_post(fd, IOC_BSTGW_QUERY_NETIFS, req, &resp);
+	nvlist_destroy(req);
+
+	if (error || _npf_extract_error(resp, NULL) != 0) {
+		nvlist_destroy(resp);
+		return NULL;
+	}
+
+	return resp;
+}
+
+
+
+
 /*
  * npf_xfer_fd: transfer the given request and receive a response.
  *
@@ -236,30 +307,26 @@ _npf_extract_error(nvlist_t *resp, npf_error_t *errinfo)
  * => On success: returns 0 and valid nvlist in 'resp'.
  * => On failure: returns an error number.
  */
+/*
 static int
 _npf_xfer_fd(int fd, unsigned long cmd, nvlist_t *req, nvlist_t **resp)
 {
 	struct stat st;
 	int kernver;
 
-	/*
-	 * Set the NPF version and operation.
-	 */
+	 // Set the NPF version and operation.
 	if (!nvlist_exists(req, "version")) {
 		nvlist_add_number(req, "version", NPF_VERSION);
 	}
 	nvlist_add_number(req, "operation", cmd);
 
-	/*
-	 * Determine the type of file descriptor:
-	 * - If socket, then perform nvlist_send()/nvlist_recv().
-	 * - If a character device, then use ioctl.
-	 */
+	 // Determine the type of file descriptor:
+	 // - If socket, then perform nvlist_send()/nvlist_recv().
+	 // - If a character device, then use ioctl.
 	if (fstat(fd, &st) == -1) {
 		goto err;
 	}
 	switch (st.st_mode & S_IFMT) {
-#if !defined(__NetBSD__)
 	case S_IFSOCK:
 		if (nvlist_send(fd, req) == -1) {
 			goto err;
@@ -268,24 +335,7 @@ _npf_xfer_fd(int fd, unsigned long cmd, nvlist_t *req, nvlist_t **resp)
 			goto err;
 		}
 		break;
-#endif
-#if !defined(_NPF_STANDALONE)
-	case S_IFBLK:
-	case S_IFCHR:
-		if (ioctl(fd, IOC_NPF_VERSION, &kernver) == -1) {
-			goto err;
-		}
-		if (kernver != NPF_VERSION) {
-			errno = EPROGMISMATCH;
-			goto err;
-		}
-		if (nvlist_xfer_ioctl(fd, cmd, req, resp) == -1) {
-			goto err;
-		}
-		break;
-#else
 		(void)kernver;
-#endif
 	default:
 		errno = ENOTSUP;
 		goto err;
@@ -294,6 +344,7 @@ _npf_xfer_fd(int fd, unsigned long cmd, nvlist_t *req, nvlist_t **resp)
 err:
 	return errno ? errno : EIO;
 }
+*/
 
 /*
  * npf_xfer_fd_errno: same as npf_xfer_fd(), but:
@@ -302,6 +353,7 @@ err:
  *    the 'errno' value (if any) and returns it.
  * => Destroys the response.
  */
+/*
 static int
 _npf_xfer_fd_errno(int fd, unsigned long cmd, nvlist_t *req)
 {
@@ -316,6 +368,7 @@ _npf_xfer_fd_errno(int fd, unsigned long cmd, nvlist_t *req)
 	nvlist_destroy(resp);
 	return error;
 }
+*/
 
 /*
  * CONFIGURATION INTERFACE.
@@ -336,7 +389,7 @@ npf_config_create(void)
 }
 
 int
-npf_config_submit(nl_config_t *ncf, int fd, npf_error_t *errinfo)
+npf_config_submit(nl_config_t *ncf, const char *fd, npf_error_t *errinfo)
 {
 	nvlist_t *resp = NULL;
 	int error;
@@ -344,7 +397,8 @@ npf_config_submit(nl_config_t *ncf, int fd, npf_error_t *errinfo)
 	/* Ensure the config is built. */
 	(void)npf_config_build(ncf);
 
-	error = _npf_xfer_fd(fd, IOC_NPF_LOAD, ncf->ncf_dict, &resp);
+	error = _npf_bstgw_post(fd, IOC_NPF_LOAD, ncf->ncf_dict, &resp);
+//	error = _npf_xfer_fd(fd, IOC_NPF_LOAD, ncf->ncf_dict, &resp);
 	if (error) {
 		return error;
 	}
@@ -354,7 +408,7 @@ npf_config_submit(nl_config_t *ncf, int fd, npf_error_t *errinfo)
 }
 
 nl_config_t *
-npf_config_retrieve(int fd)
+npf_config_retrieve(const char *fd)
 {
 	nl_config_t *ncf;
 	nvlist_t *req, *resp = NULL;
@@ -366,7 +420,8 @@ npf_config_retrieve(int fd)
 	}
 
 	req = nvlist_create(0);
-	error = _npf_xfer_fd(fd, IOC_NPF_SAVE, req, &resp);
+	error = _npf_bstgw_post(fd, IOC_NPF_SAVE, req, &resp);
+//	error = _npf_xfer_fd(fd, IOC_NPF_SAVE, req, &resp);
 	nvlist_destroy(req);
 
 	if (error || _npf_extract_error(resp, NULL) != 0) {
@@ -404,7 +459,7 @@ npf_config_import(const void *blob, size_t len)
 }
 
 int
-npf_config_flush(int fd)
+npf_config_flush(const char *fd)
 {
 	nl_config_t *ncf;
 	npf_error_t errinfo;
@@ -546,7 +601,7 @@ _npf_nat_ruleset_p(const char *name)
 }
 
 int
-npf_ruleset_add(int fd, const char *rname, nl_rule_t *rl, uint64_t *id)
+npf_ruleset_add(const char *fd, const char *rname, nl_rule_t *rl, uint64_t *id)
 {
 	const bool natset = _npf_nat_ruleset_p(rname);
 	nvlist_t *rule_nvl = rl->rule_dict, *resp;
@@ -563,7 +618,8 @@ npf_ruleset_add(int fd, const char *rname, nl_rule_t *rl, uint64_t *id)
 	nvlist_add_bool(rule_nvl, "nat-ruleset", natset);
 	nvlist_add_number(rule_nvl, "command", NPF_CMD_RULE_ADD);
 
-	error = _npf_xfer_fd(fd, IOC_NPF_RULE, rule_nvl, &resp);
+	error = _npf_bstgw_post(fd, IOC_NPF_RULE, rule_nvl, &resp);
+//	error = _npf_xfer_fd(fd, IOC_NPF_RULE, rule_nvl, &resp);
 	if (error) {
 		return error;
 	}
@@ -573,7 +629,7 @@ npf_ruleset_add(int fd, const char *rname, nl_rule_t *rl, uint64_t *id)
 }
 
 int
-npf_ruleset_remove(int fd, const char *rname, uint64_t id)
+npf_ruleset_remove(const char *fd, const char *rname, uint64_t id)
 {
 	const bool natset = _npf_nat_ruleset_p(rname);
 	nvlist_t *rule_nvl = nvlist_create(0);
@@ -584,13 +640,14 @@ npf_ruleset_remove(int fd, const char *rname, uint64_t id)
 	nvlist_add_number(rule_nvl, "command", NPF_CMD_RULE_REMOVE);
 	nvlist_add_number(rule_nvl, "id", id);
 
-	error = _npf_xfer_fd_errno(fd, IOC_NPF_RULE, rule_nvl);
+	error = _npf_bstgw_post_errno(fd, IOC_NPF_RULE, rule_nvl);
+//	error = _npf_xfer_fd_errno(fd, IOC_NPF_RULE, rule_nvl);
 	nvlist_destroy(rule_nvl);
 	return error;
 }
 
 int
-npf_ruleset_remkey(int fd, const char *rname, const void *key, size_t len)
+npf_ruleset_remkey(const char *fd, const char *rname, const void *key, size_t len)
 {
 	const bool natset = _npf_nat_ruleset_p(rname);
 	nvlist_t *rule_nvl = nvlist_create(0);
@@ -601,13 +658,14 @@ npf_ruleset_remkey(int fd, const char *rname, const void *key, size_t len)
 	nvlist_add_number(rule_nvl, "command", NPF_CMD_RULE_REMKEY);
 	nvlist_add_binary(rule_nvl, "key", key, len);
 
-	error = _npf_xfer_fd_errno(fd, IOC_NPF_RULE, rule_nvl);
+	error = _npf_bstgw_post_errno(fd, IOC_NPF_RULE, rule_nvl);
+//	error = _npf_xfer_fd_errno(fd, IOC_NPF_RULE, rule_nvl);
 	nvlist_destroy(rule_nvl);
 	return error;
 }
 
 int
-npf_ruleset_flush(int fd, const char *rname)
+npf_ruleset_flush(const char *fd, const char *rname)
 {
 	const bool natset = _npf_nat_ruleset_p(rname);
 	nvlist_t *rule_nvl = nvlist_create(0);
@@ -617,7 +675,8 @@ npf_ruleset_flush(int fd, const char *rname)
 	nvlist_add_bool(rule_nvl, "nat-ruleset", natset);
 	nvlist_add_number(rule_nvl, "command", NPF_CMD_RULE_FLUSH);
 
-	error = _npf_xfer_fd_errno(fd, IOC_NPF_RULE, rule_nvl);
+	error = _npf_bstgw_post_errno(fd, IOC_NPF_RULE, rule_nvl);
+//	error = _npf_xfer_fd_errno(fd, IOC_NPF_RULE, rule_nvl);
 	nvlist_destroy(rule_nvl);
 	return error;
 }
@@ -843,7 +902,7 @@ npf_rule_getcode(nl_rule_t *rl, int *type, size_t *len)
 }
 
 int
-_npf_ruleset_list(int fd, const char *rname, nl_config_t *ncf)
+_npf_ruleset_list(const char *fd, const char *rname, nl_config_t *ncf)
 {
 	const bool natset = _npf_nat_ruleset_p(rname);
 	nvlist_t *req, *resp;
@@ -854,7 +913,8 @@ _npf_ruleset_list(int fd, const char *rname, nl_config_t *ncf)
 	nvlist_add_bool(req, "nat-ruleset", natset);
 	nvlist_add_number(req, "command", NPF_CMD_RULE_LIST);
 
-	error = _npf_xfer_fd(fd, IOC_NPF_RULE, req, &resp);
+	error = _npf_bstgw_post(fd, IOC_NPF_RULE, req, &resp);
+//	error = _npf_xfer_fd(fd, IOC_NPF_RULE, req, &resp);
 	nvlist_destroy(req);
 	if (error) {
 		return error;
@@ -1251,7 +1311,7 @@ npf_table_insert(nl_config_t *ncf, nl_table_t *tl)
 }
 
 int
-npf_table_replace(int fd, nl_table_t *tl, npf_error_t *errinfo)
+npf_table_replace(const char *fd, nl_table_t *tl, npf_error_t *errinfo)
 {
 	nvlist_t *resp = NULL;
 	int error;
@@ -1260,7 +1320,8 @@ npf_table_replace(int fd, nl_table_t *tl, npf_error_t *errinfo)
 	if ((error = _npf_table_build_const(tl)) != 0) {
 		return error;
 	}
-	error = _npf_xfer_fd(fd, IOC_NPF_TABLE_REPLACE, tl->table_dict, &resp);
+	error = _npf_bstgw_post(fd, IOC_NPF_TABLE_REPLACE, tl->table_dict, &resp);
+//	error = _npf_xfer_fd(fd, IOC_NPF_TABLE_REPLACE, tl->table_dict, &resp);
 	if (error) {
 		assert(resp == NULL);
 		return errno;
@@ -1341,6 +1402,7 @@ typedef struct {
 	in_port_t	port[3];
 } npf_connpoint_t;
 
+/*
 static int
 _npf_conn_lookup(int fd, const int af, npf_addr_t *addr[2], in_port_t port[2],
     unsigned proto, const char *ifname, unsigned di)
@@ -1349,9 +1411,9 @@ _npf_conn_lookup(int fd, const int af, npf_addr_t *addr[2], in_port_t port[2],
 	const nvlist_t *nat;
 	int error = EINVAL;
 
-	/*
-	 * Setup the connection lookup key.
-	 */
+	
+	 // Setup the connection lookup key.
+	 
 	if ((key_nv = nvlist_create(0)) == NULL) {
 		return ENOMEM;
 	}
@@ -1373,24 +1435,23 @@ _npf_conn_lookup(int fd, const int af, npf_addr_t *addr[2], in_port_t port[2],
 		nvlist_add_number(key_nv, "di", di);
 	}
 
-	/*
-	 * Setup the request.
-	 */
+	
+	// Setup the request.
+	 
 	if ((req = nvlist_create(0)) == NULL) {
 		error = ENOMEM;
 		goto out;
 	}
 	nvlist_move_nvlist(req, "key", key_nv);
 
-	/* Lookup: retrieve the connection entry. */
+	// Lookup: retrieve the connection entry.
 	error = _npf_xfer_fd(fd, IOC_NPF_CONN_LOOKUP, req, &resp);
 	if (error) {
 		goto out;
 	}
 
-	/*
-	 * Get the NAT entry and extract the translated pair.
-	 */
+	
+	 // Get the NAT entry and extract the translated pair.
 	if ((nat = dnvlist_get_nvlist(resp, "nat", NULL)) == NULL) {
 		error = ENOENT;
 		goto out;
@@ -1423,6 +1484,7 @@ npf_nat_lookup(int fd, int af, npf_addr_t *addr[2], in_port_t port[2],
 	port[0] = htons(port[0]); port[1] = htons(port[1]);
 	return error;
 }
+*/
 
 static bool
 npf_connkey_handle(const nvlist_t *key_nv, npf_connpoint_t *ep)
@@ -1471,7 +1533,7 @@ err:
 }
 
 int
-npf_conn_list(int fd, npf_conn_func_t func, void *arg)
+npf_conn_list(const char *fd, npf_conn_func_t func, void *arg)
 {
 	nl_config_t *ncf;
 	const nvlist_t * const *conns;
diff --git a/src/libnpf/npf.h b/src/libnpf/npf.h
index aab769f..2df8599 100644
--- a/src/libnpf/npf.h
+++ b/src/libnpf/npf.h
@@ -33,8 +33,6 @@
 #include <sys/types.h>
 #include <net/npf.h>
 
-__BEGIN_DECLS
-
 struct nl_config;
 struct nl_rule;
 struct nl_rproc;
@@ -77,25 +75,30 @@ typedef int (*npf_conn_func_t)(unsigned, const npf_addr_t *,
 
 nl_config_t *	npf_config_create(void);
 void		npf_config_destroy(nl_config_t *);
-int		npf_config_submit(nl_config_t *, int, npf_error_t *);
-nl_config_t *	npf_config_retrieve(int);
-int		npf_config_flush(int);
+int		npf_config_submit(nl_config_t *, const char *, npf_error_t *);
+nl_config_t *	npf_config_retrieve(const char *);
+int		npf_config_flush(const char *);
 nl_config_t *	npf_config_import(const void *, size_t);
 void *		npf_config_export(nl_config_t *, size_t *);
 bool		npf_config_active_p(nl_config_t *);
 bool		npf_config_loaded_p(nl_config_t *);
 const void *	npf_config_build(nl_config_t *);
 
+/* BSTGW */
+struct nvlist;
+struct nvlist * bstgw_netif_list_retrieve(const char *fd);
+/* */
+
 int		npf_alg_load(nl_config_t *, const char *);
 
 int		npf_param_get(nl_config_t *, const char *, int *);
 int		npf_param_set(nl_config_t *, const char *, int);
 const char *	npf_param_iterate(nl_config_t *, nl_iter_t *, int *, int *);
 
-int		npf_ruleset_add(int, const char *, nl_rule_t *, uint64_t *);
-int		npf_ruleset_remove(int, const char *, uint64_t);
-int		npf_ruleset_remkey(int, const char *, const void *, size_t);
-int		npf_ruleset_flush(int, const char *);
+int		npf_ruleset_add(const char *, const char *, nl_rule_t *, uint64_t *);
+int		npf_ruleset_remove(const char *, const char *, uint64_t);
+int		npf_ruleset_remkey(const char *, const char *, const void *, size_t);
+int		npf_ruleset_flush(const char *, const char *);
 
 nl_ext_t *	npf_ext_construct(const char *);
 void		npf_ext_param_u32(nl_ext_t *, const char *, uint32_t);
@@ -142,7 +145,7 @@ unsigned	npf_nat_getalgo(nl_nat_t *);
 int		npf_nat_insert(nl_config_t *, nl_nat_t *);
 int		npf_nat_lookup(int, int, npf_addr_t *[2], in_port_t [2], int, int);
 
-int		npf_conn_list(int, npf_conn_func_t, void *);
+int		npf_conn_list(const char *, npf_conn_func_t, void *);
 
 nl_table_t *	npf_table_create(const char *, unsigned, int);
 const char *	npf_table_getname(nl_table_t *);
@@ -153,7 +156,7 @@ int		npf_table_add_entry(nl_table_t *, int,
 int		npf_table_insert(nl_config_t *, nl_table_t *);
 void		npf_table_destroy(nl_table_t *);
 
-int		npf_table_replace(int, nl_table_t *, npf_error_t *);
+int		npf_table_replace(const char *, nl_table_t *, npf_error_t *);
 
 #ifdef _NPF_PRIVATE
 
@@ -164,12 +167,10 @@ nl_nat_t *	npf_nat_iterate(nl_config_t *, nl_iter_t *);
 nl_rproc_t *	npf_rproc_iterate(nl_config_t *, nl_iter_t *);
 nl_table_t *	npf_table_iterate(nl_config_t *, nl_iter_t *);
 
-int		_npf_ruleset_list(int, const char *, nl_config_t *);
+int		_npf_ruleset_list(const char *, const char *, nl_config_t *);
 void		_npf_debug_addif(nl_config_t *, const char *);
 void		_npf_config_dump(nl_config_t *, int);
 
 #endif
 
-__END_DECLS
-
 #endif	/* _NPF_LIB_H_ */
diff --git a/src/libnpf/pcap b/src/libnpf/pcap
new file mode 120000
index 0000000..1d23b8e
--- /dev/null
+++ b/src/libnpf/pcap
@@ -0,0 +1 @@
+/usr/include/pcap
\ No newline at end of file
diff --git a/src/npfctl/.gitignore b/src/npfctl/.gitignore
new file mode 100644
index 0000000..70ddd56
--- /dev/null
+++ b/src/npfctl/.gitignore
@@ -0,0 +1,3 @@
+*.o
+npf_parse.*
+npf_scan.c
diff --git a/src/npfctl/Makefile b/src/npfctl/Makefile
index a06c71d..dd071a2 100644
--- a/src/npfctl/Makefile
+++ b/src/npfctl/Makefile
@@ -5,12 +5,15 @@
 
 BIN=		npfctl
 
-CFLAGS+=	-std=gnu99 -O2 -g -Wall -Wextra -Werror
+CFLAGS+=	-std=gnu11 -Os -g -Wall -Wextra -Werror
 CFLAGS+=	-D_POSIX_C_SOURCE=200809L
 CFLAGS+=	-D_GNU_SOURCE -D_DEFAULT_SOURCE
-CFLAGS+=	-I. -D__RCSID\(x\)= -D__dead= -D__printflike\(x,y\)=
+CFLAGS+=	-I. -D__dead= -D__printflike\(x,y\)=
 CFLAGS+=	-Wno-unused-local-typedefs -Wno-unused-result
 
+CFLAGS+=    -I ../../../external
+CFLAGS+=    -I ../../../nvlist/src
+
 #
 # Extended warning flags.
 #
@@ -20,32 +23,23 @@ CFLAGS+=	-Wstrict-prototypes -Wmissing-prototypes -Wpointer-arith
 CFLAGS+=	-Wmissing-declarations #-Wredundant-decls -Wnested-externs
 CFLAGS+=	-Wshadow -Wcast-qual -Wcast-align -Wwrite-strings
 CFLAGS+=	-Wold-style-definition
-#CFLAGS+=	-Wsuggest-attribute=noreturn -Wjump-misses-init
-
-# New GCC 6/7 flags:
-#CFLAGS+=	-Wduplicated-cond -Wmisleading-indentation -Wnull-dereference
-#CFLAGS+=	-Wduplicated-branches -Wrestrict
+CFLAGS+=	-Wsuggest-attribute=noreturn -Wjump-misses-init
 
-ifeq ($(DEBUG),1)
-CFLAGS+=	-Og -DDEBUG -fno-omit-frame-pointer
-CFLAGS+=	-fsanitize=address -fsanitize=undefined
-LDFLAGS+=	-fsanitize=address -fsanitize=undefined
-else
 CFLAGS+=	-DNDEBUG
-endif
 
-LDFLAGS+=	-lnpf -lcrypto -lpcap
+LDFLAGS+=	-lnpf #-lcrypto -lpcap
+LDFLAGS+=	-lnv -lcdb # taken from libnpf
+
+LDFLAGS+=   -L ../libnpf
+LDFLAGS+=   -L ../../../libcdb/src
+LDFLAGS+=   -L ../../../nvlist/src
 
 #
 # System specific flags
 #
 
-SYSNAME:=	$(shell uname -s)
-
-ifeq ($(SYSNAME),Linux)
 CFLAGS+=	-Dgetprogname\(\)=\"$(BIN)\"
 LDFLAGS+=	-ldl
-endif
 
 #
 # Objects to compile and binary to produce.
@@ -54,34 +48,56 @@ endif
 OBJS=		npfctl.o npf_var.o npf_data.o npf_build.o npf_extmod.o
 OBJS+=		npf_bpf_comp.o npf_show.o npf_cmd.o
 OBJS+=		npf_parse.o npf_scan.o
+OBJS+=		sha1/sha1.o
+
+OBJS+=		npf_bstgw_ifs.o
+
+#JSLINK_FLAGS+= -Os
+
+# currently causes error: "Uncaught TypeError: Cannot read property 'currentScript' of undefined",
+# probably because document.currentScript is not defined in the worker (no <script> tag)
+#JSLINK_FLAGS+= -s ENVIRONMENT=web
 
-MAN5=		npf.conf.5
-MAN8=		npfctl.8
+#JSLINK_FLAGS+= -s EXTRA_EXPORTED_RUNTIME_METHODS='["callMain","ccall","cwrap",\
+			   "stackAlloc","allocateUTF8OnStack","stackSave","stackRestore"]'
+JSLINK_FLAGS+= -s EXTRA_EXPORTED_RUNTIME_METHODS='["cwrap","ccall"]'
 
-install:	IBINDIR=	$(DESTDIR)/$(BINDIR)
-install:	IMAN5DIR=	$(DESTDIR)/$(MANDIR)/man5/
-install:	IMAN8DIR=	$(DESTDIR)/$(MANDIR)/man8/
+JSLINK_FLAGS+= -s FETCH=1
+
+#JSLINK_FLAGS+= -s SINGLE_FILE=1
+
+ # for synchronous use of the Fetch API
+JSLINK_FLAGS+= --pre-js sjcl.js
+JSLINK_FLAGS+= --proxy-to-worker --pre-js bstgw_post_msg.js
+
+# alternative with threads (problem: callMain() doesn't seem to free the resouces,
+# s.t. 2-3 calls cause memory OOM);
+# and ccall() will just call in main thread as only main() is instrumented/replace;
+#JSLINK_FLAGS+= -s USE_PTHREADS=1 -s PROXY_TO_PTHREAD=1 -s PTHREAD_POOL_SIZE=2 # =1
 
 #
 # Targets
 #
 
 all: $(OBJS)
-	$(CC) $^ -o $(BIN) $(LDFLAGS)
+	$(CC) $^ -o $(BIN).js $(JSLINK_FLAGS) $(LDFLAGS)
+#	$(CC) $^ -o $(BIN).html $(JSLINK_FLAGS) $(LDFLAGS)
+	mkdir -p ../../../out
+	mv $(BIN).js $(BIN).worker.js $(BIN).wasm ../../../out/
+#	mv $(BIN).js $(BIN).worker.js $(BIN).wasm $(BIN).html ../../../out/
+
 
 npf_parse.c:
 	$(YACC) -d -o npf_parse.c npf_parse.y
 
-npf_scan.o:
+npf_scan.c:
 	$(LEX) -o npf_scan.c npf_scan.l
-	$(CC) $(CFLAGS) -Wno-sign-compare -c npf_scan.c -o npf_scan.o
 
-install:
-	mkdir -p $(IBINDIR) && install -c $(BIN) $(IBINDIR)
-	mkdir -p $(IMAN5DIR) && install -c $(MAN5) $(IMAN5DIR)
-	mkdir -p $(IMAN8DIR) && install -c $(MAN8) $(IMAN8DIR)
+npf_scan.o: npf_scan.c
+	$(CC) $(CFLAGS) -Wno-sign-compare -c npf_scan.c -o npf_scan.o
 
 clean:
-	rm -f $(BIN) *.o npf_parse.c npf_parse.h npf_scan.c
+	rm -f $(BIN) *.o sha1/*.o npf_parse.c npf_parse.h npf_scan.c
+	rm -rf ../../../out
 
-.PHONY: all install clean
+.PHONY: all clean
diff --git a/src/npfctl/bstgw_post_msg.js b/src/npfctl/bstgw_post_msg.js
new file mode 120000
index 0000000..095f5bc
--- /dev/null
+++ b/src/npfctl/bstgw_post_msg.js
@@ -0,0 +1 @@
+../../../pre-js/bstgw_post_msg.js
\ No newline at end of file
diff --git a/src/npfctl/npf.conf.5 b/src/npfctl/npf.conf.5
index b8759ba..3077f44 100644
--- a/src/npfctl/npf.conf.5
+++ b/src/npfctl/npf.conf.5
@@ -298,11 +298,6 @@ pass stateful in final family inet4 proto tcp flags S/SA \e
         apply \*qsomeproc\*q
 .Ed
 .Pp
-Alternatively, NPF supports
-.Xr pcap-filter 7
-syntax, for example:
-.Pp
-.Dl block out final pcap-filter \*qtcp and dst 10.1.1.252\*q
 .Pp
 Fragments are not selectable since NPF always reassembles packets
 before further processing.
@@ -598,7 +593,7 @@ npf-filter	= [ "family" family-opt ] [ proto ] ( "all" | filt-opts )
 static-rule	= ( "block" [ block-opts ] | "pass" )
 		  [ "stateful" | "stateful-all" ]
 		  [ "in" | "out" ] [ "final" ] [ "on" interface ]
-		  ( npf-filter | "pcap-filter" pcap-filter-expr )
+		  ( npf-filter )
 		  [ "apply" proc-name ]
 
 dynamic-ruleset	= "ruleset" group-opts
@@ -688,7 +683,6 @@ group default {
 .Xr bpf 4 ,
 .Xr npf 7 ,
 .Xr npf-params 7 ,
-.Xr pcap-filter 7 ,
 .Xr npfctl 8 ,
 .Xr npfd 8
 .Pp
diff --git a/src/npfctl/npf_bpf_comp.c b/src/npfctl/npf_bpf_comp.c
index 2f96c81..b5a88b0 100644
--- a/src/npfctl/npf_bpf_comp.c
+++ b/src/npfctl/npf_bpf_comp.c
@@ -82,7 +82,6 @@
  */
 
 #include <sys/cdefs.h>
-__RCSID("$NetBSD$");
 
 #include <stdlib.h>
 #include <stdbool.h>
diff --git a/src/npfctl/npf_bstgw_ifs.c b/src/npfctl/npf_bstgw_ifs.c
new file mode 100644
index 0000000..38dd198
--- /dev/null
+++ b/src/npfctl/npf_bstgw_ifs.c
@@ -0,0 +1,248 @@
+#include <stdlib.h>
+#include <string.h>
+
+#include "npfctl.h"
+
+struct bstgw_ifnet *
+bstgw_retrieve_netif_list(const char *fd) {
+	if(!fd) return NULL;
+
+	/* Request list from (remote) trusted router */
+	nvlist_t *nvl = bstgw_netif_list_retrieve(fd);
+	if(!nvl) return NULL;
+
+	/* Extract ifs_list from response */
+	if(!nvlist_exists_nvlist(nvl, "ifs_list")) {
+		nvlist_destroy(nvl);
+		return NULL;
+	}
+	const nvlist_t *descr_list = nvlist_get_nvlist(nvl, "ifs_list");
+
+	/* Parse ifs_list */
+	struct bstgw_ifnet *head = bstgw_parse_netif_list(descr_list);
+	nvlist_destroy(nvl);
+
+	return head;
+}
+
+void bstgw_free_netifs_chain(struct bstgw_ifnet *head) {
+	if(!head) return;
+	while(head) {
+		struct bstgw_ifnet *next = head->next;
+		free(head);
+		head = next;
+	}
+}
+
+static struct bstgw_ifnet *
+bstgw_build_ifnet(const char *if_name, unsigned long if_idx,
+	uint64_t if_fam, struct in_addr ip_addr) {
+
+	struct bstgw_ifnet *ifp = malloc(sizeof(struct bstgw_ifnet));
+	if(!ifp) {
+		fprintf(stderr, "OOM\n");
+		return NULL;
+	}
+	ifp->name = strdup(if_name);
+	if(!ifp->name) {
+		fprintf(stderr, "OOM\n");
+		free(ifp);
+		return NULL;
+	}
+
+	ifp->next = NULL;
+	ifp->if_idx = if_idx;
+
+	ifp->ip_addr = malloc(sizeof(struct sockaddr));
+	if(!ifp->ip_addr) {
+		fprintf(stderr, "OOM\n");
+		free(ifp->name);
+		free(ifp);
+		return NULL;
+	}
+	ifp->ip_addr->sin_family = if_fam;
+	ifp->ip_addr->sin_port = 0;
+	ifp->ip_addr->sin_addr = ip_addr;
+
+	return ifp;
+}
+
+/*
+ * netif nvlist {
+ * 	  name: 	 	str
+ * 	  idx:  	 	number
+ *    ip0:			nvlist {
+ *	    addr_type: 	number
+ *  	ip_addr_nbo:  number
+ * 	  }
+ *    ip1: ...
+ * 	  ...
+ * // trusted:   	bool
+ * // flags:		number (e.g. IFF_UP)
+ * }
+ *
+ * Returns *out_ifnet_cnt struct bstgw_ifnet objects chained together.
+ * One struct is created per IP address.
+ *
+ * FIXME: adapt struct bstgw_ifnet (and caller code) to hold all IPs
+ */
+#include <arpa/inet.h>
+#define BSTGW_NETIF_PARSE_DEBUG
+static struct bstgw_ifnet *
+bstgw_parse_netif_dev(const nvlist_t *descr, int *out_ifnet_cnt) {
+	if(!descr || !out_ifnet_cnt) return NULL;
+
+	struct bstgw_ifnet *ifnet_chain = NULL;
+	*out_ifnet_cnt = 0;
+
+	bool valid = true;
+	valid &= nvlist_exists_string(descr, "name");
+	valid &= nvlist_exists_number(descr, "idx");
+	if(!valid) return NULL;
+
+	// warning: this is not a copy
+	const char *if_name = nvlist_get_string(descr, "name");
+
+	// TODO: type conversions?
+	uint64_t if_idx = nvlist_get_number(descr, "idx");
+
+#ifdef BSTGW_NETIF_PARSE_DEBUG
+	/* Debug Prints */
+	printf("Netif Description:\n");
+	printf("\tif_name: %s\n", if_name);
+	printf("\tif_idx: %llu\n", if_idx);
+#endif
+
+	void *cookie = NULL;
+	int type;
+	const char *name;
+
+	// Go through list of ips
+	while ( (name = nvlist_next(descr, &type, &cookie)) != NULL ) {
+		// skip non-IPs (shared by all, already parsed)
+		if( strcmp("name", name) == 0 ) continue;
+		if( strcmp("idx", name) == 0 )  continue;
+
+		const nvlist_t *next_ip;
+		struct bstgw_ifnet *ifp;
+
+		switch (type) {
+			case NV_TYPE_NVLIST:
+				next_ip = nvlist_get_nvlist(descr, name);
+
+				valid = true & nvlist_exists_number(next_ip, "addr_type");
+				valid &= nvlist_exists_number(next_ip, "ip_addr_nbo");
+				if (!valid) {
+					fprintf(stderr, "Invalid IP address description");
+					break;
+				}
+
+				// TODO: type conversions?
+				uint64_t if_fam = nvlist_get_number(next_ip, "addr_type");
+				uint32_t if_ip4 = (uint32_t)nvlist_get_number(next_ip, "ip_addr_nbo");
+
+#ifdef BSTGW_NETIF_PARSE_DEBUG
+				/* Debug Prints */
+				printf("Netif Address:\n");
+				printf("\tif_fam: %llu (%s)\n", if_fam, if_fam == AF_INET ? "AF_INET" : "unknown");
+#endif
+
+				struct in_addr ip_addr = {
+					.s_addr = if_ip4,
+				};
+
+				char ip4[INET_ADDRSTRLEN];
+				if(inet_ntop(if_fam, &ip_addr, (char *)ip4, INET_ADDRSTRLEN)) {
+#ifdef BSTGW_NETIF_PARSE_DEBUG
+					printf("\tif_ip4: %s\n", (char *)ip4);
+#endif
+				} else {
+					fprintf(stderr, "ip4 conversion failed\n");
+					break;
+				}
+
+				// build struct
+				ifp = bstgw_build_ifnet(if_name, if_idx,
+					if_fam, ip_addr);
+				if(!ifp) {
+					fprintf(stderr, "ifnet entry creation failed\n");
+					break;
+				}
+
+				// add to front of list
+				ifp->next = ifnet_chain;
+				ifnet_chain = ifp;
+				*out_ifnet_cnt += 1;
+				break;
+
+			default:
+				fprintf(stderr, "Invalid field type (expected IP addr nvlist)");
+				break;
+		}
+	}
+
+	return ifnet_chain;
+}
+
+/*
+ * nvlist {
+ *    "ifs_list":	null
+ * 	  <netif_name>: nvlist
+ *    <netif_name>: nvlist
+ * }
+ */
+struct bstgw_ifnet * bstgw_parse_netif_list(const nvlist_t *descr_list) {
+	if(!descr_list) {
+		fprintf(stderr, "descriptor list object is NULL\n");
+		return NULL;
+	}
+
+	// Check that it's an ifs_list
+	if(!nvlist_exists_null(descr_list, "ifs_list")) {
+		fprintf(stderr, "ifs_list entry is missing\n");
+		return NULL;
+	}
+
+	struct bstgw_ifnet *ifp_head = NULL;
+
+	void *cookie = NULL;
+	int type;
+	const char *name;
+	// Go through list of netifs
+	while ( (name = nvlist_next(descr_list, &type, &cookie)) != NULL ) {
+		struct bstgw_ifnet *ifp_next;
+		/* try to parse a single netif */
+		switch (type) {
+			case NV_TYPE_NVLIST: {
+				const nvlist_t *descr = nvlist_get_nvlist(descr_list, name);
+				int ifp_cnt = 0;
+				if(! (ifp_next = bstgw_parse_netif_dev(descr, &ifp_cnt)) ) {
+					fprintf(stderr, "Failed parsing an interface entry (%s). Going to ignore it.\n", name);
+					continue;
+				}
+				// find end of new chain
+				struct bstgw_ifnet *tmp, *last_entry = ifp_next;
+				for ( ; last_entry->next != NULL ; ) {
+					tmp = last_entry;
+				    last_entry = tmp->next;
+				}
+				// add new chain to front of existing list
+				last_entry->next = ifp_head;
+				ifp_head = ifp_next;
+				break;
+			}
+			case NV_TYPE_NULL: {
+				if(strcmp(name, "ifs_list") == 0) continue;
+				/* fall-through */
+			}
+			default: {
+				// everything else is an unexpected error
+				fprintf(stderr, "Unexpected field in ifnet_list\n");
+				fprintf(stderr, "Violating field name: %s, of type: %d", name, type);
+				continue;
+			}
+		}
+	}
+
+	return ifp_head;
+}
diff --git a/src/npfctl/npf_build.c b/src/npfctl/npf_build.c
index fcf7fee..4136efb 100644
--- a/src/npfctl/npf_build.c
+++ b/src/npfctl/npf_build.c
@@ -31,8 +31,9 @@
  * npfctl(8) building of the configuration.
  */
 
+/* Note: we currently dropped libpcap syntax support to avoid the libpcap linking dependency */
+
 #include <sys/cdefs.h>
-__RCSID("$NetBSD$");
 
 #include <sys/types.h>
 #define	__FAVOR_BSD
@@ -112,7 +113,7 @@ npfctl_config_build(void)
 }
 
 int
-npfctl_config_send(int fd)
+npfctl_config_send(const char *fd)
 {
 	npf_error_t errinfo;
 	int error = 0;
@@ -524,26 +525,6 @@ npfctl_build_code(nl_rule_t *rl, sa_family_t family, const npfvar_t *popts,
 	return true;
 }
 
-static void
-npfctl_build_pcap(nl_rule_t *rl, const char *filter)
-{
-	const size_t maxsnaplen = 64 * 1024;
-	struct bpf_program bf;
-	size_t len;
-
-	if (pcap_compile_nopcap(maxsnaplen, DLT_RAW, &bf,
-	    filter, 1, PCAP_NETMASK_UNKNOWN) == -1) {
-		yyerror("invalid pcap-filter(7) syntax");
-	}
-	len = bf.bf_len * sizeof(struct bpf_insn);
-
-	if (npf_rule_setcode(rl, NPF_CODE_BPF, bf.bf_insns, len) != 0) {
-		errx(EXIT_FAILURE, "npf_rule_setcode failed");
-	}
-	npfctl_dump_bpf(&bf);
-	pcap_freecode(&bf);
-}
-
 static void
 npfctl_build_rpcall(nl_rproc_t *rp, const char *name, npfvar_t *args)
 {
@@ -703,7 +684,9 @@ npfctl_build_rule(uint32_t attr, const char *ifname, sa_family_t family,
 
 	rl = npf_rule_create(NULL, attr, ifname);
 	if (pcap_filter) {
-		npfctl_build_pcap(rl, pcap_filter);
+//		npfctl_build_pcap(rl, pcap_filter);
+		printf("ERROR: we currently dropped pcap syntax support\n");
+		abort();
 	} else {
 		npfctl_build_code(rl, family, popts, fopts);
 	}
@@ -1107,6 +1090,8 @@ npfctl_dump_bpf(struct bpf_program *bf)
 
 		int rule_line = yylineno - (int)(*yytext == '\n');
 		printf("\nRULE AT LINE %d\n", rule_line);
-		bpf_dump(bf, 0);
+//		bpf_dump(bf, 0); // would add unnecessary dependency on libpcap
+		(void)bf;
+		printf("NOTE: bpf_dump() is deactivated\n");
 	}
 }
diff --git a/src/npfctl/npf_cmd.c b/src/npfctl/npf_cmd.c
index 88cceaa..1f4df02 100644
--- a/src/npfctl/npf_cmd.c
+++ b/src/npfctl/npf_cmd.c
@@ -28,7 +28,6 @@
  */
 
 #include <sys/cdefs.h>
-__RCSID("$NetBSD$");
 
 #include <stdio.h>
 #include <string.h>
@@ -37,12 +36,7 @@ __RCSID("$NetBSD$");
 #include <errno.h>
 #include <err.h>
 
-#ifdef __NetBSD__
-#include <sha1.h>
-#define SHA_DIGEST_LENGTH SHA1_DIGEST_LENGTH
-#else
-#include <openssl/sha.h>
-#endif
+#include "sha1/sha1.h"
 
 #include "npfctl.h"
 
@@ -51,18 +45,16 @@ __RCSID("$NetBSD$");
 // NPFCTL RULE COMMANDS
 //
 
-#ifdef __NetBSD__
 static unsigned char *
 SHA1(const unsigned char *d, size_t l, unsigned char *md)
 {
-	SHA1_CTX c;
+    mbedtls_sha1_context c;
 
-	SHA1Init(&c);
-	SHA1Update(&c, d, l);
-	SHA1Final(md, &c);
-	return md;
+    mbedtls_sha1_init(&c);
+    mbedtls_sha1_update(&c, d, l);
+    mbedtls_sha1_finish(&c, md);
+    return md;
 }
-#endif
 
 static void
 npfctl_generate_key(nl_rule_t *rl, void *key)
@@ -105,7 +97,7 @@ npfctl_parse_rule(int argc, char **argv, parse_entry_t entry)
 }
 
 void
-npfctl_rule(int fd, int argc, char **argv)
+npfctl_rule(const char *fd, int argc, char **argv)
 {
 	static const struct ruleops_s {
 		const char *	cmd;
@@ -219,7 +211,7 @@ npfctl_table_type(const char *typename)
 }
 
 void
-npfctl_table_replace(int fd, int argc, char **argv)
+npfctl_table_replace(const char *fd, int argc, char **argv)
 {
 	const char *name, *newname, *path, *typename = NULL;
 	nl_config_t *ncf;
@@ -287,116 +279,6 @@ npfctl_table_replace(int fd, int argc, char **argv)
 	}
 }
 
-void
-npfctl_table(int fd, int argc, char **argv)
-{
-	static const struct tblops_s {
-		const char *	cmd;
-		int		action;
-	} tblops[] = {
-		{ "add",	NPF_CMD_TABLE_ADD		},
-		{ "rem",	NPF_CMD_TABLE_REMOVE		},
-		{ "del",	NPF_CMD_TABLE_REMOVE		},
-		{ "test",	NPF_CMD_TABLE_LOOKUP		},
-		{ "list",	NPF_CMD_TABLE_LIST		},
-		{ "flush",	NPF_CMD_TABLE_FLUSH		},
-		{ NULL,		0				}
-	};
-	npf_ioctl_table_t nct;
-	fam_addr_mask_t fam;
-	size_t buflen = 512;
-	char *cmd, *arg;
-	int n, alen;
-
-	/* Default action is list. */
-	memset(&nct, 0, sizeof(npf_ioctl_table_t));
-	nct.nct_name = argv[0];
-	cmd = argv[1];
-
-	for (n = 0; tblops[n].cmd != NULL; n++) {
-		if (strcmp(cmd, tblops[n].cmd) != 0) {
-			continue;
-		}
-		nct.nct_cmd = tblops[n].action;
-		break;
-	}
-	if (tblops[n].cmd == NULL) {
-		errx(EXIT_FAILURE, "invalid command '%s'", cmd);
-	}
-
-	switch (nct.nct_cmd) {
-	case NPF_CMD_TABLE_LIST:
-	case NPF_CMD_TABLE_FLUSH:
-		arg = NULL;
-		break;
-	default:
-		if (argc < 3) {
-			usage();
-		}
-		arg = argv[2];
-	}
-
-again:
-	switch (nct.nct_cmd) {
-	case NPF_CMD_TABLE_LIST:
-		nct.nct_data.buf.buf = ecalloc(1, buflen);
-		nct.nct_data.buf.len = buflen;
-		break;
-	case NPF_CMD_TABLE_FLUSH:
-		break;
-	default:
-		if (!npfctl_parse_cidr(arg, &fam, &alen)) {
-			errx(EXIT_FAILURE, "invalid CIDR '%s'", arg);
-		}
-		nct.nct_data.ent.alen = alen;
-		memcpy(&nct.nct_data.ent.addr, &fam.fam_addr, alen);
-		nct.nct_data.ent.mask = fam.fam_mask;
-	}
-
-	if (ioctl(fd, IOC_NPF_TABLE, &nct) != -1) {
-		errno = 0;
-	}
-	switch (errno) {
-	case 0:
-		break;
-	case EEXIST:
-		errx(EXIT_FAILURE, "entry already exists or is conflicting");
-	case ENOENT:
-		errx(EXIT_FAILURE, "not found");
-	case EINVAL:
-		errx(EXIT_FAILURE, "invalid address, mask or table ID");
-	case ENOMEM:
-		if (nct.nct_cmd == NPF_CMD_TABLE_LIST) {
-			/* XXX */
-			free(nct.nct_data.buf.buf);
-			buflen <<= 1;
-			goto again;
-		}
-		/* FALLTHROUGH */
-	default:
-		err(EXIT_FAILURE, "ioctl(IOC_NPF_TABLE)");
-	}
-
-	if (nct.nct_cmd == NPF_CMD_TABLE_LIST) {
-		npf_ioctl_ent_t *ent = nct.nct_data.buf.buf;
-		char *buf;
-
-		while (nct.nct_data.buf.len--) {
-			if (!ent->alen)
-				break;
-			buf = npfctl_print_addrmask(ent->alen, "%a",
-			    &ent->addr, ent->mask);
-			puts(buf);
-			ent++;
-		}
-		free(nct.nct_data.buf.buf);
-	} else {
-		printf("%s: %s\n", getprogname(),
-		    nct.nct_cmd == NPF_CMD_TABLE_LOOKUP ?
-		    "match" : "success");
-	}
-}
-
 ////////////////////////////////////////////////////////////////////////////
 //
 // NPFCTL CONNECTION COMMANDS
@@ -467,7 +349,7 @@ npfctl_conn_print(unsigned alen, const npf_addr_t *a, const in_port_t *p,
 }
 
 static void
-npf_conn_list_v(int fd, unsigned alen, npf_conn_filter_t *f)
+npf_conn_list_v(const char *fd, unsigned alen, npf_conn_filter_t *f)
 {
 	f->alen = alen;
 	f->v4 = alen == sizeof(struct in_addr);
@@ -478,7 +360,7 @@ npf_conn_list_v(int fd, unsigned alen, npf_conn_filter_t *f)
 }
 
 int
-npfctl_conn_list(int fd, int argc, char **argv)
+npfctl_conn_list(const char *fd, int argc, char **argv)
 {
 	npf_conn_filter_t f;
 	bool header = true;
diff --git a/src/npfctl/npf_data.c b/src/npfctl/npf_data.c
index e21bedc..4843475 100644
--- a/src/npfctl/npf_data.c
+++ b/src/npfctl/npf_data.c
@@ -29,7 +29,6 @@
  */
 
 #include <sys/cdefs.h>
-__RCSID("$NetBSD: npf_data.c,v 1.30 2019/01/19 21:19:32 rmind Exp $");
 
 #include <stdlib.h>
 #include <stddef.h>
@@ -55,12 +54,57 @@ __RCSID("$NetBSD: npf_data.c,v 1.30 2019/01/19 21:19:32 rmind Exp $");
 
 #include "npfctl.h"
 
-static struct ifaddrs *		ifs_list = NULL;
+static struct bstgw_ifnet * ifs_list = NULL;
+
+
+static int bstgw_update_ifs_list(void) {
+	if(ifs_list) {
+		bstgw_free_netifs_chain(ifs_list);
+		ifs_list = NULL;
+	}
+
+	const char *dst;
+	if (custom_bstgw_path == NULL) dst = NPF_BSTGW_PATH;
+	else dst = custom_bstgw_path;
+
+	struct bstgw_ifnet *head = bstgw_retrieve_netif_list(dst);
+	if(!head) return -1;
+	
+	ifs_list = head;
+	return 0;
+}
+
+static unsigned long bstgw_ifs_nametoindex(const char *ifname) {
+	if(!ifname) {
+		errno = ENODEV;
+		return 0;
+	}
+
+	if (!ifs_list && (bstgw_update_ifs_list() != 0)) {
+		errno = ENODEV;
+		fprintf(stderr, "Failed to fetch ifs_list, so cannot resolve index\n");
+		return 0;
+	}
+
+	struct bstgw_ifnet *ifa;
+	for (ifa = ifs_list; ifa != NULL; ifa = ifa->next) {
+		if(strcmp(ifname, ifa->name) == 0) return ifa->if_idx;
+	}
+
+	errno = ENODEV;
+	return 0;
+}
+
+
+
 
 void
 npfctl_note_interface(const char *ifname)
 {
-	unsigned long if_idx = if_nametoindex(ifname);
+	// TODO: need to adapt this function!
+	printf("npfctl_note_interface(%s);\n", ifname);
+
+	unsigned long if_idx = bstgw_ifs_nametoindex(ifname);
 	bool testif = npfctl_debug_addif(ifname);
 	const char *p = ifname;
 
@@ -95,7 +139,10 @@ err:
 static unsigned long
 npfctl_find_ifindex(const char *ifname)
 {
-	unsigned long if_idx = if_nametoindex(ifname);
+// TODO: need to adapt this function!
+	printf("npfctl_find_ifindex(%s);\n", ifname);
+
+	unsigned long if_idx = bstgw_ifs_nametoindex(ifname);
 	bool testif = npfctl_debug_addif(ifname);
 
 	if (!if_idx) {
@@ -146,6 +193,7 @@ npfctl_parse_fam_addr(const char *name, sa_family_t *fam, npf_addr_t *addr)
 	struct addrinfo *ai;
 	int ret;
 
+	// no need to change?
 	ret = getaddrinfo(name, NULL, &hint, &ai);
 	if (ret) {
 		yyerror("cannot parse '%s' (%s)", name, gai_strerror(ret));
@@ -327,12 +375,15 @@ npfctl_parse_port_range_variable(const char *v, npfvar_t *vp)
 npfvar_t *
 npfctl_parse_ifnet(const char *ifname, const int family)
 {
-	struct ifaddrs *ifa;
+	struct bstgw_ifnet *ifa;
 	ifnet_addr_t ifna;
 	npfvar_t *vpa;
 
-	if (ifs_list == NULL && getifaddrs(&ifs_list) == -1) {
-		err(EXIT_FAILURE, "getifaddrs");
+	// TODO: need to adapt this function!
+	printf("npfctl_parse_ifnet(%s, %d); -- will call getifaddrs()\n", ifname, family);
+
+	if (ifs_list == NULL && (bstgw_update_ifs_list() != 0)) {
+		err(EXIT_FAILURE, "bstgw_update_ifs_list");
 	}
 
 	vpa = npfvar_create();
@@ -341,17 +392,17 @@ npfctl_parse_ifnet(const char *ifname, const int family)
 	ifna.ifna_index = npfctl_find_ifindex(ifname);
 	assert(ifna.ifna_index != 0);
 
-	for (ifa = ifs_list; ifa != NULL; ifa = ifa->ifa_next) {
+	for (ifa = ifs_list; ifa != NULL; ifa = ifa->next) {
 		fam_addr_mask_t fam;
 		struct sockaddr *sa;
 
-		if (strcmp(ifa->ifa_name, ifname) != 0)
+		if (strcmp(ifa->name, ifname) != 0)
 			continue;
 
-		if ((ifa->ifa_flags & IFF_UP) == 0)
-			warnx("interface '%s' is down", ifname);
+		//if ((ifa->flags & IFF_UP) == 0)
+		//	warnx("interface '%s' is down", ifname);
 
-		sa = ifa->ifa_addr;
+		sa = (struct sockaddr *)ifa->ip_addr;
 		if (sa->sa_family != AF_INET && sa->sa_family != AF_INET6)
 			continue;
 		if (family != AF_UNSPEC && sa->sa_family != family)
@@ -438,6 +489,7 @@ npfctl_portno(const char *port)
 	in_port_t p = 0;
 	int e;
 
+	// port resolve, should be fine
 	e = getaddrinfo(NULL, port, NULL, &rai);
 	if (e != 0) {
 		yyerror("invalid port name '%s' (%s)", port, gai_strerror(e));
@@ -492,29 +544,7 @@ npfctl_parse_tcpflag(const char *s)
 uint8_t
 npfctl_icmptype(int proto, const char *type)
 {
-#ifdef __NetBSD__
-	uint8_t ul;
-
-	switch (proto) {
-	case IPPROTO_ICMP:
-		for (ul = 0; icmp_type[ul]; ul++)
-			if (strcmp(icmp_type[ul], type) == 0)
-				return ul;
-		break;
-	case IPPROTO_ICMPV6:
-		for (ul = 0; icmp6_type_err[ul]; ul++)
-			if (strcmp(icmp6_type_err[ul], type) == 0)
-				return ul;
-		for (ul = 0; icmp6_type_info[ul]; ul++)
-			if (strcmp(icmp6_type_info[ul], type) == 0)
-				return ul + 128;
-		break;
-	default:
-		assert(false);
-	}
-#else
 	(void)proto;
-#endif
 	yyerror("unknown icmp-type %s", type);
 	return ~0;
 }
@@ -522,92 +552,7 @@ npfctl_icmptype(int proto, const char *type)
 uint8_t
 npfctl_icmpcode(int proto, uint8_t type, const char *code)
 {
-#ifdef __NetBSD__
-	const char * const *arr;
-
-	switch (proto) {
-	case IPPROTO_ICMP:
-		switch (type) {
-		case ICMP_ECHOREPLY:
-		case ICMP_SOURCEQUENCH:
-		case ICMP_ALTHOSTADDR:
-		case ICMP_ECHO:
-		case ICMP_ROUTERSOLICIT:
-		case ICMP_TSTAMP:
-		case ICMP_TSTAMPREPLY:
-		case ICMP_IREQ:
-		case ICMP_IREQREPLY:
-		case ICMP_MASKREQ:
-		case ICMP_MASKREPLY:
-			arr = icmp_code_none;
-			break;
-		case ICMP_ROUTERADVERT:
-			arr = icmp_code_routeradvert;
-			break;
-		case ICMP_UNREACH:
-			arr = icmp_code_unreach;
-			break;
-		case ICMP_REDIRECT:
-			arr = icmp_code_redirect;
-			break;
-		case ICMP_TIMXCEED:
-			arr = icmp_code_timxceed;
-			break;
-		case ICMP_PARAMPROB:
-			arr = icmp_code_paramprob;
-			break;
-		case ICMP_PHOTURIS:
-			arr = icmp_code_photuris;
-			break;
-		default:
-			yyerror("unknown icmp-type %d while parsing code %s",
-				type, code);
-			return ~0;
-		}
-		break;
-	case IPPROTO_ICMPV6:
-		switch (type) {
-		case ICMP6_DST_UNREACH:
-			arr = icmp6_code_unreach;
-			break;
-		case ICMP6_TIME_EXCEEDED:
-			arr = icmp6_code_timxceed;
-			break;
-		case ICMP6_PARAM_PROB:
-			arr = icmp6_code_paramprob;
-			break;
-		case ICMP6_PACKET_TOO_BIG:
-		/* code-less info ICMPs */
-		case ICMP6_ECHO_REQUEST:
-		case ICMP6_ECHO_REPLY:
-		case MLD_LISTENER_QUERY:
-		case MLD_LISTENER_REPORT:
-		case MLD_LISTENER_DONE:
-		case ND_ROUTER_SOLICIT:
-		case ND_ROUTER_ADVERT:
-		case ND_NEIGHBOR_SOLICIT:
-		case ND_NEIGHBOR_ADVERT:
-		case ND_REDIRECT:
-			arr = icmp6_code_none;
-			break;
-		/* XXX TODO: info ICMPs with code values */
-		default:
-			yyerror("unknown icmp-type %d while parsing code %s",
-				type, code);
-			return ~0;
-		}
-		break;
-	default:
-		assert(false);
-	}
-
-	for (uint8_t ul = 0; arr[ul]; ul++) {
-		if (strcmp(arr[ul], code) == 0)
-			return ul;
-	}
-#else
 	(void)proto;
-#endif
 	yyerror("unknown code %s for icmp-type %d", code, type);
 	return ~0;
 }
diff --git a/src/npfctl/npf_extmod.c b/src/npfctl/npf_extmod.c
index f469ad2..d38db83 100644
--- a/src/npfctl/npf_extmod.c
+++ b/src/npfctl/npf_extmod.c
@@ -32,7 +32,6 @@
  */
 
 #include <sys/cdefs.h>
-__RCSID("$NetBSD: npf_extmod.c,v 1.5 2018/09/29 14:41:36 rmind Exp $");
 
 #include <stdlib.h>
 #include <inttypes.h>
diff --git a/src/npfctl/npf_parse.y b/src/npfctl/npf_parse.y
index d77f462..0c3d148 100644
--- a/src/npfctl/npf_parse.y
+++ b/src/npfctl/npf_parse.y
@@ -34,9 +34,6 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-#ifdef __NetBSD__
-#include <vis.h>
-#endif
 
 #include "npfctl.h"
 
@@ -46,7 +43,7 @@ int			yystarttoken;
 const char *		yyfilename;
 
 extern int		yylineno, yycolumn;
-extern int		yylex(int);
+extern int		yylex(void);
 
 void
 yyerror(const char *fmt, ...)
@@ -65,13 +62,6 @@ yyerror(const char *fmt, ...)
 	fprintf(stderr, "%s:%d:%d: %s", yyfilename,
 	    yylineno - (int)eol, yycolumn, msg);
 	if (!eol) {
-#ifdef __NetBSD__
-		size_t len = strlen(context);
-		char *dst = ecalloc(1, len * 4 + 1);
-
-		strvisx(dst, context, len, VIS_WHITE|VIS_CSTYLE);
-		context = dst;
-#endif
 		fprintf(stderr, " near '%s'", context);
 	}
 	fprintf(stderr, "\n");
@@ -92,7 +82,6 @@ yyerror(const char *fmt, ...)
  */
 %start input
 %token RULE_ENTRY_TOKEN MAP_ENTRY_TOKEN
-%lex-param { int yystarttoken }
 
 /*
  * General tokens.
diff --git a/src/npfctl/npf_scan.l b/src/npfctl/npf_scan.l
index 28bc5e9..3b1e287 100644
--- a/src/npfctl/npf_scan.l
+++ b/src/npfctl/npf_scan.l
@@ -145,7 +145,6 @@ interface		return INTERFACE;
 all			return ALL;
 block			return BLOCK;
 pass			return PASS;
-pcap-filter		return PCAP_FILTER;
 stateful		return STATEFUL;
 stateful-all		return STATEFUL_ALL;
 apply			return APPLY;
diff --git a/src/npfctl/npf_show.c b/src/npfctl/npf_show.c
index 8e88945..79f2580 100644
--- a/src/npfctl/npf_show.c
+++ b/src/npfctl/npf_show.c
@@ -34,7 +34,6 @@
  */
 
 #include <sys/cdefs.h>
-__RCSID("$NetBSD");
 
 #include <sys/socket.h>
 #define	__FAVOR_BSD
@@ -487,11 +486,9 @@ npfctl_print_filter(npf_conf_info_t *ctx, nl_rule_t *rl)
 	if (!marks && (code = npf_rule_getcode(rl, &type, &len)) != NULL) {
 		/*
 		 * No marks, but the byte-code is present.  This must
-		 * have been filled by libpcap(3) or possibly an unknown
-		 * to us byte-code.
+		 * have been filled by an unknown to us byte-code.
 		 */
-		ctx->fpos += fprintf(ctx->fp, "%s ", type == NPF_CODE_BPF ?
-		    "pcap-filter \"...\"" : "unrecognized-bytecode");
+		ctx->fpos += fprintf(ctx->fp, "%s ", "unrecognized-bytecode");
 		return true;
 	}
 	ctx->flags = 0;
@@ -685,7 +682,7 @@ npfctl_print_params(npf_conf_info_t *ctx, nl_config_t *ncf)
 }
 
 int
-npfctl_config_show(int fd)
+npfctl_config_show(const char *fd)
 {
 	npf_conf_info_t *ctx = npfctl_show_init();
 	nl_config_t *ncf;
@@ -753,7 +750,7 @@ npfctl_config_show(int fd)
 }
 
 int
-npfctl_ruleset_show(int fd, const char *ruleset_name)
+npfctl_ruleset_show(const char *fd, const char *ruleset_name)
 {
 	npf_conf_info_t *ctx = npfctl_show_init();
 	nl_config_t *ncf;
diff --git a/src/npfctl/npf_var.c b/src/npfctl/npf_var.c
index c4ee672..e5cbee9 100644
--- a/src/npfctl/npf_var.c
+++ b/src/npfctl/npf_var.c
@@ -34,7 +34,6 @@
  */
 
 #include <sys/cdefs.h>
-__RCSID("$NetBSD$");
 
 #include <stdlib.h>
 #include <string.h>
diff --git a/src/npfctl/npfctl.8 b/src/npfctl/npfctl.8
index 5103421..4a11708 100644
--- a/src/npfctl/npfctl.8
+++ b/src/npfctl/npfctl.8
@@ -50,14 +50,6 @@ The first argument,
 specifies the action to take.
 Valid commands are:
 .Bl -tag -width reload -offset 3n
-.It Ic start
-Enable packet inspection using the currently loaded configuration, if any.
-Note that this command does not load or reload the configuration,
-or affect existing connections.
-.It Ic stop
-Disable packet inspection.
-This command does not change the currently loaded configuration,
-or affect existing connections.
 .It Ic reload Op Ar path
 Load or reload configuration from file.
 The configuration file at
@@ -118,28 +110,6 @@ List all rules in the dynamic ruleset specified by
 Remove all rules from the dynamic ruleset specified by
 .Ar name .
 .\" ---
-.It Ic table Ar name Ic add Aq Ar addr/mask
-In table
-.Ar name ,
-add the IP address and optionally netmask, specified by
-.Aq Ar addr/mask .
-Only the tables of type "lpm" support masks.
-.It Ic table Ar name Ic rem Aq Ar addr/mask
-In table
-.Ar name ,
-remove the IP address and optionally netmask, specified by
-.Aq Ar addr/mask .
-Only the tables of type "lpm" support masks.
-.It Ic table Ar name Ic test Aq Ar addr
-Query the table
-.Ar name
-for a specific IP address, specified by
-.Ar addr .
-If no mask is specified, a single host is assumed.
-.It Ic table Ar name Ic list
-List all entries in the currently loaded table specified by
-.Ar name .
-This operation is expensive and should be used with caution.
 .It Ic table Ar name Ic replace Oo Fl n Ar newname Oc Oo Fl t Ar type Oc Aq Ar path
 Replace the existing table specified by
 .Ar name
@@ -169,13 +139,9 @@ The data will be stored in the
 .Pa /var/db/npf.db
 file unless a file is specified by
 .Ar path .
-Administrator may want to stop the packet inspection before saving.
 .It Ic load
 Load the saved configuration file and the connections from the file.
 Note that any existing connections will be destroyed.
-Administrator may want to start packet inspection after the load.
-.It Ic stats
-Print various statistics.
 .It Ic debug ( Fl a | Fl b Ar binary-config | Fl c Ar config ) \
 Oo Fl o Ar outfile Oc
 Process the active configuration (if
@@ -230,16 +196,9 @@ default configuration file
 Starting the NPF packet filter:
 .Bd -literal -offset indent
 # npfctl reload
-# npfctl start
 # npfctl show
 .Ed
 .Pp
-Addition and removal of entries in the table whose ID is "vip":
-.Bd -literal -offset indent
-# npfctl table "vip" add 10.0.0.1
-# npfctl table "vip" rem 182.168.0.0/24
-.Ed
-.Pp
 Replacing the existing table which has ID "svr"
 with a new const table populated from file "/tmp/npf_vps_new",
 and renamed to "vps":
diff --git a/src/npfctl/npfctl.c b/src/npfctl/npfctl.c
index affba1c..ce75ebe 100644
--- a/src/npfctl/npfctl.c
+++ b/src/npfctl/npfctl.c
@@ -28,16 +28,12 @@
  */
 
 #include <sys/cdefs.h>
-__RCSID("$NetBSD$");
 
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <sys/socket.h>
 #include <sys/mman.h>
 #include <sys/un.h>
-#ifdef __NetBSD__
-#include <sys/module.h>
-#endif
 
 #include <stdio.h>
 #include <string.h>
@@ -49,20 +45,22 @@ __RCSID("$NetBSD$");
 
 #include "npfctl.h"
 
+#include <emscripten.h>
+
+char *custom_bstgw_path = NULL;
+
 enum {
-	NPFCTL_START,
-	NPFCTL_STOP,
 	NPFCTL_RELOAD,
 	NPFCTL_SHOWCONF,
 	NPFCTL_FLUSH,
 	NPFCTL_VALIDATE,
 	NPFCTL_TABLE,
 	NPFCTL_RULE,
-	NPFCTL_STATS,
 	NPFCTL_SAVE,
 	NPFCTL_LOAD,
 	NPFCTL_DEBUG,
 	NPFCTL_CONN_LIST,
+	BSTGW_NETIF_DEMO,
 };
 
 bool
@@ -93,7 +91,7 @@ usage(void)
 	const char *progname = getprogname();
 
 	fprintf(stderr,
-	    "Usage:\t%s start | stop | flush | show | stats\n",
+	    "Usage:\t%s flush | show\n",
 	    progname);
 	fprintf(stderr,
 	    "\t%s validate | reload [<rule-file>]\n",
@@ -107,12 +105,6 @@ usage(void)
 	fprintf(stderr,
 	    "\t%s rule \"rule-name\" { list | flush }\n",
 	    progname);
-	fprintf(stderr,
-	    "\t%s table \"table-name\" { add | rem | test } <address/mask>\n",
-	    progname);
-	fprintf(stderr,
-	    "\t%s table \"table-name\" { list | flush }\n",
-	    progname);
 	fprintf(stderr,
 	    "\t%s table \"table-name\" replace [-n \"name\"]"
 	    " [-t <type>] <table-file>\n",
@@ -127,75 +119,12 @@ usage(void)
 	    "\t%s debug { -a | -b <binary-config> | -c <config> } "
 	    "[ -o <outfile> ]\n",
 	    progname);
+	fprintf(stderr,
+		"\t%s netif-demo\n",
+		progname);
 	exit(EXIT_FAILURE);
 }
 
-static int
-npfctl_print_stats(int fd)
-{
-	static const struct stats_s {
-		/* Note: -1 indicates a new section. */
-		int		index;
-		const char *	name;
-	} stats[] = {
-		{ -1, "Packets passed"					},
-		{ NPF_STAT_PASS_DEFAULT,	"default pass"		},
-		{ NPF_STAT_PASS_RULESET,	"ruleset pass"		},
-		{ NPF_STAT_PASS_CONN,		"state pass"		},
-
-		{ -1, "Packets blocked"					},
-		{ NPF_STAT_BLOCK_DEFAULT,	"default block"		},
-		{ NPF_STAT_BLOCK_RULESET,	"ruleset block"		},
-
-		{ -1, "State and NAT entries"				},
-		{ NPF_STAT_CONN_CREATE,		"state allocations"},
-		{ NPF_STAT_CONN_DESTROY,	"state destructions"},
-		{ NPF_STAT_NAT_CREATE,		"NAT entry allocations"	},
-		{ NPF_STAT_NAT_DESTROY,		"NAT entry destructions"},
-
-		{ -1, "Network buffers"					},
-		{ NPF_STAT_NBUF_NONCONTIG,	"non-contiguous cases"	},
-		{ NPF_STAT_NBUF_CONTIG_FAIL,	"contig alloc failures"	},
-
-		{ -1, "Invalid packet state cases"			},
-		{ NPF_STAT_INVALID_STATE,	"cases in total"	},
-		{ NPF_STAT_INVALID_STATE_TCP1,	"TCP case I"		},
-		{ NPF_STAT_INVALID_STATE_TCP2,	"TCP case II"		},
-		{ NPF_STAT_INVALID_STATE_TCP3,	"TCP case III"		},
-
-		{ -1, "Packet race cases"				},
-		{ NPF_STAT_RACE_NAT,		"NAT association race"	},
-		{ NPF_STAT_RACE_CONN,		"duplicate state race"	},
-
-		{ -1, "Fragmentation"					},
-		{ NPF_STAT_FRAGMENTS,		"fragments"		},
-		{ NPF_STAT_REASSEMBLY,		"reassembled"		},
-		{ NPF_STAT_REASSFAIL,		"failed reassembly"	},
-
-		{ -1, "Other"						},
-		{ NPF_STAT_ERROR,		"unexpected errors"	},
-	};
-	uint64_t *st = ecalloc(1, NPF_STATS_SIZE);
-
-	if (ioctl(fd, IOC_NPF_STATS, &st) != 0) {
-		err(EXIT_FAILURE, "ioctl(IOC_NPF_STATS)");
-	}
-
-	for (unsigned i = 0; i < __arraycount(stats); i++) {
-		const char *sname = stats[i].name;
-		int sidx = stats[i].index;
-
-		if (sidx == -1) {
-			printf("%s:\n", sname);
-		} else {
-			printf("\t%"PRIu64" %s\n", st[sidx], sname);
-		}
-	}
-
-	free(st);
-	return 0;
-}
-
 void
 npfctl_print_error(const npf_error_t *ne)
 {
@@ -264,27 +193,6 @@ npfctl_bpfjit(bool onoff)
 static void
 npfctl_preload_bpfjit(void)
 {
-#ifdef __NetBSD__
-	modctl_load_t args = {
-		.ml_filename = "bpfjit",
-		.ml_flags = MODCTL_NO_PROP,
-		.ml_props = NULL,
-		.ml_propslen = 0
-	};
-
-	if (!bpfjit)
-		return;
-
-	if (modctl(MODCTL_LOAD, &args) != 0 && errno != EEXIST) {
-		static const char *p = "; performance will be degraded";
-		if (errno == ENOENT)
-			warnx("the bpfjit module seems to be missing%s", p);
-		else
-			warn("error loading the bpfjit module%s", p);
-		warnx("To disable this warning `set bpf.jit off' in "
-		    "/etc/npf.conf");
-	}
-#endif
 }
 
 static nl_config_t *
@@ -319,7 +227,7 @@ npfctl_import(const char *path)
 }
 
 static int
-npfctl_load(int fd)
+npfctl_load(const char *fd)
 {
 	nl_config_t *ncf;
 	npf_error_t errinfo;
@@ -338,6 +246,7 @@ npfctl_load(int fd)
 	return errno;
 }
 
+/*
 static int
 npfctl_open_dev(const char *path)
 {
@@ -355,7 +264,7 @@ npfctl_open_dev(const char *path)
 		}
 		memset(&addr, 0, sizeof(addr));
 		addr.sun_family = AF_UNIX;
-		strncpy(addr.sun_path, path, sizeof(addr.sun_path) - 1);
+		strlcpy(addr.sun_path, path, sizeof(addr.sun_path) - 1);
 
 		if (connect(fd, (struct sockaddr *)&addr, sizeof(addr)) == -1) {
 			err(EXIT_FAILURE, "connect");
@@ -367,6 +276,7 @@ npfctl_open_dev(const char *path)
 	}
 	return fd;
 }
+*/
 
 static void
 npfctl_debug(int argc, char **argv)
@@ -374,7 +284,8 @@ npfctl_debug(int argc, char **argv)
 	const char *conf = NULL, *bconf = NULL, *outfile = NULL;
 	bool use_active = false;
 	nl_config_t *ncf = NULL;
-	int fd, c, optcount;
+	int c, optcount;
+	const char *fd;
 
 	argc--;
 	argv++;
@@ -414,7 +325,8 @@ npfctl_debug(int argc, char **argv)
 
 	if (use_active) {
 		puts("Loading the active configuration");
-		fd = npfctl_open_dev(NPF_DEV_PATH);
+		if (custom_bstgw_path == NULL) fd = NPF_BSTGW_PATH;
+		else fd = custom_bstgw_path;
 		if ((ncf = npf_config_retrieve(fd)) == NULL) {
 			err(EXIT_FAILURE, "npf_config_retrieve");
 		}
@@ -444,30 +356,22 @@ npfctl_debug(int argc, char **argv)
 static void
 npfctl(int action, int argc, char **argv)
 {
-	int fd, boolval, ret = 0;
+	int ret = 0;
+	const char *fd;
 	const char *fun = "";
 	nl_config_t *ncf;
 
 	switch (action) {
 	case NPFCTL_VALIDATE:
 	case NPFCTL_DEBUG:
-		fd = 0;
+		fd = NULL;
 		break;
 	default:
-		fd = npfctl_open_dev(NPF_DEV_PATH);
+		if (custom_bstgw_path == NULL) fd = NPF_BSTGW_PATH;
+		else fd = custom_bstgw_path;
 	}
 
 	switch (action) {
-	case NPFCTL_START:
-		boolval = true;
-		ret = ioctl(fd, IOC_NPF_SWITCH, &boolval);
-		fun = "ioctl(IOC_NPF_SWITCH)";
-		break;
-	case NPFCTL_STOP:
-		boolval = false;
-		ret = ioctl(fd, IOC_NPF_SWITCH, &boolval);
-		fun = "ioctl(IOC_NPF_SWITCH)";
-		break;
 	case NPFCTL_RELOAD:
 		npfctl_config_init(false);
 		npfctl_parse_file(argc < 3 ? NPF_CONF_PATH : argv[2]);
@@ -491,7 +395,8 @@ npfctl(int action, int argc, char **argv)
 		if (strcmp(argv[1], "replace") == 0) {
 			npfctl_table_replace(fd, argc, argv);
 		} else {
-			npfctl_table(fd, argc, argv);
+			usage();
+//			npfctl_table(fd, argc, argv);
 		}
 		break;
 	case NPFCTL_RULE:
@@ -517,10 +422,6 @@ npfctl(int action, int argc, char **argv)
 		}
 		fun = "npfctl_config_save";
 		break;
-	case NPFCTL_STATS:
-		ret = npfctl_print_stats(fd);
-		fun = "npfctl_print_stats";
-		break;
 	case NPFCTL_CONN_LIST:
 		ret = npfctl_conn_list(fd, argc, argv);
 		fun = "npfctl_conn_list";
@@ -528,31 +429,70 @@ npfctl(int action, int argc, char **argv)
 	case NPFCTL_VALIDATE:
 		npfctl_config_init(false);
 		npfctl_parse_file(argc > 2 ? argv[2] : NPF_CONF_PATH);
-		ret = npfctl_config_show(0);
+		ret = npfctl_config_show(NULL);
 		fun = "npfctl_config_show";
 		break;
 	case NPFCTL_DEBUG:
 		npfctl_debug(argc, argv);
 		break;
+	case BSTGW_NETIF_DEMO: {
+		struct bstgw_ifnet *net_list = bstgw_retrieve_netif_list(fd);
+		if(!net_list)
+			fprintf(stderr, "Failed to retrieve netif list\n");
+		else
+			bstgw_free_netifs_chain(net_list);
+		fun = "bstgw_netif_list_retrieve";
+		break;
+	}
 	}
 	if (ret) {
 		err(EXIT_FAILURE, "%s", fun);
 	}
-	if (fd) {
-		close(fd);
-	}
 }
 
+EMSCRIPTEN_KEEPALIVE
 int
 main(int argc, char **argv)
 {
+	(void)argc;
+	(void)argv;
+	return 0;
+}
+
+void set_bstgw_base_url(const char *);
+
+EMSCRIPTEN_KEEPALIVE
+void set_bstgw_base_url(const char *path) {
+	if (path == NULL) return;
+	size_t plen = strlen(path);
+	if (plen == 0) return;
+
+	char *new_url;
+	if ( (new_url = malloc(plen+1+strlen(NPF_BSTGW_PATH)+1)) == NULL) return;
+	if (custom_bstgw_path != NULL) free(custom_bstgw_path);
+
+	/* path / NPF_BSTGW_PATH */
+	// e.g.:  path = http://localhost:4433;  -->  http://localhost:4433 + / + trustconf
+	strncpy(new_url, path, plen);
+	new_url[plen] = '/';
+	strncpy(new_url+(plen+1), NPF_BSTGW_PATH, strlen(NPF_BSTGW_PATH));
+	new_url[plen+1+strlen(NPF_BSTGW_PATH)] = '\0';
+	custom_bstgw_path = new_url;
+	printf("set new base url to: %s\n", custom_bstgw_path);
+}
+
+int npfctl_main(int argc, char **argv);
+
+EMSCRIPTEN_KEEPALIVE
+int
+npfctl_main(int argc, char **argv)
+{
+	printf("npfctl_main(%d, %p), url: %s\n", argc, argv, NPF_BSTGW_PATH);
 	static const struct operations_s {
 		const char *		cmd;
 		int			action;
 	} operations[] = {
 		/* Start, stop, reload */
-		{	"start",	NPFCTL_START		},
-		{	"stop",		NPFCTL_STOP		},
 		{	"reload",	NPFCTL_RELOAD		},
 		{	"show",		NPFCTL_SHOWCONF,	},
 		{	"flush",	NPFCTL_FLUSH		},
@@ -560,8 +500,6 @@ main(int argc, char **argv)
 		{	"table",	NPFCTL_TABLE		},
 		/* Rule */
 		{	"rule",		NPFCTL_RULE		},
-		/* Stats */
-		{	"stats",	NPFCTL_STATS		},
 		/* Full state save/load */
 		{	"save",		NPFCTL_SAVE		},
 		{	"load",		NPFCTL_LOAD		},
@@ -569,6 +507,7 @@ main(int argc, char **argv)
 		/* Misc. */
 		{	"valid",	NPFCTL_VALIDATE		},
 		{	"debug",	NPFCTL_DEBUG		},
+		{   "netif-demo", BSTGW_NETIF_DEMO  },
 		/* --- */
 		{	NULL,		0			}
 	};
@@ -590,4 +529,5 @@ main(int argc, char **argv)
 		return EXIT_SUCCESS;
 	}
 	usage();
-}
+	return EXIT_FAILURE;
+}
\ No newline at end of file
diff --git a/src/npfctl/npfctl.h b/src/npfctl/npfctl.h
index 4a17517..247f435 100644
--- a/src/npfctl/npfctl.h
+++ b/src/npfctl/npfctl.h
@@ -44,7 +44,13 @@
 
 #include "npf_var.h"
 
-#define	NPF_DEV_PATH	"/dev/npf"
+//#define	NPF_DEV_PATH	"/dev/npf"
+
+/* Note: "/trustconf" and "trustconf" don't seem to work from different origin worker */
+//#define NPF_BSTGW_PATH "http://localhost:4433/trustconf"
+#define NPF_BSTGW_PATH "trustconf"
+extern char *custom_bstgw_path;
+
 #define	NPF_CONF_PATH	"/etc/npf.conf"
 #define	NPF_DB_PATH	"/var/db/npf.db"
 
@@ -145,10 +151,26 @@ uint16_t	npfctl_npt66_calcadj(npf_netmask_t, const npf_addr_t *,
 int		npfctl_nat_ruleset_p(const char *, bool *);
 
 void		usage(void);
-void		npfctl_rule(int, int, char **);
-void		npfctl_table_replace(int, int, char **);
-void		npfctl_table(int, int, char **);
-int		npfctl_conn_list(int, int, char **);
+void		npfctl_rule(const char *, int, char **);
+void		npfctl_table_replace(const char *, int, char **);
+int		npfctl_conn_list(const char *, int, char **);
+
+/*
+ * BSTGW -- netif information parsing
+ */
+struct bstgw_ifnet {
+	struct bstgw_ifnet *next;
+	// WARNING: not necessarily unique if interface has multiple IPs
+	unsigned long if_idx;
+	char *name;
+	struct sockaddr_in *ip_addr;
+};
+
+#include <nv.h>
+struct bstgw_ifnet * bstgw_retrieve_netif_list(const char *);
+
+struct bstgw_ifnet * bstgw_parse_netif_list(const nvlist_t *);
+void bstgw_free_netifs_chain(struct bstgw_ifnet *);
 
 /*
  * NPF extension loading.
@@ -204,11 +226,11 @@ void		npfctl_bpf_table(npf_bpf_t *, u_int, u_int);
 
 void		npfctl_config_init(bool);
 void		npfctl_config_build(void);
-int		npfctl_config_send(int);
+int		npfctl_config_send(const char *);
 nl_config_t *	npfctl_config_ref(void);
-int		npfctl_config_show(int);
+int		npfctl_config_show(const char *);
 void		npfctl_config_save(nl_config_t *, const char *);
-int		npfctl_ruleset_show(int, const char *);
+int		npfctl_ruleset_show(const char *, const char *);
 
 nl_rule_t *	npfctl_rule_ref(void);
 nl_table_t *	npfctl_table_ref(void);
diff --git a/src/npfctl/pcap b/src/npfctl/pcap
new file mode 120000
index 0000000..1d23b8e
--- /dev/null
+++ b/src/npfctl/pcap
@@ -0,0 +1 @@
+/usr/include/pcap
\ No newline at end of file
diff --git a/src/npfctl/sha1/sha1.c b/src/npfctl/sha1/sha1.c
new file mode 100644
index 0000000..1911f09
--- /dev/null
+++ b/src/npfctl/sha1/sha1.c
@@ -0,0 +1,451 @@
+// SPDX-License-Identifier: Apache-2.0
+/*
+ *  FIPS-180-1 compliant SHA-1 implementation
+ *
+ *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License"); you may
+ *  not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  This file is part of mbed TLS (https://tls.mbed.org)
+ */
+/*
+ *  The SHA-1 standard was published by NIST in 1993.
+ *
+ *  http://www.itl.nist.gov/fipspubs/fip180-1.htm
+ */
+
+#include "sha1.h"
+
+#include <string.h>
+#include <stdio.h>
+#define mbedtls_printf printf
+
+#define MBEDTLS_INTERNAL_VALIDATE( cond )           do { } while( 0 )
+
+/* Internal macro meant to be called only from within the library. */
+#define MBEDTLS_INTERNAL_VALIDATE_RET( cond, ret )  \
+    do {                                            \
+        if( !(cond) )                               \
+        {                                           \
+            return( ret );                          \
+        }                                           \
+    } while( 0 )
+
+#define SHA1_VALIDATE_RET(cond)                             \
+    MBEDTLS_INTERNAL_VALIDATE_RET( cond, MBEDTLS_ERR_SHA1_BAD_INPUT_DATA )
+
+#define SHA1_VALIDATE(cond)  MBEDTLS_INTERNAL_VALIDATE( cond )
+
+/*
+ * 32-bit integer manipulation macros (big endian)
+ */
+#ifndef GET_UINT32_BE
+#define GET_UINT32_BE(n,b,i)                            \
+{                                                       \
+    (n) = ( (uint32_t) (b)[(i)    ] << 24 )             \
+        | ( (uint32_t) (b)[(i) + 1] << 16 )             \
+        | ( (uint32_t) (b)[(i) + 2] <<  8 )             \
+        | ( (uint32_t) (b)[(i) + 3]       );            \
+}
+#endif
+
+#ifndef PUT_UINT32_BE
+#define PUT_UINT32_BE(n,b,i)                            \
+{                                                       \
+    (b)[(i)    ] = (unsigned char) ( (n) >> 24 );       \
+    (b)[(i) + 1] = (unsigned char) ( (n) >> 16 );       \
+    (b)[(i) + 2] = (unsigned char) ( (n) >>  8 );       \
+    (b)[(i) + 3] = (unsigned char) ( (n)       );       \
+}
+#endif
+
+void mbedtls_sha1_init( mbedtls_sha1_context *ctx )
+{
+    SHA1_VALIDATE( ctx != NULL );
+
+    memset( ctx, 0, sizeof( mbedtls_sha1_context ) );
+}
+
+void mbedtls_sha1_free( mbedtls_sha1_context *ctx )
+{
+    if( ctx == NULL )
+        return;
+
+//    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_sha1_context ) );
+    memset( ctx, 0, sizeof( mbedtls_sha1_context ) );
+}
+
+void mbedtls_sha1_clone( mbedtls_sha1_context *dst,
+                         const mbedtls_sha1_context *src )
+{
+    SHA1_VALIDATE( dst != NULL );
+    SHA1_VALIDATE( src != NULL );
+
+    *dst = *src;
+}
+
+/*
+ * SHA-1 context setup
+ */
+int mbedtls_sha1_starts_ret( mbedtls_sha1_context *ctx )
+{
+    SHA1_VALIDATE_RET( ctx != NULL );
+
+    ctx->total[0] = 0;
+    ctx->total[1] = 0;
+
+    ctx->state[0] = 0x67452301;
+    ctx->state[1] = 0xEFCDAB89;
+    ctx->state[2] = 0x98BADCFE;
+    ctx->state[3] = 0x10325476;
+    ctx->state[4] = 0xC3D2E1F0;
+
+    return( 0 );
+}
+
+void mbedtls_sha1_starts( mbedtls_sha1_context *ctx )
+{
+    mbedtls_sha1_starts_ret( ctx );
+}
+
+int mbedtls_internal_sha1_process( mbedtls_sha1_context *ctx,
+                                   const unsigned char data[64] )
+{
+    uint32_t temp, W[16], A, B, C, D, E;
+
+    SHA1_VALIDATE_RET( ctx != NULL );
+    SHA1_VALIDATE_RET( (const unsigned char *)data != NULL );
+
+    GET_UINT32_BE( W[ 0], data,  0 );
+    GET_UINT32_BE( W[ 1], data,  4 );
+    GET_UINT32_BE( W[ 2], data,  8 );
+    GET_UINT32_BE( W[ 3], data, 12 );
+    GET_UINT32_BE( W[ 4], data, 16 );
+    GET_UINT32_BE( W[ 5], data, 20 );
+    GET_UINT32_BE( W[ 6], data, 24 );
+    GET_UINT32_BE( W[ 7], data, 28 );
+    GET_UINT32_BE( W[ 8], data, 32 );
+    GET_UINT32_BE( W[ 9], data, 36 );
+    GET_UINT32_BE( W[10], data, 40 );
+    GET_UINT32_BE( W[11], data, 44 );
+    GET_UINT32_BE( W[12], data, 48 );
+    GET_UINT32_BE( W[13], data, 52 );
+    GET_UINT32_BE( W[14], data, 56 );
+    GET_UINT32_BE( W[15], data, 60 );
+
+#define S(x,n) ((x << n) | ((x & 0xFFFFFFFF) >> (32 - n)))
+
+#define R(t)                                            \
+(                                                       \
+    temp = W[( t -  3 ) & 0x0F] ^ W[( t - 8 ) & 0x0F] ^ \
+           W[( t - 14 ) & 0x0F] ^ W[  t       & 0x0F],  \
+    ( W[t & 0x0F] = S(temp,1) )                         \
+)
+
+#define P(a,b,c,d,e,x)                                  \
+{                                                       \
+    e += S(a,5) + F(b,c,d) + K + x; b = S(b,30);        \
+}
+
+    A = ctx->state[0];
+    B = ctx->state[1];
+    C = ctx->state[2];
+    D = ctx->state[3];
+    E = ctx->state[4];
+
+#define F(x,y,z) (z ^ (x & (y ^ z)))
+#define K 0x5A827999
+
+    P( A, B, C, D, E, W[0]  );
+    P( E, A, B, C, D, W[1]  );
+    P( D, E, A, B, C, W[2]  );
+    P( C, D, E, A, B, W[3]  );
+    P( B, C, D, E, A, W[4]  );
+    P( A, B, C, D, E, W[5]  );
+    P( E, A, B, C, D, W[6]  );
+    P( D, E, A, B, C, W[7]  );
+    P( C, D, E, A, B, W[8]  );
+    P( B, C, D, E, A, W[9]  );
+    P( A, B, C, D, E, W[10] );
+    P( E, A, B, C, D, W[11] );
+    P( D, E, A, B, C, W[12] );
+    P( C, D, E, A, B, W[13] );
+    P( B, C, D, E, A, W[14] );
+    P( A, B, C, D, E, W[15] );
+    P( E, A, B, C, D, R(16) );
+    P( D, E, A, B, C, R(17) );
+    P( C, D, E, A, B, R(18) );
+    P( B, C, D, E, A, R(19) );
+
+#undef K
+#undef F
+
+#define F(x,y,z) (x ^ y ^ z)
+#define K 0x6ED9EBA1
+
+    P( A, B, C, D, E, R(20) );
+    P( E, A, B, C, D, R(21) );
+    P( D, E, A, B, C, R(22) );
+    P( C, D, E, A, B, R(23) );
+    P( B, C, D, E, A, R(24) );
+    P( A, B, C, D, E, R(25) );
+    P( E, A, B, C, D, R(26) );
+    P( D, E, A, B, C, R(27) );
+    P( C, D, E, A, B, R(28) );
+    P( B, C, D, E, A, R(29) );
+    P( A, B, C, D, E, R(30) );
+    P( E, A, B, C, D, R(31) );
+    P( D, E, A, B, C, R(32) );
+    P( C, D, E, A, B, R(33) );
+    P( B, C, D, E, A, R(34) );
+    P( A, B, C, D, E, R(35) );
+    P( E, A, B, C, D, R(36) );
+    P( D, E, A, B, C, R(37) );
+    P( C, D, E, A, B, R(38) );
+    P( B, C, D, E, A, R(39) );
+
+#undef K
+#undef F
+
+#define F(x,y,z) ((x & y) | (z & (x | y)))
+#define K 0x8F1BBCDC
+
+    P( A, B, C, D, E, R(40) );
+    P( E, A, B, C, D, R(41) );
+    P( D, E, A, B, C, R(42) );
+    P( C, D, E, A, B, R(43) );
+    P( B, C, D, E, A, R(44) );
+    P( A, B, C, D, E, R(45) );
+    P( E, A, B, C, D, R(46) );
+    P( D, E, A, B, C, R(47) );
+    P( C, D, E, A, B, R(48) );
+    P( B, C, D, E, A, R(49) );
+    P( A, B, C, D, E, R(50) );
+    P( E, A, B, C, D, R(51) );
+    P( D, E, A, B, C, R(52) );
+    P( C, D, E, A, B, R(53) );
+    P( B, C, D, E, A, R(54) );
+    P( A, B, C, D, E, R(55) );
+    P( E, A, B, C, D, R(56) );
+    P( D, E, A, B, C, R(57) );
+    P( C, D, E, A, B, R(58) );
+    P( B, C, D, E, A, R(59) );
+
+#undef K
+#undef F
+
+#define F(x,y,z) (x ^ y ^ z)
+#define K 0xCA62C1D6
+
+    P( A, B, C, D, E, R(60) );
+    P( E, A, B, C, D, R(61) );
+    P( D, E, A, B, C, R(62) );
+    P( C, D, E, A, B, R(63) );
+    P( B, C, D, E, A, R(64) );
+    P( A, B, C, D, E, R(65) );
+    P( E, A, B, C, D, R(66) );
+    P( D, E, A, B, C, R(67) );
+    P( C, D, E, A, B, R(68) );
+    P( B, C, D, E, A, R(69) );
+    P( A, B, C, D, E, R(70) );
+    P( E, A, B, C, D, R(71) );
+    P( D, E, A, B, C, R(72) );
+    P( C, D, E, A, B, R(73) );
+    P( B, C, D, E, A, R(74) );
+    P( A, B, C, D, E, R(75) );
+    P( E, A, B, C, D, R(76) );
+    P( D, E, A, B, C, R(77) );
+    P( C, D, E, A, B, R(78) );
+    P( B, C, D, E, A, R(79) );
+
+#undef K
+#undef F
+
+    ctx->state[0] += A;
+    ctx->state[1] += B;
+    ctx->state[2] += C;
+    ctx->state[3] += D;
+    ctx->state[4] += E;
+
+    return( 0 );
+}
+
+void mbedtls_sha1_process( mbedtls_sha1_context *ctx,
+                           const unsigned char data[64] )
+{
+    mbedtls_internal_sha1_process( ctx, data );
+}
+
+/*
+ * SHA-1 process buffer
+ */
+int mbedtls_sha1_update_ret( mbedtls_sha1_context *ctx,
+                             const unsigned char *input,
+                             size_t ilen )
+{
+    int ret;
+    size_t fill;
+    uint32_t left;
+
+    SHA1_VALIDATE_RET( ctx != NULL );
+    SHA1_VALIDATE_RET( ilen == 0 || input != NULL );
+
+    if( ilen == 0 )
+        return( 0 );
+
+    left = ctx->total[0] & 0x3F;
+    fill = 64 - left;
+
+    ctx->total[0] += (uint32_t) ilen;
+    ctx->total[0] &= 0xFFFFFFFF;
+
+    if( ctx->total[0] < (uint32_t) ilen )
+        ctx->total[1]++;
+
+    if( left && ilen >= fill )
+    {
+        memcpy( (void *) (ctx->buffer + left), input, fill );
+
+        if( ( ret = mbedtls_internal_sha1_process( ctx, ctx->buffer ) ) != 0 )
+            return( ret );
+
+        input += fill;
+        ilen  -= fill;
+        left = 0;
+    }
+
+    while( ilen >= 64 )
+    {
+        if( ( ret = mbedtls_internal_sha1_process( ctx, input ) ) != 0 )
+            return( ret );
+
+        input += 64;
+        ilen  -= 64;
+    }
+
+    if( ilen > 0 )
+        memcpy( (void *) (ctx->buffer + left), input, ilen );
+
+    return( 0 );
+}
+
+void mbedtls_sha1_update( mbedtls_sha1_context *ctx,
+                          const unsigned char *input,
+                          size_t ilen )
+{
+    mbedtls_sha1_update_ret( ctx, input, ilen );
+}
+
+/*
+ * SHA-1 final digest
+ */
+int mbedtls_sha1_finish_ret( mbedtls_sha1_context *ctx,
+                             unsigned char output[20] )
+{
+    int ret;
+    uint32_t used;
+    uint32_t high, low;
+
+    SHA1_VALIDATE_RET( ctx != NULL );
+    SHA1_VALIDATE_RET( (unsigned char *)output != NULL );
+
+    /*
+     * Add padding: 0x80 then 0x00 until 8 bytes remain for the length
+     */
+    used = ctx->total[0] & 0x3F;
+
+    ctx->buffer[used++] = 0x80;
+
+    if( used <= 56 )
+    {
+        /* Enough room for padding + length in current block */
+        memset( ctx->buffer + used, 0, 56 - used );
+    }
+    else
+    {
+        /* We'll need an extra block */
+        memset( ctx->buffer + used, 0, 64 - used );
+
+        if( ( ret = mbedtls_internal_sha1_process( ctx, ctx->buffer ) ) != 0 )
+            return( ret );
+
+        memset( ctx->buffer, 0, 56 );
+    }
+
+    /*
+     * Add message length
+     */
+    high = ( ctx->total[0] >> 29 )
+         | ( ctx->total[1] <<  3 );
+    low  = ( ctx->total[0] <<  3 );
+
+    PUT_UINT32_BE( high, ctx->buffer, 56 );
+    PUT_UINT32_BE( low,  ctx->buffer, 60 );
+
+    if( ( ret = mbedtls_internal_sha1_process( ctx, ctx->buffer ) ) != 0 )
+        return( ret );
+
+    /*
+     * Output final state
+     */
+    PUT_UINT32_BE( ctx->state[0], output,  0 );
+    PUT_UINT32_BE( ctx->state[1], output,  4 );
+    PUT_UINT32_BE( ctx->state[2], output,  8 );
+    PUT_UINT32_BE( ctx->state[3], output, 12 );
+    PUT_UINT32_BE( ctx->state[4], output, 16 );
+
+    return( 0 );
+}
+
+void mbedtls_sha1_finish( mbedtls_sha1_context *ctx,
+                          unsigned char output[20] )
+{
+    mbedtls_sha1_finish_ret( ctx, output );
+}
+
+/*
+ * output = SHA-1( input buffer )
+ */
+int mbedtls_sha1_ret( const unsigned char *input,
+                      size_t ilen,
+                      unsigned char output[20] )
+{
+    int ret;
+    mbedtls_sha1_context ctx;
+
+    SHA1_VALIDATE_RET( ilen == 0 || input != NULL );
+    SHA1_VALIDATE_RET( (unsigned char *)output != NULL );
+
+    mbedtls_sha1_init( &ctx );
+
+    if( ( ret = mbedtls_sha1_starts_ret( &ctx ) ) != 0 )
+        goto exit;
+
+    if( ( ret = mbedtls_sha1_update_ret( &ctx, input, ilen ) ) != 0 )
+        goto exit;
+
+    if( ( ret = mbedtls_sha1_finish_ret( &ctx, output ) ) != 0 )
+        goto exit;
+
+exit:
+    mbedtls_sha1_free( &ctx );
+
+    return( ret );
+}
+
+void mbedtls_sha1( const unsigned char *input,
+                   size_t ilen,
+                   unsigned char output[20] )
+{
+    mbedtls_sha1_ret( input, ilen, output );
+}
diff --git a/src/npfctl/sha1/sha1.h b/src/npfctl/sha1/sha1.h
new file mode 100644
index 0000000..30dee9c
--- /dev/null
+++ b/src/npfctl/sha1/sha1.h
@@ -0,0 +1,300 @@
+/* SPDX-License-Identifier: Apache-2.0 */
+/**
+ * \file sha1.h
+ *
+ * \brief This file contains SHA-1 definitions and functions.
+ *
+ * The Secure Hash Algorithm 1 (SHA-1) cryptographic hash function is defined in
+ * <em>FIPS 180-4: Secure Hash Standard (SHS)</em>.
+ *
+ * \warning   SHA-1 is considered a weak message digest and its use constitutes
+ *            a security risk. We recommend considering stronger message
+ *            digests instead.
+ */
+/*
+ *  Copyright (C) 2006-2018, Arm Limited (or its affiliates), All Rights Reserved
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License"); you may
+ *  not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  This file is part of Mbed TLS (https://tls.mbed.org)
+ */
+#ifndef MBEDTLS_SHA1_H
+#define MBEDTLS_SHA1_H
+
+#include <stddef.h>
+#include <stdint.h>
+
+/* MBEDTLS_ERR_SHA1_HW_ACCEL_FAILED is deprecated and should not be used. */
+#define MBEDTLS_ERR_SHA1_HW_ACCEL_FAILED                  -0x0035  /**< SHA-1 hardware accelerator failed */
+#define MBEDTLS_ERR_SHA1_BAD_INPUT_DATA                   -0x0073  /**< SHA-1 input data was malformed. */
+
+#define SHA_DIGEST_LENGTH		20
+
+// Regular implementation
+//
+
+/**
+ * \brief          The SHA-1 context structure.
+ *
+ * \warning        SHA-1 is considered a weak message digest and its use
+ *                 constitutes a security risk. We recommend considering
+ *                 stronger message digests instead.
+ *
+ */
+typedef struct mbedtls_sha1_context
+{
+    uint32_t total[2];          /*!< The number of Bytes processed.  */
+    uint32_t state[5];          /*!< The intermediate digest state.  */
+    unsigned char buffer[64];   /*!< The data block being processed. */
+}
+mbedtls_sha1_context;
+
+/**
+ * \brief          This function initializes a SHA-1 context.
+ *
+ * \warning        SHA-1 is considered a weak message digest and its use
+ *                 constitutes a security risk. We recommend considering
+ *                 stronger message digests instead.
+ *
+ * \param ctx      The SHA-1 context to initialize.
+ *                 This must not be \c NULL.
+ *
+ */
+void mbedtls_sha1_init( mbedtls_sha1_context *ctx );
+
+/**
+ * \brief          This function clears a SHA-1 context.
+ *
+ * \warning        SHA-1 is considered a weak message digest and its use
+ *                 constitutes a security risk. We recommend considering
+ *                 stronger message digests instead.
+ *
+ * \param ctx      The SHA-1 context to clear. This may be \c NULL,
+ *                 in which case this function does nothing. If it is
+ *                 not \c NULL, it must point to an initialized
+ *                 SHA-1 context.
+ *
+ */
+void mbedtls_sha1_free( mbedtls_sha1_context *ctx );
+
+/**
+ * \brief          This function clones the state of a SHA-1 context.
+ *
+ * \warning        SHA-1 is considered a weak message digest and its use
+ *                 constitutes a security risk. We recommend considering
+ *                 stronger message digests instead.
+ *
+ * \param dst      The SHA-1 context to clone to. This must be initialized.
+ * \param src      The SHA-1 context to clone from. This must be initialized.
+ *
+ */
+void mbedtls_sha1_clone( mbedtls_sha1_context *dst,
+                         const mbedtls_sha1_context *src );
+
+/**
+ * \brief          This function starts a SHA-1 checksum calculation.
+ *
+ * \warning        SHA-1 is considered a weak message digest and its use
+ *                 constitutes a security risk. We recommend considering
+ *                 stronger message digests instead.
+ *
+ * \param ctx      The SHA-1 context to initialize. This must be initialized.
+ *
+ * \return         \c 0 on success.
+ * \return         A negative error code on failure.
+ *
+ */
+int mbedtls_sha1_starts_ret( mbedtls_sha1_context *ctx );
+
+/**
+ * \brief          This function feeds an input buffer into an ongoing SHA-1
+ *                 checksum calculation.
+ *
+ * \warning        SHA-1 is considered a weak message digest and its use
+ *                 constitutes a security risk. We recommend considering
+ *                 stronger message digests instead.
+ *
+ * \param ctx      The SHA-1 context. This must be initialized
+ *                 and have a hash operation started.
+ * \param input    The buffer holding the input data.
+ *                 This must be a readable buffer of length \p ilen Bytes.
+ * \param ilen     The length of the input data \p input in Bytes.
+ *
+ * \return         \c 0 on success.
+ * \return         A negative error code on failure.
+ */
+int mbedtls_sha1_update_ret( mbedtls_sha1_context *ctx,
+                             const unsigned char *input,
+                             size_t ilen );
+
+/**
+ * \brief          This function finishes the SHA-1 operation, and writes
+ *                 the result to the output buffer.
+ *
+ * \warning        SHA-1 is considered a weak message digest and its use
+ *                 constitutes a security risk. We recommend considering
+ *                 stronger message digests instead.
+ *
+ * \param ctx      The SHA-1 context to use. This must be initialized and
+ *                 have a hash operation started.
+ * \param output   The SHA-1 checksum result. This must be a writable
+ *                 buffer of length \c 20 Bytes.
+ *
+ * \return         \c 0 on success.
+ * \return         A negative error code on failure.
+ */
+int mbedtls_sha1_finish_ret( mbedtls_sha1_context *ctx,
+                             unsigned char output[20] );
+
+/**
+ * \brief          SHA-1 process data block (internal use only).
+ *
+ * \warning        SHA-1 is considered a weak message digest and its use
+ *                 constitutes a security risk. We recommend considering
+ *                 stronger message digests instead.
+ *
+ * \param ctx      The SHA-1 context to use. This must be initialized.
+ * \param data     The data block being processed. This must be a
+ *                 readable buffer of length \c 64 Bytes.
+ *
+ * \return         \c 0 on success.
+ * \return         A negative error code on failure.
+ *
+ */
+int mbedtls_internal_sha1_process( mbedtls_sha1_context *ctx,
+                                   const unsigned char data[64] );
+
+/**
+ * \brief          This function starts a SHA-1 checksum calculation.
+ *
+ * \warning        SHA-1 is considered a weak message digest and its use
+ *                 constitutes a security risk. We recommend considering
+ *                 stronger message digests instead.
+ *
+ * \deprecated     Superseded by mbedtls_sha1_starts_ret() in 2.7.0.
+ *
+ * \param ctx      The SHA-1 context to initialize. This must be initialized.
+ *
+ */
+void mbedtls_sha1_starts( mbedtls_sha1_context *ctx );
+
+/**
+ * \brief          This function feeds an input buffer into an ongoing SHA-1
+ *                 checksum calculation.
+ *
+ * \warning        SHA-1 is considered a weak message digest and its use
+ *                 constitutes a security risk. We recommend considering
+ *                 stronger message digests instead.
+ *
+ * \deprecated     Superseded by mbedtls_sha1_update_ret() in 2.7.0.
+ *
+ * \param ctx      The SHA-1 context. This must be initialized and
+ *                 have a hash operation started.
+ * \param input    The buffer holding the input data.
+ *                 This must be a readable buffer of length \p ilen Bytes.
+ * \param ilen     The length of the input data \p input in Bytes.
+ *
+ */
+void mbedtls_sha1_update( mbedtls_sha1_context *ctx,
+                                             const unsigned char *input,
+                                             size_t ilen );
+
+/**
+ * \brief          This function finishes the SHA-1 operation, and writes
+ *                 the result to the output buffer.
+ *
+ * \warning        SHA-1 is considered a weak message digest and its use
+ *                 constitutes a security risk. We recommend considering
+ *                 stronger message digests instead.
+ *
+ * \deprecated     Superseded by mbedtls_sha1_finish_ret() in 2.7.0.
+ *
+ * \param ctx      The SHA-1 context. This must be initialized and
+ *                 have a hash operation started.
+ * \param output   The SHA-1 checksum result.
+ *                 This must be a writable buffer of length \c 20 Bytes.
+ */
+void mbedtls_sha1_finish( mbedtls_sha1_context *ctx,
+                                             unsigned char output[20] );
+
+/**
+ * \brief          SHA-1 process data block (internal use only).
+ *
+ * \warning        SHA-1 is considered a weak message digest and its use
+ *                 constitutes a security risk. We recommend considering
+ *                 stronger message digests instead.
+ *
+ * \deprecated     Superseded by mbedtls_internal_sha1_process() in 2.7.0.
+ *
+ * \param ctx      The SHA-1 context. This must be initialized.
+ * \param data     The data block being processed.
+ *                 This must be a readable buffer of length \c 64 bytes.
+ *
+ */
+void mbedtls_sha1_process( mbedtls_sha1_context *ctx,
+                                              const unsigned char data[64] );
+
+/**
+ * \brief          This function calculates the SHA-1 checksum of a buffer.
+ *
+ *                 The function allocates the context, performs the
+ *                 calculation, and frees the context.
+ *
+ *                 The SHA-1 result is calculated as
+ *                 output = SHA-1(input buffer).
+ *
+ * \warning        SHA-1 is considered a weak message digest and its use
+ *                 constitutes a security risk. We recommend considering
+ *                 stronger message digests instead.
+ *
+ * \param input    The buffer holding the input data.
+ *                 This must be a readable buffer of length \p ilen Bytes.
+ * \param ilen     The length of the input data \p input in Bytes.
+ * \param output   The SHA-1 checksum result.
+ *                 This must be a writable buffer of length \c 20 Bytes.
+ *
+ * \return         \c 0 on success.
+ * \return         A negative error code on failure.
+ *
+ */
+int mbedtls_sha1_ret( const unsigned char *input,
+                      size_t ilen,
+                      unsigned char output[20] );
+
+/**
+ * \brief          This function calculates the SHA-1 checksum of a buffer.
+ *
+ *                 The function allocates the context, performs the
+ *                 calculation, and frees the context.
+ *
+ *                 The SHA-1 result is calculated as
+ *                 output = SHA-1(input buffer).
+ *
+ * \warning        SHA-1 is considered a weak message digest and its use
+ *                 constitutes a security risk. We recommend considering
+ *                 stronger message digests instead.
+ *
+ * \deprecated     Superseded by mbedtls_sha1_ret() in 2.7.0
+ *
+ * \param input    The buffer holding the input data.
+ *                 This must be a readable buffer of length \p ilen Bytes.
+ * \param ilen     The length of the input data \p input in Bytes.
+ * \param output   The SHA-1 checksum result. This must be a writable
+ *                 buffer of size \c 20 Bytes.
+ *
+ */
+void mbedtls_sha1( const unsigned char *input,
+                                      size_t ilen,
+                                      unsigned char output[20] );
+
+#endif /* mbedtls_sha1.h */
diff --git a/src/npfctl/sjcl.js b/src/npfctl/sjcl.js
new file mode 120000
index 0000000..19f6efc
--- /dev/null
+++ b/src/npfctl/sjcl.js
@@ -0,0 +1 @@
+../../../nw_offload/sjcl/sjcl.js
\ No newline at end of file
diff --git a/src/npfctl/util.h b/src/npfctl/util.h
index f385e1b..eac4925 100644
--- a/src/npfctl/util.h
+++ b/src/npfctl/util.h
@@ -89,10 +89,8 @@ estrndup(const char *s, size_t len)
 }
 #endif
 
-#if defined(__linux__) && !defined(_GNU_SOURCE) // XXX glibc
 int asprintf(char **strp, const char *fmt, ...);
 int vasprintf(char **strp, const char *fmt, va_list ap);
-#endif
 
 #ifndef easprintf
 static inline int
@@ -108,18 +106,6 @@ easprintf(char ** __restrict ret, const char * __restrict format, ...)
 }
 #endif
 
-#ifdef __linux__
-
-static inline char *
-strlcpy(char *d, const char *s, size_t l)
-{
-	if (l == 0)
-		return NULL;
-	strncpy(d, s, l);
-	d[l - 1] = '\0';
-	return d;
-}
-
 # define SALEN(sa)	((unsigned)sizeof(*sa))
 
 static int
@@ -236,11 +222,8 @@ sockaddr_snprintf(char * const sbuf, const size_t len, const char * const fmt,
 		break;
 #endif
 	default:
-#ifdef __linux__
 		errno = ENOTSUP;
-#else
-		errno = EAFNOSUPPORT;
-#endif
+	//	errno = EAFNOSUPPORT;
 		return -1;
 	}
 
@@ -394,6 +377,5 @@ done:
 		sbuf[len - 1] = '\0';
 	return (int)(buf - sbuf);
 }
-#endif
 
 #endif
diff --git a/src/npftest/Makefile b/src/npftest/Makefile
deleted file mode 100644
index 44d90e8..0000000
--- a/src/npftest/Makefile
+++ /dev/null
@@ -1,65 +0,0 @@
-#
-# Standalone NPF makefile: npftest utility with the unit tests.
-# This file is in the Public Domain.
-#
-
-BIN=		npftest
-
-SYSNAME:=	$(shell uname -s)
-SYSARCH:=	$(shell uname -m)
-
-CFLAGS+=	-std=c99 -O2 -g -Wall -Wextra -Werror
-CFLAGS+=	-D_POSIX_C_SOURCE=200809L
-CFLAGS+=	-D_GNU_SOURCE -D_DEFAULT_SOURCE
-
-CFLAGS+=	-I ../kern -I ../kern/stand -D__RCSID\(x\)=
-CFLAGS+=	-D_NPF_STANDALONE
-
-#
-# Extended warning flags.
-#
-CFLAGS+=	-Wno-unknown-warning-option # gcc vs clang
-
-CFLAGS+=	-Wstrict-prototypes -Wmissing-prototypes -Wpointer-arith
-CFLAGS+=	-Wmissing-declarations -Wredundant-decls -Wnested-externs
-CFLAGS+=	-Wshadow -Wcast-qual -Wcast-align -Wwrite-strings
-CFLAGS+=	-Wold-style-definition
-CFLAGS+=	-Wsuggest-attribute=noreturn #-Wjump-misses-init
-CFLAGS+=	-Wduplicated-cond -Wmisleading-indentation -Wnull-dereference
-CFLAGS+=	-Wduplicated-branches -Wrestrict
-
-#
-# Always debug mode, as this is the test utility.
-#
-CFLAGS+=	-Og -DDEBUG -fno-omit-frame-pointer
-ifeq ($(SYSARCH),x86_64)
-ifeq ($(CC),gcc) # XXX clang
-CFLAGS+=	-fsanitize=address -fsanitize=undefined
-LDFLAGS+=	-fsanitize=address -fsanitize=undefined
-endif
-endif
-
-CFLAGS+=	-pthread
-LDFLAGS+=	-lpthread -lnv -lpcap -lcdb -lnpfkern-dbg
-
-OBJS=		npftest.o npfstream.o
-
-OBJS+=		libnpftest/npf_bpf_test.o
-OBJS+=		libnpftest/npf_gc_test.o
-OBJS+=		libnpftest/npf_nat_test.o
-OBJS+=		libnpftest/npf_nbuf_test.o
-OBJS+=		libnpftest/npf_perf_test.o
-OBJS+=		libnpftest/npf_rule_test.o
-OBJS+=		libnpftest/npf_state_test.o
-OBJS+=		libnpftest/npf_table_test.o
-
-OBJS+=		libnpftest/npf_mbuf_subr.o
-OBJS+=		libnpftest/npf_test_subr.o
-
-all: $(OBJS)
-	$(CC) $^ -o $(BIN) $(LDFLAGS)
-
-clean:
-	rm -rf $(BIN) *.o libnpftest/*.o
-
-.PHONY: all clean
diff --git a/src/npftest/README b/src/npftest/README
deleted file mode 100644
index b1614db..0000000
--- a/src/npftest/README
+++ /dev/null
@@ -1,35 +0,0 @@
-$NetBSD: README,v 1.7 2018/09/29 14:41:36 rmind Exp $
-
-npftest - a tool for regression testing and debugging NPF.
-It uses RUMP framework to run NPF kernel module in the userspace.
-
----
-
-Test:
-
-npfctl debug -c npftest.conf -o /tmp/npf.nvlist
-npftest -c /tmp/npf.nvlist -t
-
-Stream:
-
-tcpdump -w stream.pcap -i $interface "host $host and tcp"
-npfctl debug -c npftest.conf -o /tmp/npf.nvlist
-npftest -c /tmp/npf.nvlist -s stream.pcap > stream_npf_data.txt
-
-Preferably, use MALLOC_OPTIONS="AJ" and/or other facilities.
-
-Benchmark:
-
-npftest -b rule -c /tmp/npf.nvlist -p $ncpu
-
----
-
-Update RUMP libraries once the kernel side has been changed.  Hint:
-
-cd src/sys/net/npf
-sudo make includes
-
-cd src/sys/rump/net/lib/libnpf
-make distclean
-MKDEBUG=yes MKDEBUGLIB=yes DBG="-g -O2" make -j8
-sudo MKDEBUG=yes MKDEBUGLIB=yes DBG="-g -O2" make install
diff --git a/src/npftest/libnpftest/npf_bpf_test.c b/src/npftest/libnpftest/npf_bpf_test.c
deleted file mode 100644
index 0659f71..0000000
--- a/src/npftest/libnpftest/npf_bpf_test.c
+++ /dev/null
@@ -1,122 +0,0 @@
-/*-
- * Copyright (c) 2013 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * This code is derived from software contributed to The NetBSD Foundation
- * by Mindaugas Rasiukevicius.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
- * NPF tests of BPF coprocessor.
- */
-
-#ifdef _KERNEL
-#include <sys/types.h>
-#include <sys/endian.h>
-#endif
-
-#define	NPF_BPFCOP
-#include "npf_impl.h"
-#include "npf_test.h"
-
-static bool	lverbose = false;
-
-static int
-test_bpf_code(void *code, size_t size)
-{
-	uint32_t memstore[BPF_MEMWORDS];
-	bpf_args_t bc_args;
-	npf_cache_t *npc;
-	struct mbuf *m;
-	int ret, jret;
-	void *jcode;
-
-	/* Layer 3 (IP + TCP). */
-	m = mbuf_get_pkt(AF_INET, IPPROTO_TCP,
-	    "192.168.2.100", "10.0.0.1", 15000, 80);
-	npc = get_cached_pkt(m, NULL);
-#ifdef _NPF_STANDALONE
-	bc_args.pkt = (const uint8_t *)nbuf_dataptr(npc->npc_nbuf);
-#else
-	bc_args.pkt = (const uint8_t *)m;
-#endif
-	bc_args.buflen = m_length(m);
-	bc_args.wirelen = bc_args.buflen;
-	bc_args.mem = memstore;
-	bc_args.arg = npc;
-
-	ret = npf_bpf_filter(&bc_args, code, NULL);
-
-	/* JIT-compiled code. */
-	jcode = npf_bpf_compile(code, size);
-	if (jcode) {
-		jret = npf_bpf_filter(&bc_args, NULL, jcode);
-		assert(ret == jret); (void)jret;
-		bpf_jit_freecode(jcode);
-	} else if (lverbose) {
-		printf("JIT-compilation failed\n");
-	}
-	put_cached_pkt(npc);
-	return ret;
-}
-
-static uint32_t
-npf_bpfcop_run(unsigned reg)
-{
-	struct bpf_insn insns_npf_bpfcop[] = {
-		BPF_STMT(BPF_MISC+BPF_COP, NPF_COP_L3),
-		BPF_STMT(BPF_LD+BPF_W+BPF_MEM, reg),
-		BPF_STMT(BPF_RET+BPF_A, 0),
-	};
-	return test_bpf_code(&insns_npf_bpfcop, sizeof(insns_npf_bpfcop));
-}
-
-static bool
-npf_bpfcop_test(void)
-{
-	/* A <- IP version (4 or 6) */
-	struct bpf_insn insns_ipver[] = {
-		BPF_STMT(BPF_MISC+BPF_COP, NPF_COP_L3),
-		BPF_STMT(BPF_RET+BPF_A, 0),
-	};
-	CHECK_TRUE(test_bpf_code(&insns_ipver, sizeof(insns_ipver)) == IPVERSION);
-
-	/* BPF_MW_IPVERI <- IP version */
-	CHECK_TRUE(npf_bpfcop_run(BPF_MW_IPVER) == IPVERSION);
-
-	/* BPF_MW_L4OFF <- L4 header offset */
-	CHECK_TRUE(npf_bpfcop_run(BPF_MW_L4OFF) == sizeof(struct ip));
-
-	/* BPF_MW_L4PROTO <- L4 protocol */
-	CHECK_TRUE(npf_bpfcop_run(BPF_MW_L4PROTO) == IPPROTO_TCP);
-
-	return true;
-}
-
-bool
-npf_bpf_test(bool verbose)
-{
-	lverbose = verbose;
-	return npf_bpfcop_test();
-}
diff --git a/src/npftest/libnpftest/npf_gc_test.c b/src/npftest/libnpftest/npf_gc_test.c
deleted file mode 100644
index 3c3ee57..0000000
--- a/src/npftest/libnpftest/npf_gc_test.c
+++ /dev/null
@@ -1,267 +0,0 @@
-/*
- * NPF connection tests.
- *
- * Public Domain.
- */
-
-#ifdef _KERNEL
-#include <sys/types.h>
-#include <sys/kmem.h>
-#endif
-
-#include "npf.h"
-#include "npf_impl.h"
-#include "npf_conn.h"
-#include "npf_test.h"
-
-static bool	lverbose = false;
-
-static unsigned
-count_conns(npf_conndb_t *cd)
-{
-	npf_conn_t *head = npf_conndb_getlist(cd), *conn = head;
-	unsigned n = 0;
-
-	while (conn) {
-		n++;
-		conn = npf_conndb_getnext(cd, conn);
-		if (conn == head) {
-			break;
-		}
-	}
-	return n;
-}
-
-static struct mbuf *
-get_packet(unsigned i)
-{
-	struct mbuf *m;
-	struct ip *ip;
-
-	m = mbuf_get_pkt(AF_INET, IPPROTO_UDP,
-	    "10.0.0.1", "172.16.0.1", 9000, 9000);
-	(void)mbuf_return_hdrs(m, false, &ip);
-	ip->ip_src.s_addr += i;
-	return m;
-}
-
-static bool
-enqueue_connection(unsigned i, bool expire)
-{
-	struct mbuf *m = get_packet(i);
-	npf_cache_t *npc = get_cached_pkt(m, NULL);
-	npf_conn_t *con;
-
-	con = npf_conn_establish(npc, PFIL_IN, true);
-	CHECK_TRUE(con != NULL);
-	if (expire) {
-		npf_conn_expire(con);
-	}
-	npf_conn_release(con);
-	put_cached_pkt(npc);
-	return true;
-}
-
-static bool
-run_conn_gc(unsigned active, unsigned expired, unsigned expected)
-{
-	npf_t *npf = npf_getkernctx();
-	npf_conndb_t *cd = npf_conndb_create();
-	unsigned total, n = 0;
-
-	npf->conn_db = cd;
-
-	/*
-	 * Insert the given number of active and expired connections..
-	 */
-	total = active + expired;
-
-	while (active || expired) {
-		if (active) {
-			enqueue_connection(n++, false);
-			active--;
-		}
-		if (expired) {
-			enqueue_connection(n++, true);
-			expired--;
-		}
-	}
-
-	/* Verify the count. */
-	n = count_conns(cd);
-	CHECK_TRUE(n == total);
-
-	/*
-	 * Run G/C.  Check the remaining.
-	 */
-	npf_conndb_gc(npf, cd, false, false);
-	n = count_conns(cd);
-	if (lverbose) {
-		printf("in conndb -- %u (expected %u)\n", n, expected);
-	}
-	CHECK_TRUE(n == expected);
-
-	/* Flush and destroy. */
-	npf_conndb_gc(npf, cd, true, false);
-	npf_conndb_destroy(cd);
-	npf->conn_db = NULL;
-	return true;
-}
-
-static bool
-run_gc_tests(void)
-{
-	bool ok;
-	int val;
-
-	/* Check the default value. */
-	npfk_param_get(npf_getkernctx(), "gc.step", &val);
-	CHECK_TRUE(val == 256);
-
-	/* Empty => GC => 0 in conndb. */
-	ok = run_conn_gc(0, 0, 0);
-	CHECK_TRUE(ok);
-
-	/* 1 active => GC => 1 in conndb. */
-	ok = run_conn_gc(1, 0, 1);
-	CHECK_TRUE(ok);
-
-	/* 1 expired => GC => 0 in conndb. */
-	ok = run_conn_gc(0, 1, 0);
-	CHECK_TRUE(ok);
-
-	/* 1 active and 1 expired => GC => 1 in conndb. */
-	ok = run_conn_gc(1, 1, 1);
-	CHECK_TRUE(ok);
-
-	/* 2 expired => GC => 0 in conndb. */
-	ok = run_conn_gc(0, 2, 0);
-	CHECK_TRUE(ok);
-
-	/* 128 expired => GC => 0 in conndb. */
-	ok = run_conn_gc(0, 128, 0);
-	CHECK_TRUE(ok);
-
-	/* 512 expired => GC => 256 in conndb. */
-	ok = run_conn_gc(0, 512, 256);
-	CHECK_TRUE(ok);
-
-	/* 512 expired => GC => 127 in conndb. */
-	npfk_param_set(npf_getkernctx(), "gc.step", 128);
-	ok = run_conn_gc(0, 512, 384);
-	CHECK_TRUE(ok);
-
-	return true;
-}
-
-static bool
-run_conndb_tests(npf_t *npf)
-{
-	npf_conndb_t *orig_cd = npf->conn_db;
-	bool ok;
-
-	npf_config_enter(npf);
-	npf_conn_tracking(npf, true);
-	npf_config_exit(npf);
-
-	ok = run_gc_tests();
-
-	/* We *MUST* restore the valid conndb. */
-	npf->conn_db = orig_cd;
-	return ok;
-}
-
-
-static void
-worker_test_task(npf_t *npf)
-{
-	bool *done = atomic_load_acquire(&npf->arg);
-	atomic_store_release(done, true);
-}
-
-static bool
-run_worker_tests(npf_t *npf)
-{
-	unsigned n = 100;
-	int error;
-
-	/* Spawn a worker thread. */
-	error = npf_worker_sysinit(1);
-	assert(error == 0);
-
-	/*
-	 * Enlist/discharge an instance, trying to trigger a race.
-	 */
-	while (n--) {
-		bool task_done = false;
-		unsigned retry = 100;
-		npf_t *test_npf;
-
-		/*
-		 * Initialize a dummy NPF instance and add a test task.
-		 * We will (ab)use npf_t::arg here.
-		 *
-		 * XXX/TODO: We should use:
-		 *
-		 *	npfk_create(NPF_NO_GC, &npftest_mbufops,
-		 *	    &npftest_ifops, &task_done);
-		 *
-		 * However, it resets the interface state and breaks
-		 * other tests; to be refactor.
-		 */
-		test_npf = kmem_zalloc(sizeof(npf_t), KM_SLEEP);
-		atomic_store_release(&test_npf->arg, &task_done);
-		test_npf->ebr = npf_ebr_create();
-
-		error = npf_worker_addfunc(test_npf, worker_test_task);
-		assert(error == 0);
-
-		/* Enlist the NPF instance. */
-		npf_worker_enlist(test_npf);
-
-		/* Wait for the task to be done. */
-		while (!atomic_load_acquire(&task_done) && retry--) {
-			npf_worker_signal(test_npf);
-			kpause("gctest", false, mstohz(1), NULL);
-		}
-
-		CHECK_TRUE(atomic_load_acquire(&task_done));
-		npf_worker_discharge(test_npf);
-
-		/* Clear the parameter and signal again. */
-		atomic_store_release(&test_npf->arg, NULL);
-		npf_worker_signal(test_npf);
-
-		npf_ebr_destroy(test_npf->ebr);
-		kmem_free(test_npf, sizeof(npf_t)); // npfk_destroy()
-	}
-
-	/*
-	 * Destroy the worker.
-	 *
-	 * Attempts to enlist, discharge or signal should have no effect.
-	 */
-
-	npf_worker_sysfini();
-	npf_worker_enlist(npf);
-	npf_worker_signal(npf);
-	npf_worker_discharge(npf);
-	return true;
-}
-
-bool
-npf_gc_test(bool verbose)
-{
-	npf_t *npf = npf_getkernctx();
-	bool ok;
-
-	lverbose = verbose;
-
-	ok = run_conndb_tests(npf);
-	CHECK_TRUE(ok);
-
-	ok = run_worker_tests(npf);
-	CHECK_TRUE(ok);
-
-	return ok;
-}
diff --git a/src/npftest/libnpftest/npf_mbuf_subr.c b/src/npftest/libnpftest/npf_mbuf_subr.c
deleted file mode 100644
index 4d9c0d6..0000000
--- a/src/npftest/libnpftest/npf_mbuf_subr.c
+++ /dev/null
@@ -1,343 +0,0 @@
-/*
- * NPF testing - helper routines.
- *
- * Public Domain.
- */
-
-#ifdef _KERNEL
-#include <sys/types.h>
-#include <sys/kmem.h>
-#endif
-
-#include "npf_impl.h"
-#include "npf_test.h"
-
-
-#if defined(_NPF_STANDALONE)
-struct mbuf *
-npfkern_m_get(npf_t *npf __unused, unsigned flags, size_t space)
-{
-	unsigned mlen = offsetof(struct mbuf, m_data0[space]);
-	struct mbuf *m;
-
-	m = calloc(1, mlen);
-	if (m) {
-		m->m_type = 1;
-		m->m_flags = flags;
-		m->m_data = m->m_data0;
-	}
-	return m;
-}
-#else
-struct mbuf *
-npfkern_m_get(npf_t *npf __unused, unsigned flags, size_t space)
-{
-	return m_get(flags, space);
-}
-#endif
-
-static void *
-npfkern_m_getdata(const struct mbuf *m)
-{
-	return m->m_data;
-}
-
-static struct mbuf *
-npfkern_m_next(struct mbuf *m)
-{
-	return m->m_next;
-}
-
-static size_t
-npfkern_m_buflen(const struct mbuf *m)
-{
-	return m->m_len;
-}
-
-size_t
-npfkern_m_length(const struct mbuf *m)
-{
-	const struct mbuf *m0;
-	unsigned pktlen = 0;
-
-	if ((m->m_flags & M_PKTHDR) != 0)
-		return m->m_pkthdr.len;
-	for (m0 = m; m0 != NULL; m0 = m0->m_next)
-		pktlen += m0->m_len;
-	return pktlen;
-}
-
-void
-npfkern_m_freem(struct mbuf *m)
-{
-#ifdef _NPF_STANDALONE
-	struct mbuf *n;
-
-	do {
-		n = m->m_next;
-		m->m_type = MT_FREE;
-		free(m);
-		m = n;
-	} while (m);
-#else
-	m_freem(m);
-#endif
-}
-
-static bool
-npfkern_m_ensure_contig(struct mbuf **m0, size_t len)
-{
-	struct mbuf *m1;
-	unsigned tlen;
-	char *dptr;
-
-	tlen = npfkern_m_length(*m0);
-	if ((m1 = npfkern_m_get(NULL, M_PKTHDR, tlen)) == NULL) {
-		return false;
-	}
-	m1->m_pkthdr.len = m1->m_len = tlen;
-	dptr = m1->m_data;
-	for (struct mbuf *m = *m0; m != NULL; m = m->m_next) {
-		memcpy(dptr, m->m_data, m->m_len);
-		dptr += m->m_len;
-	}
-	npfkern_m_freem(*m0);
-	*m0 = m1;
-	(void)len;
-	return true;
-}
-
-
-struct mbuf *
-mbuf_getwithdata(const void *data, size_t len)
-{
-	struct mbuf *m;
-	void *dst;
-
-	m = m_gethdr(M_WAITOK, MT_HEADER);
-	assert(m != NULL);
-	dst = mtod(m, void *);
-	memcpy(dst, data, len);
-	m->m_pkthdr.len = len;
-	m->m_len = len;
-	return m;
-}
-
-struct mbuf *
-mbuf_construct_ether(int proto)
-{
-	struct mbuf *m0, *m1;
-	struct ether_header *ethdr;
-
-	m0 = m_gethdr(M_WAITOK, MT_HEADER);
-	ethdr = mtod(m0, struct ether_header *);
-	ethdr->ether_type = htons(ETHERTYPE_IP);
-	m0->m_pkthdr.len = sizeof(struct ether_header);
-	m0->m_len = sizeof(struct ether_header);
-
-	m1 = mbuf_construct(proto);
-	m0->m_next = m1;
-	m1->m_next = NULL;
-	return m0;
-}
-
-static int
-mbuf_fill_proto(int proto, void *l4data)
-{
-	struct tcphdr *th;
-	int size = 0;
-
-	switch (proto) {
-	case IPPROTO_TCP:
-		th = l4data;
-		th->th_off = sizeof(struct tcphdr) >> 2;
-		size = sizeof(struct tcphdr);
-		break;
-	case IPPROTO_UDP:
-		size = sizeof(struct udphdr);
-		break;
-	case IPPROTO_ICMP:
-		size = offsetof(struct icmp, icmp_data);
-		break;
-	}
-	return size;
-}
-
-struct mbuf *
-mbuf_construct(int proto)
-{
-	struct mbuf *m;
-	struct ip *iphdr;
-	void *l4data;
-	int size;
-
-	m = m_gethdr(M_WAITOK, MT_HEADER);
-	iphdr = mtod(m, struct ip *);
-
-	iphdr->ip_v = IPVERSION;
-	iphdr->ip_hl = sizeof(struct ip) >> 2;
-	iphdr->ip_off = 0;
-	iphdr->ip_ttl = 64;
-	iphdr->ip_p = proto;
-
-	size = sizeof(struct ip);
-	l4data = (void *)(iphdr + 1);
-	size += mbuf_fill_proto(proto, l4data);
-	iphdr->ip_len = htons(size);
-
-	m->m_pkthdr.len = size;
-	m->m_len = size;
-	m->m_next = NULL;
-	return m;
-}
-
-struct mbuf *
-mbuf_construct6(int proto)
-{
-	struct mbuf *m;
-	struct ip6_hdr *ip6;
-	void *l4data;
-	int size;
-
-	m = m_gethdr(M_WAITOK, MT_HEADER);
-	ip6 = mtod(m, struct ip6_hdr *);
-
-	ip6->ip6_vfc = IPV6_VERSION;
-	ip6->ip6_nxt = proto;
-	ip6->ip6_hlim = 64;
-
-	size = sizeof(struct ip6_hdr);
-	l4data = (void *)(ip6 + 1);
-	size += mbuf_fill_proto(proto, l4data);
-	ip6->ip6_plen = htons(size);
-
-	m->m_pkthdr.len = size;
-	m->m_len = size;
-	m->m_next = NULL;
-	return m;
-}
-
-void *
-mbuf_return_hdrs(struct mbuf *m, bool ether, struct ip **ip)
-{
-	struct ip *iphdr;
-
-	if (ether) {
-		struct mbuf *mn = m->m_next;
-		iphdr = mtod(mn, struct ip *);
-	} else {
-		iphdr = mtod(m, struct ip *);
-	}
-	*ip = iphdr;
-	return (void *)(iphdr + 1);
-}
-
-void *
-mbuf_return_hdrs6(struct mbuf *m, struct ip6_hdr **ip6)
-{
-	struct ip6_hdr *ip6hdr = mtod(m, struct ip6_hdr *);
-
-	*ip6 = ip6hdr;
-	return (void *)(ip6hdr + 1);
-}
-
-void
-mbuf_icmp_append(struct mbuf *m, struct mbuf *m_orig)
-{
-	struct ip *iphdr = mtod(m, struct ip *);
-	const size_t hlen = iphdr->ip_hl << 2;
-	void *p = (uint8_t *)iphdr + hlen;
-	struct icmp *ic = (struct icmp *)p;
-	const size_t addlen = m_length(m_orig);
-
-	iphdr->ip_len = htons(ntohs(iphdr->ip_len) + addlen);
-	memcpy(&ic->icmp_ip, mtod(m_orig, struct ip *), addlen);
-	m->m_pkthdr.len += addlen;
-	m->m_len += addlen;
-	m_freem(m_orig);
-}
-
-struct mbuf *
-mbuf_get_pkt(int af, int proto, const char *src, const char *dst,
-    int sport, int dport)
-{
-	struct mbuf *m;
-	struct ip *ip;
-	struct ip6_hdr *ip6;
-	struct tcphdr *th;
-	struct udphdr *uh;
-	void *p, *ipsrc, *ipdst;
-
-	switch (af) {
-	case AF_INET6:
-		m = mbuf_construct6(proto);
-		p = mbuf_return_hdrs6(m, &ip6);
-		ipsrc = &ip6->ip6_src;
-		ipdst = &ip6->ip6_dst;
-		break;
-	case AF_INET:
-	default:
-		m = mbuf_construct(proto);
-		p = mbuf_return_hdrs(m, false, &ip);
-		ipsrc = &ip->ip_src.s_addr;
-		ipdst = &ip->ip_dst.s_addr;
-	}
-
-	npf_inet_pton(af, src, ipsrc);
-	npf_inet_pton(af, dst, ipdst);
-
-	switch (proto) {
-	case IPPROTO_TCP:
-		th = p;
-		th->th_sport = htons(sport);
-		th->th_dport = htons(dport);
-		break;
-	case IPPROTO_UDP:
-		uh = p;
-		uh->uh_sport = htons(sport);
-		uh->uh_dport = htons(dport);
-		break;
-	default:
-		KASSERT(false);
-	}
-	return m;
-}
-
-npf_cache_t *
-get_cached_pkt(struct mbuf *m, const char *ifname)
-{
-	ifnet_t *ifp = npf_test_getif(ifname ? ifname : IFNAME_DUMMY);
-	npf_cache_t *npc = kmem_zalloc(sizeof(npf_cache_t), KM_SLEEP);
-	nbuf_t *nbuf = kmem_zalloc(sizeof(nbuf_t), KM_SLEEP);
-	int ret;
-
-	npc->npc_info = 0;
-	npc->npc_ctx = npf_getkernctx();
-
-	nbuf_init(npc->npc_ctx, nbuf, m, ifp);
-	npc->npc_nbuf = nbuf;
-	ret = npf_cache_all(npc);
-	assert(ret); (void)ret;
-
-	return npc;
-}
-
-void
-put_cached_pkt(npf_cache_t *npc)
-{
-	struct mbuf *m = nbuf_head_mbuf(npc->npc_nbuf);
-	kmem_free(npc->npc_nbuf, sizeof(nbuf_t));
-	kmem_free(npc, sizeof(npf_cache_t));
-	m_freem(m);
-}
-
-const npf_mbufops_t npftest_mbufops = {
-	.alloc			= npfkern_m_get,
-	.free			= npfkern_m_freem,
-	.getdata		= npfkern_m_getdata,
-	.getnext		= npfkern_m_next,
-	.getlen			= npfkern_m_buflen,
-	.getchainlen		= npfkern_m_length,
-	.ensure_contig		= npfkern_m_ensure_contig,
-	.ensure_writable	= NULL,
-};
diff --git a/src/npftest/libnpftest/npf_nat_test.c b/src/npftest/libnpftest/npf_nat_test.c
deleted file mode 100644
index d3a06c0..0000000
--- a/src/npftest/libnpftest/npf_nat_test.c
+++ /dev/null
@@ -1,244 +0,0 @@
-/*
- * NPF NAT tests.
- *
- * Public Domain.
- */
-
-#ifdef _KERNEL
-#include <sys/types.h>
-#endif
-
-#include "npf_impl.h"
-#include "npf_test.h"
-
-#define	RESULT_PASS	0
-#define	RESULT_BLOCK	ENETUNREACH
-
-#define	NPF_BINAT	(NPF_NATIN | NPF_NATOUT)
-
-#define	RANDOM_PORT	18791
-
-static const struct test_case {
-	const char *	src;
-	in_port_t	sport;
-	const char *	dst;
-	in_port_t	dport;
-	int		ttype;
-	const char *	ifname;
-	int		di;
-	int		ret;
-	int		af;
-	const char *	taddr;
-	in_port_t	tport;
-} test_cases[] = {
-
-	/*
-	 * Traditional NAPT (outbound NAT):
-	 *	map $ext_if dynamic $local_net -> $pub_ip1
-	 */
-	{
-		LOCAL_IP1,	15000,		REMOTE_IP1,	7000,
-		NPF_NATOUT,	IFNAME_EXT,	PFIL_OUT,
-		RESULT_PASS,	AF_INET,	PUB_IP1,	RANDOM_PORT
-	},
-	{
-		LOCAL_IP1,	15000,		REMOTE_IP1,	7000,
-		NPF_NATOUT,	IFNAME_EXT,	PFIL_OUT,
-		RESULT_PASS,	AF_INET,	PUB_IP1,	RANDOM_PORT
-	},
-	{
-		LOCAL_IP1,	15000,		REMOTE_IP1,	7000,
-		NPF_NATOUT,	IFNAME_EXT,	PFIL_IN,
-		RESULT_BLOCK,	AF_INET,	NULL,		0
-	},
-	{
-		REMOTE_IP1,	7000,		LOCAL_IP1,	15000,
-		NPF_NATOUT,	IFNAME_EXT,	PFIL_IN,
-		RESULT_BLOCK,	AF_INET,	NULL,		0
-	},
-	{
-		REMOTE_IP1,	7000,		PUB_IP1,	RANDOM_PORT,
-		NPF_NATOUT,	IFNAME_INT,	PFIL_IN,
-		RESULT_BLOCK,	AF_INET,	NULL,		0
-	},
-	{
-		REMOTE_IP1,	7000,		PUB_IP1,	RANDOM_PORT,
-		NPF_NATOUT,	IFNAME_EXT,	PFIL_IN,
-		RESULT_PASS,	AF_INET,	LOCAL_IP1,	15000
-	},
-
-	/*
-	 * NAT redirect (inbound NAT):
-	 *	map $ext_if dynamic $local_ip1 port 6000 <- $pub_ip1 port 8000
-	 */
-	{
-		REMOTE_IP2,	16000,		PUB_IP1,	8000,
-		NPF_NATIN,	IFNAME_EXT,	PFIL_IN,
-		RESULT_PASS,	AF_INET,	LOCAL_IP1,	6000
-	},
-	{
-		LOCAL_IP1,	6000,		REMOTE_IP2,	16000,
-		NPF_NATIN,	IFNAME_EXT,	PFIL_OUT,
-		RESULT_PASS,	AF_INET,	PUB_IP1,	8000
-	},
-
-	/*
-	 * Bi-directional NAT (inbound + outbound NAT):
-	 *	map $ext_if dynamic $local_ip2 <-> $pub_ip2
-	 */
-	{
-		REMOTE_IP2,	17000,		PUB_IP2,	9000,
-		NPF_BINAT,	IFNAME_EXT,	PFIL_IN,
-		RESULT_PASS,	AF_INET,	LOCAL_IP2,	9000
-	},
-	{
-		LOCAL_IP2,	9000,		REMOTE_IP2,	17000,
-		NPF_BINAT,	IFNAME_EXT,	PFIL_OUT,
-		RESULT_PASS,	AF_INET,	PUB_IP2,	9000
-	},
-	{
-		LOCAL_IP2,	18000,		REMOTE_IP2,	9000,
-		NPF_BINAT,	IFNAME_EXT,	PFIL_OUT,
-		RESULT_PASS,	AF_INET,	PUB_IP2,	18000
-	},
-	{
-		REMOTE_IP2,	9000,		PUB_IP2,	18000,
-		NPF_BINAT,	IFNAME_EXT,	PFIL_IN,
-		RESULT_PASS,	AF_INET,	LOCAL_IP2,	18000
-	},
-
-	/*
-	 * Static NAT: plain translation both ways.
-	 *	map $ext_if static $local_ip3 <-> $pub_ip3
-	 */
-	{
-		LOCAL_IP3,	19000,		REMOTE_IP3,	10000,
-		NPF_BINAT,	IFNAME_EXT,	PFIL_OUT,
-		RESULT_PASS,	AF_INET,	PUB_IP3,	19000
-	},
-	{
-		REMOTE_IP3,	10000,		PUB_IP3,	19000,
-		NPF_BINAT,	IFNAME_EXT,	PFIL_IN,
-		RESULT_PASS,	AF_INET,	LOCAL_IP3,	19000
-	},
-
-	/*
-	 * NETMAP case:
-	 *	map $ext_if static algo netmap $net_a <-> $net_b
-	 */
-	{
-		NET_A_IP1,	12345,		REMOTE_IP4,	12345,
-		NPF_BINAT,	IFNAME_EXT,	PFIL_OUT,
-		RESULT_PASS,	AF_INET,	NET_B_IP1,	12345
-	},
-
-	/*
-	 * NPTv6 case:
-	 *	map $ext_if static algo npt66 $net6_inner <-> $net6_outer
-	 */
-	{
-		LOCAL_IP6,	1000,		REMOTE_IP6,	1001,
-		NPF_BINAT,	IFNAME_EXT,	PFIL_OUT,
-		RESULT_PASS,	AF_INET6,	EXPECTED_IP6,	1000
-	},
-	{
-		REMOTE_IP6,	1001,		EXPECTED_IP6,	1000,
-		NPF_BINAT,	IFNAME_EXT,	PFIL_IN,
-		RESULT_PASS,	AF_INET6,	LOCAL_IP6,	1000
-	},
-
-};
-
-static bool
-match_addr(int af, const char *saddr, const npf_addr_t *addr2)
-{
-	npf_addr_t addr1;
-	size_t len;
-
-	npf_inet_pton(af, saddr, &addr1);
-	len = af == AF_INET ? sizeof(struct in_addr) : sizeof(struct in6_addr);
-	return memcmp(&addr1, addr2, len) == 0;
-}
-
-static bool
-checkresult(bool verbose, unsigned i, struct mbuf *m, ifnet_t *ifp, int error)
-{
-	const struct test_case *t = &test_cases[i];
-	const int af = t->af;
-	npf_cache_t npc;
-	nbuf_t nbuf;
-
-	if (verbose) {
-		printf("packet %d (expected %d ret %d)\n", i+1, t->ret, error);
-	}
-	if (error) {
-		return error == t->ret;
-	}
-
-	nbuf_init(npf_getkernctx(), &nbuf, m, ifp);
-	memset(&npc, 0, sizeof(npf_cache_t));
-	npc.npc_ctx = npf_getkernctx();
-	npc.npc_nbuf = &nbuf;
-
-	if (!npf_cache_all(&npc)) {
-		printf("error: could not fetch the packet data");
-		return false;
-	}
-
-	const struct udphdr *uh = npc.npc_l4.udp;
-
-	if (verbose) {
-		char sbuf[64], dbuf[64];
-
-		npf_inet_ntop(af, npc.npc_ips[NPF_SRC], sbuf, sizeof(sbuf));
-		npf_inet_ntop(af, npc.npc_ips[NPF_DST], dbuf, sizeof(dbuf));
-
-		printf("\tpost-translation: ");
-		printf("src %s (%d) ", sbuf, ntohs(uh->uh_sport));
-		printf("dst %s (%d)\n", dbuf, ntohs(uh->uh_dport));
-	}
-	if (error != t->ret) {
-		return false;
-	}
-
-	const bool forw = t->di == PFIL_OUT;
-	const char *saddr = forw ? t->taddr : t->src;
-	const char *daddr = forw ? t->dst : t->taddr;
-	in_addr_t sport = forw ? t->tport : t->sport;
-	in_addr_t dport = forw ? t->dport : t->tport;
-
-	CHECK_TRUE(match_addr(af, saddr, npc.npc_ips[NPF_SRC]));
-	CHECK_TRUE(sport == ntohs(uh->uh_sport));
-	CHECK_TRUE(match_addr(af, daddr, npc.npc_ips[NPF_DST]));
-	CHECK_TRUE(dport == ntohs(uh->uh_dport));
-
-	return true;
-}
-
-bool
-npf_nat_test(bool verbose)
-{
-	npf_t *npf = npf_getkernctx();
-
-	for (unsigned i = 0; i < __arraycount(test_cases); i++) {
-		const struct test_case *t = &test_cases[i];
-		ifnet_t *ifp = npf_test_getif(t->ifname);
-		struct mbuf *m;
-		int error;
-		bool ret;
-
-		if (ifp == NULL) {
-			printf("Interface %s is not configured.\n", t->ifname);
-			return false;
-		}
-		m = mbuf_get_pkt(t->af, IPPROTO_UDP,
-		    t->src, t->dst, t->sport, t->dport);
-		error = npfk_packet_handler(npf, &m, ifp, t->di);
-		ret = checkresult(verbose, i, m, ifp, error);
-		if (m) {
-			m_freem(m);
-		}
-		CHECK_TRUE(ret);
-	}
-	return true;
-}
diff --git a/src/npftest/libnpftest/npf_nbuf_test.c b/src/npftest/libnpftest/npf_nbuf_test.c
deleted file mode 100644
index d32d969..0000000
--- a/src/npftest/libnpftest/npf_nbuf_test.c
+++ /dev/null
@@ -1,214 +0,0 @@
-/*
- * NPF nbuf interface tests.
- *
- * Public Domain.
- */
-
-#ifdef _KERNEL
-#include <sys/types.h>
-#include <sys/kmem.h>
-#endif
-
-#include "npf_impl.h"
-#include "npf_test.h"
-
-#define	MBUF_CHAIN_LEN		128
-
-CTASSERT((MBUF_CHAIN_LEN % sizeof(uint32_t)) == 0);
-
-static void
-mbuf_consistency_check(nbuf_t *nbuf)
-{
-	struct mbuf *m = nbuf_head_mbuf(nbuf);
-
-	while (m) {
-		assert(m->m_type != MT_FREE);
-		m = m->m_next;
-	}
-}
-
-static char *
-parse_nbuf_chain(struct mbuf *m)
-{
-	ifnet_t *dummy_ifp = npf_test_addif(IFNAME_TEST, false, false);
-	char *s = kmem_zalloc(MBUF_CHAIN_LEN + 1, KM_SLEEP);
-	nbuf_t nbuf;
-	void *nptr;
-	int n;
-
-	nbuf_init(npf_getkernctx(), &nbuf, m, dummy_ifp);
-
-	nptr = nbuf_advance(&nbuf, (random() % 16) + 1, (random() % 16) + 1);
-	mbuf_consistency_check(&nbuf);
-	assert(nptr != NULL);
-	nbuf_reset(&nbuf);
-
-	for (n = 0; ; ) {
-		char d[4 + 1];
-
-		nptr = nbuf_ensure_contig(&nbuf, sizeof(uint32_t));
-		if (nptr == NULL) {
-			break;
-		}
-		mbuf_consistency_check(&nbuf);
-		memcpy(&d, nptr, sizeof(uint32_t));
-
-		d[sizeof(d) - 1] = '\0';
-		strcat(s, d);
-
-		if (n + sizeof(uint32_t) == MBUF_CHAIN_LEN) {
-			assert(nbuf_advance(&nbuf, sizeof(uint32_t) - 1, 0));
-			assert(!nbuf_advance(&nbuf, 1, 0));
-			break;
-		}
-		if (!nbuf_advance(&nbuf, sizeof(uint32_t), 0)) {
-			break;
-		}
-		n += sizeof(uint32_t);
-	}
-	mbuf_consistency_check(&nbuf);
-	m_freem(nbuf_head_mbuf(&nbuf));
-	return s;
-}
-
-static char *
-mbuf_getstring(struct mbuf *m)
-{
-	char *s = kmem_zalloc(MBUF_CHAIN_LEN + 1, KM_SLEEP);
-	unsigned tlen = 0;
-
-	while (m) {
-		int len = m->m_len;
-		char *d = m->m_data;
-		while (len--) {
-			s[tlen++] = *d++;
-		}
-		m = m->m_next;
-	}
-	return s;
-}
-
-static struct mbuf *
-mbuf_alloc_with_off(size_t off, int len)
-{
-	struct mbuf *m;
-
-	KASSERT(off + len < MLEN);
-	m = m_get(M_WAITOK, MT_DATA);
-	m->m_data = (char *)m->m_data + off;
-	m->m_len = len;
-	return m;
-}
-
-/*
- * Create an mbuf chain, each of 1 byte size.
- */
-static struct mbuf *
-mbuf_bytesize(size_t clen)
-{
-	struct mbuf *m0 = NULL, *m = NULL;
-	unsigned i, n;
-
-	/* Chain of clen (e.g. 128) mbufs, each storing 1 byte of data. */
-	for (i = 0, n = 0; i < clen; i++) {
-		/* Range of offset: 0 .. 15. */
-		m0 = mbuf_alloc_with_off(n & 0xf, 1);
-
-		/* Fill data with letters from 'a' to 'z'. */
-		memset(m0->m_data, 'a' + n, 1);
-		n = ('a' + n) < 'z' ? n + 1 : 0;
-
-		/* Next mbuf.. */
-		m0->m_next = m;
-		m = m0;
-	}
-
-	m0 = m_gethdr(M_WAITOK, MT_HEADER);
-	m0->m_pkthdr.len = clen;
-	m0->m_len = 0;
-	m0->m_next = m;
-	return m0;
-}
-
-/*
- * Generate random number of mbufs, with random offsets and lengths.
- */
-static struct mbuf *
-mbuf_random_len(size_t chain_len)
-{
-	struct mbuf *m0 = NULL, *m = NULL;
-	unsigned tlen = 0, n = 0;
-
-	while (tlen < chain_len) {
-		unsigned off, len;
-		char *d;
-
-		/* Random offset and length range: 1 .. 16. */
-		off = (random() % 16) + 1;
-		len = (random() % 16) + 1;
-
-		/* Do not exceed 128 bytes of total length. */
-		if (tlen + len > chain_len) {
-			len = chain_len - tlen;
-		}
-		tlen += len;
-
-		/* Consistently fill data with letters from 'a' to 'z'. */
-		m0 = mbuf_alloc_with_off(off, len);
-		d = m0->m_data;
-		while (len--) {
-			*d++ = ('a' + n);
-			n = ('a' + n) < 'z' ? n + 1 : 0;
-		}
-
-		/* Next mbuf.. */
-		m0->m_next = m;
-		m = m0;
-	}
-	KASSERT(tlen == chain_len);
-
-	m0 = m_gethdr(M_WAITOK, MT_HEADER);
-	m0->m_pkthdr.len = tlen;
-	m0->m_next = m;
-	m0->m_len = 0;
-	return m0;
-}
-
-static bool
-validate_mbuf_data(char *bufa, char *bufb)
-{
-	bool ok = strcmp(bufa, bufb) == 0;
-
-	if (!ok) {
-		printf("Buffer A: %s\nBuffer B: %s\n", bufa, bufb);
-	}
-	kmem_free(bufa, MBUF_CHAIN_LEN + 1);
-	kmem_free(bufb, MBUF_CHAIN_LEN + 1);
-	return ok;
-}
-
-bool
-npf_nbuf_test(bool verbose)
-{
-	struct mbuf *m;
-	char *bufa, *bufb;
-	unsigned n = 10000;
-	bool ok;
-
-	while (n--) {
-		m = mbuf_random_len(MBUF_CHAIN_LEN);
-		bufa = mbuf_getstring(m);
-		bufb = parse_nbuf_chain(m);
-		ok = validate_mbuf_data(bufa, bufb);
-		CHECK_TRUE(ok);
-	}
-
-	m = mbuf_bytesize(MBUF_CHAIN_LEN);
-	bufa = mbuf_getstring(m);
-	bufb = parse_nbuf_chain(m);
-	ok = validate_mbuf_data(bufa, bufb);
-	CHECK_TRUE(ok);
-
-	(void)verbose;
-	return true;
-}
diff --git a/src/npftest/libnpftest/npf_perf_test.c b/src/npftest/libnpftest/npf_perf_test.c
deleted file mode 100644
index 6c71715..0000000
--- a/src/npftest/libnpftest/npf_perf_test.c
+++ /dev/null
@@ -1,90 +0,0 @@
-/*
- * NPF benchmarking.
- *
- * Public Domain.
- */
-
-#ifdef _KERNEL
-#include <sys/types.h>
-#include <sys/param.h>
-
-#include <sys/kernel.h>
-#include <sys/kmem.h>
-#include <sys/kthread.h>
-#endif
-
-#include "npf_impl.h"
-#include "npf_test.h"
-
-#define	NSECS		10 /* seconds */
-
-static volatile int	run;
-static volatile int	done;
-
-static uint64_t *	npackets;
-static bool		stateful;
-
-__dead static void
-worker(void *arg)
-{
-	npf_t *npf = npf_getkernctx();
-	ifnet_t *ifp = npf_test_getif(IFNAME_INT);
-	unsigned int i = (uintptr_t)arg;
-	struct mbuf *m;
-	uint64_t n = 0;
-
-	m = mbuf_get_pkt(AF_INET, IPPROTO_UDP,
-	    PUB_IP1, stateful ? LOCAL_IP2 : LOCAL_IP3,
-	    80, 15000 + i);
-
-	while (!run)
-		/* spin-wait */;
-	while (!done) {
-		int error;
-
-		error = npfk_packet_handler(npf, &m, ifp, PFIL_OUT);
-		KASSERT(error == 0); (void)error;
-		n++;
-	}
-	npackets[i] = n;
-	m_freem(m);
-	kthread_exit(0);
-}
-
-void
-npf_test_conc(bool st, unsigned nthreads)
-{
-	uint64_t total = 0;
-	int error;
-	lwp_t **l;
-
-	printf("THREADS\tPKTS\n");
-	stateful = st;
-	done = false;
-	run = false;
-
-	npackets = kmem_zalloc(sizeof(uint64_t) * nthreads, KM_SLEEP);
-	l = kmem_zalloc(sizeof(lwp_t *) * nthreads, KM_SLEEP);
-
-	for (unsigned i = 0; i < nthreads; i++) {
-		error = kthread_create(PRI_NONE, KTHREAD_MUSTJOIN |
-		    KTHREAD_MPSAFE, NULL, worker, (void *)(uintptr_t)i,
-		    &l[i], "npfperf");
-		KASSERT(error == 0); (void)error;
-	}
-
-	/* Let them spin! */
-	run = true;
-	kpause("perf", false, mstohz(NSECS * 1000), NULL);
-	done = true;
-
-	/* Wait until all threads exit and sum the counts. */
-	for (unsigned i = 0; i < nthreads; i++) {
-		kthread_join(l[i]);
-		total += npackets[i];
-	}
-	kmem_free(npackets, sizeof(uint64_t) * nthreads);
-	kmem_free(l, sizeof(lwp_t *) * nthreads);
-
-	printf("%u\t%" PRIu64 "\n", nthreads, total / NSECS);
-}
diff --git a/src/npftest/libnpftest/npf_rule_test.c b/src/npftest/libnpftest/npf_rule_test.c
deleted file mode 100644
index 6b57d79..0000000
--- a/src/npftest/libnpftest/npf_rule_test.c
+++ /dev/null
@@ -1,192 +0,0 @@
-/*
- * NPF ruleset tests.
- *
- * Public Domain.
- */
-
-#ifdef _KERNEL
-#include <sys/types.h>
-#endif
-
-#include "npf_impl.h"
-#include "npf_test.h"
-
-#define	RESULT_PASS	0
-#define	RESULT_BLOCK	ENETUNREACH
-
-static const struct test_case {
-	const char *	src;
-	const char *	dst;
-	const char *	ifname;
-	int		di;
-	int		stateful_ret;
-	int		ret;
-} test_cases[] = {
-
-	/* Stateful pass. */
-	{
-		.src = "10.1.1.1",		.dst = "10.1.1.2",
-		.ifname = IFNAME_INT,		.di = PFIL_OUT,
-		.stateful_ret = RESULT_PASS,	.ret = RESULT_PASS
-	},
-	{
-		.src = "10.1.1.2",		.dst = "10.1.1.1",
-		.ifname = IFNAME_INT,		.di = PFIL_IN,
-		.stateful_ret = RESULT_PASS,	.ret = RESULT_BLOCK
-	},
-
-	/* Pass forwards stream only. */
-	{
-		.src = "10.1.1.1",		.dst = "10.1.1.3",
-		.ifname = IFNAME_INT,		.di = PFIL_OUT,
-		.stateful_ret = RESULT_PASS,	.ret = RESULT_PASS
-	},
-	{
-		.src = "10.1.1.3",		.dst = "10.1.1.1",
-		.ifname = IFNAME_INT,		.di = PFIL_IN,
-		.stateful_ret = RESULT_BLOCK,	.ret = RESULT_BLOCK
-	},
-
-	/* Block. */
-	{	.src = "10.1.1.1",		.dst = "10.1.1.4",
-		.ifname = IFNAME_INT,		.di = PFIL_OUT,
-		.stateful_ret = RESULT_BLOCK,	.ret = RESULT_BLOCK
-	},
-
-};
-
-static int
-run_raw_testcase(unsigned i)
-{
-	const struct test_case *t = &test_cases[i];
-	npf_t *npf = npf_getkernctx();
-	npf_cache_t *npc;
-	struct mbuf *m;
-	npf_rule_t *rl;
-	int slock, error;
-
-	m = mbuf_get_pkt(AF_INET, IPPROTO_UDP, t->src, t->dst, 9000, 9000);
-	npc = get_cached_pkt(m, t->ifname);
-
-	slock = npf_config_read_enter(npf);
-	rl = npf_ruleset_inspect(npc, npf_config_ruleset(npf), t->di, NPF_LAYER_3);
-	if (rl) {
-		npf_match_info_t mi;
-		error = npf_rule_conclude(rl, &mi);
-	} else {
-		error = ENOENT;
-	}
-	npf_config_read_exit(npf, slock);
-
-	put_cached_pkt(npc);
-	return error;
-}
-
-static int
-run_handler_testcase(unsigned i)
-{
-	const struct test_case *t = &test_cases[i];
-	ifnet_t *ifp = npf_test_getif(t->ifname);
-	npf_t *npf = npf_getkernctx();
-	struct mbuf *m;
-	int error;
-
-	m = mbuf_get_pkt(AF_INET, IPPROTO_UDP, t->src, t->dst, 9000, 9000);
-	error = npfk_packet_handler(npf, &m, ifp, t->di);
-	if (m) {
-		m_freem(m);
-	}
-	return error;
-}
-
-static npf_rule_t *
-npf_blockall_rule(void)
-{
-	npf_t *npf = npf_getkernctx();
-	nvlist_t *rule = nvlist_create(0);
-	npf_rule_t *rl;
-
-	nvlist_add_number(rule, "attr",
-	    NPF_RULE_IN | NPF_RULE_OUT | NPF_RULE_DYNAMIC);
-	rl = npf_rule_alloc(npf, rule);
-	nvlist_destroy(rule);
-	return rl;
-}
-
-static bool
-test_static(bool verbose)
-{
-	for (unsigned i = 0; i < __arraycount(test_cases); i++) {
-		const struct test_case *t = &test_cases[i];
-		int error, serror;
-
-		if (npf_test_getif(t->ifname) == NULL) {
-			printf("Interface %s is not configured.\n", t->ifname);
-			return false;
-		}
-
-		error = run_raw_testcase(i);
-		serror = run_handler_testcase(i);
-
-		if (verbose) {
-			printf("rule test %d:\texpected %d (stateful) and %d\n"
-			    "\t\t-> returned %d and %d\n",
-			    i + 1, t->stateful_ret, t->ret, serror, error);
-		}
-		CHECK_TRUE(error == t->ret);
-		CHECK_TRUE(serror == t->stateful_ret)
-	}
-	return true;
-}
-
-static bool
-test_dynamic(void)
-{
-	npf_t *npf = npf_getkernctx();
-	npf_ruleset_t *rlset;
-	npf_rule_t *rl;
-	uint64_t id;
-	int error;
-
-	/*
-	 * Test dynamic NPF rules.
-	 */
-
-	error = run_raw_testcase(0);
-	CHECK_TRUE(error == RESULT_PASS);
-
-	npf_config_enter(npf);
-	rlset = npf_config_ruleset(npf);
-
-	rl = npf_blockall_rule();
-	error = npf_ruleset_add(rlset, "test-rules", rl);
-	CHECK_TRUE(error == 0);
-
-	error = run_raw_testcase(0);
-	CHECK_TRUE(error == RESULT_BLOCK);
-
-	id = npf_rule_getid(rl);
-	error = npf_ruleset_remove(rlset, "test-rules", id);
-	CHECK_TRUE(error == 0);
-
-	npf_config_exit(npf);
-
-	error = run_raw_testcase(0);
-	CHECK_TRUE(error == RESULT_PASS);
-
-	return true;
-}
-
-bool
-npf_rule_test(bool verbose)
-{
-	bool ok;
-
-	ok = test_static(verbose);
-	CHECK_TRUE(ok);
-
-	ok = test_dynamic();
-	CHECK_TRUE(ok);
-
-	return true;
-}
diff --git a/src/npftest/libnpftest/npf_state_test.c b/src/npftest/libnpftest/npf_state_test.c
deleted file mode 100644
index 1a5b3a5..0000000
--- a/src/npftest/libnpftest/npf_state_test.c
+++ /dev/null
@@ -1,177 +0,0 @@
-/*
- * NPF state tracking tests.
- *
- * Public Domain.
- */
-
-#ifdef _KERNEL
-#include <sys/types.h>
-#include <sys/kmem.h>
-#endif
-
-#include "npf_impl.h"
-#include "npf_test.h"
-
-typedef struct {
-	int		tcpfl;		/* TCP flags. */
-	int		tlen;		/* TCP data length. */
-	uint32_t	seq;		/* SEQ number. */
-	uint32_t	ack;		/* ACK number. */
-	uint32_t	win;		/* TCP Window. */
-	int		flags;		/* Direction et al. */
-} tcp_meta_t;
-
-#define	S	TH_SYN
-#define	A	TH_ACK
-#define	F	TH_FIN
-#define	OUT	0x1
-#define	IN	0x2
-#define	ERR	0x4
-#define	CLEAR	.flags = 0
-
-static const tcp_meta_t packet_sequence[] = {
-	/*
-	 *	TCP data	SEQ	ACK		WIN
-	 */
-
-	/* Out of order ACK. */
-	{ S,	0,		9999,	0,		4096,	OUT	},
-	{ S|A,	0,		9,	10000,		2048,	IN	},
-	{ A,	0,		10000,	10,		4096,	OUT	},
-	/* --- */
-	{ A,	0,		10,	10000,		2048,	IN	},
-	{ A,	1000,		10000,	10,		4096,	OUT	},
-	{ A,	1000,		11000,	10,		4096,	OUT	},
-	{ A,	0,		10,	12000,		2048,	IN	},
-	{ A,	0,		10,	13000,		2048,	IN	},
-	{ A,	1000,		12000,	10,		4096,	OUT	},
-	{ A,	0,		10,	11000,		1048,	IN	},
-	/* --- */
-	{ A,	1000,		14000,	10,		4096,	OUT	},
-	{ A,	0,		10,	13000,		2048,	IN	},
-	{ CLEAR },
-
-	/* Retransmission after out of order ACK and missing ACK. */
-	{ S,	0,		9999,	0,		1000,	OUT	},
-	{ S|A,	0,		9,	10000,		4000,	IN	},
-	{ A,	0,		10000,	10,		1000,	OUT	},
-	/* --- */
-	{ A,	1000,		10000,	10,		1000,	OUT	},
-	{ A,	0,		10,	11000,		4000,	IN	},
-	{ A,	1000,		11000,	10,		1000,	OUT	},
-	{ A,	1000,		12000,	10,		1000,	OUT	},
-	{ A,	1000,		13000,	10,		1000,	OUT	},
-	{ A,	1000,		14000,	10,		1000,	OUT	},
-	/* --- Assume the first was delayed; second was lost after us. */
-	{ A,	0,		10,	15000,		4000,	IN	},
-	{ A,	0,		10,	15000,		2000,	IN	},
-	/* --- */
-	{ A,	1000,		12000,	10,		1000,	OUT	},
-	{ CLEAR },
-
-	/* FIN exchange with retransmit. */
-	{ S,	0,		999,	0,		1000,	OUT	},
-	{ S|A,	0,		9,	1000,		2000,	IN	},
-	{ A,	0,		1000,	10,		1000,	OUT	},
-	/* --- */
-	{ F,	0,		10,	1000,		2000,	IN	},
-	{ F,	0,		1000,	10,		1000,	OUT	},
-	{ A,	0,		1000,	11,		1000,	OUT	},
-	/* --- */
-	{ F,	0,		1000,	11,		1000,	OUT	},
-	{ F,	0,		1000,	11,		1000,	OUT	},
-	{ A,	0,		11,	1001,		2000,	OUT	},
-	{ CLEAR },
-
-	/* Out of window. */
-	{ S,	0,		9,	0,		8760,	OUT	},
-	{ S|A,	0,		9999,	10,		1000,	IN	},
-	{ A,	0,		10,	10000,		8760,	OUT	},
-	/* --- */
-	{ A,	1460,		10000,	10,		1000,	IN	},
-	{ A,	1460,		11460,	10,		1000,	IN	},
-	{ A,	0,		10,	12920,		8760,	OUT	},
-	{ A,	1460,		12920,	10,		1000,	IN	},
-	{ A,	0,		10,	14380,		8760,	OUT	},
-	{ A,	1460,		17300,	10,		1000,	IN	},
-	{ A,	0,		10,	14380,		8760,	OUT	},
-	{ A,	1460,		18760,	10,		1000,	IN	},
-	{ A,	0,		10,	14380,		8760,	OUT	},
-	{ A,	1460,		20220,	10,		1000,	IN	},
-	{ A,	0,		10,	14380,		8760,	OUT	},
-	{ A,	1460,		21680,	10,		1000,	IN	},
-	{ A,	0,		10,	14380,		8760,	OUT	},
-	/* --- */
-	{ A,	1460,		14380,	10,		1000,	IN	},
-	{ A,	1460,		23140,	10,		1000,	IN|ERR	},
-	{ CLEAR },
-
-};
-
-#undef S
-#undef A
-#undef F
-
-static struct mbuf *
-construct_packet(const tcp_meta_t *p)
-{
-	struct mbuf *m = mbuf_construct(IPPROTO_TCP);
-	struct ip *ip;
-	struct tcphdr *th;
-
-	th = mbuf_return_hdrs(m, false, &ip);
-
-	/* Imitate TCP payload, set TCP sequence numbers, flags and window. */
-	ip->ip_len = htons(sizeof(struct ip) + sizeof(struct tcphdr) + p->tlen);
-	th->th_seq = htonl(p->seq);
-	th->th_ack = htonl(p->ack);
-	th->th_flags = p->tcpfl;
-	th->th_win = htons(p->win);
-	return m;
-}
-
-static bool
-process_packet(const int i, npf_state_t *nst, bool *snew)
-{
-	const tcp_meta_t *p = &packet_sequence[i];
-	npf_cache_t *npc;
-	int ret;
-
-	if (p->flags == 0) {
-		npf_state_destroy(nst);
-		*snew = true;
-		return true;
-	}
-
-	npc = get_cached_pkt(construct_packet(p), NULL);
-	if (*snew) {
-		ret = npf_state_init(npc, nst);
-		KASSERT(ret == true);
-		*snew = false;
-	}
-	ret = npf_state_inspect(npc, nst,
-	    (p->flags == OUT) ? NPF_FLOW_FORW : NPF_FLOW_BACK);
-	put_cached_pkt(npc);
-
-	return ret ? true : (p->flags & ERR) != 0;
-}
-
-bool
-npf_state_test(bool verbose)
-{
-	npf_state_t nst;
-	bool snew = true;
-	bool ok = true;
-
-	for (unsigned i = 0; i < __arraycount(packet_sequence); i++) {
-		if (process_packet(i, &nst, &snew)) {
-			continue;
-		}
-		if (verbose) {
-			printf("Failed on packet %d, state dump:\n", i);
-			npf_state_dump(&nst);
-		}
-		ok = false;
-	}
-	return ok;
-}
diff --git a/src/npftest/libnpftest/npf_table_test.c b/src/npftest/libnpftest/npf_table_test.c
deleted file mode 100644
index b70c4de..0000000
--- a/src/npftest/libnpftest/npf_table_test.c
+++ /dev/null
@@ -1,501 +0,0 @@
-/*
- * NPF tableset tests.
- *
- * Public Domain.
- */
-
-#ifdef _KERNEL
-#include <sys/types.h>
-#include <sys/kmem.h>
-#endif
-
-#ifdef __linux__
-#include <endian.h>
-#else
-#include <sys/endian.h>
-#endif
-
-#include "npf_impl.h"
-#include "npf_test.h"
-
-static const char *ip_list[] = {
-	"192.168.1.1",
-	"10.0.0.1",
-	"192.168.2.1",
-	"10.1.0.1",
-	"192.168.100.253",
-	"10.0.5.1",
-	"192.168.128.127",
-	"10.0.0.2",
-};
-
-static const uint8_t ip6_list[][16] = {
-	{
-		0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-		0x02, 0xa0, 0xc0, 0xff, 0xfe, 0x10, 0x12, 0x34
-	},
-	{
-		0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-		0x02, 0xa0, 0xc0, 0xff, 0x00, 0x00, 0x00, 0x00,
-	},
-	{
-		0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-	},
-	{
-		0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-		0x02, 0xa0, 0xc0, 0xff, 0xfe, 0x10, 0x12, 0x30
-	}
-};
-
-#define	IPSET_TID		0
-#define	IPSET_NAME		"ipset-table"
-
-#define	LPM_TID			1
-#define	LPM_NAME		"lpm-table"
-
-#define	CDB_TID			2
-#define	CDB_NAME		"cdb-table"
-
-#define	IFADDR_TID		3
-#define	IFADDR_NAME		".ifaddr-eth0"
-
-///////////////////////////////////////////////////////////////////////////
-
-static bool
-check_ip4(const npf_addr_t *addr, const char *ipstr)
-{
-	npf_addr_t addr_storage, *test_addr = &addr_storage;
-	const int alen = sizeof(struct in_addr);
-	test_addr->word32[0] = inet_addr(ipstr);
-	return memcmp(addr, test_addr, alen) == 0;
-}
-
-static bool
-ip4list_insert_lookup(npf_table_t *t, unsigned i)
-{
-	npf_addr_t addr_storage, *addr = &addr_storage;
-	const int alen = sizeof(struct in_addr);
-	int error;
-
-	addr->word32[0] = inet_addr(ip_list[i]);
-	error = npf_table_insert(t, alen, addr, NPF_NO_NETMASK);
-	CHECK_TRUE(error == 0);
-	error = npf_table_lookup(t, alen, addr);
-	CHECK_TRUE(error == 0);
-	return true;
-}
-
-static bool
-fill_with_ip4(npf_tableset_t *tblset)
-{
-	npf_addr_t addr_storage, *addr = &addr_storage;
-	const int alen = sizeof(struct in_addr);
-	const int nm = NPF_NO_NETMASK;
-
-	for (unsigned i = 0; i < __arraycount(ip_list); i++) {
-		npf_table_t *t;
-		int error;
-
-		addr->word32[0] = inet_addr(ip_list[i]);
-
-		t = npf_tableset_getbyname(tblset, IPSET_NAME);
-		error = npf_table_insert(t, alen, addr, nm);
-		CHECK_TRUE(error == 0);
-		error = npf_table_insert(t, alen, addr, nm);
-		CHECK_TRUE(error != 0); // duplicate
-
-		t = npf_tableset_getbyname(tblset, LPM_NAME);
-		error = npf_table_insert(t, alen, addr, nm);
-		CHECK_TRUE(error == 0);
-		error = npf_table_insert(t, alen, addr, nm);
-		CHECK_TRUE(error != 0); // duplicate
-	}
-	return true;
-}
-
-static bool
-verify_ip4(npf_tableset_t *tblset)
-{
-	npf_addr_t addr_storage, *addr = &addr_storage;
-	const size_t alen = sizeof(struct in_addr);
-	const int nm = NPF_NO_NETMASK;
-	npf_table_t *t;
-	int error;
-
-	/* Attempt to add duplicates - should fail. */
-	addr->word32[0] = inet_addr(ip_list[0]);
-
-	t = npf_tableset_getbyname(tblset, IPSET_NAME);
-	error = npf_table_insert(t, alen, addr, nm);
-	CHECK_TRUE(error != 0);
-
-	t = npf_tableset_getbyname(tblset, LPM_NAME);
-	error = npf_table_insert(t, alen, addr, nm);
-	CHECK_TRUE(error != 0);
-
-	/* Match (validate) each IP entry. */
-	for (unsigned i = 0; i < __arraycount(ip_list); i++) {
-		addr->word32[0] = inet_addr(ip_list[i]);
-
-		t = npf_tableset_getbyname(tblset, IPSET_NAME);
-		error = npf_table_lookup(t, alen, addr);
-		CHECK_TRUE(error == 0);
-
-		t = npf_tableset_getbyname(tblset, LPM_NAME);
-		error = npf_table_lookup(t, alen, addr);
-		CHECK_TRUE(error == 0);
-	}
-	return true;
-}
-
-static bool
-clear_ip4(npf_tableset_t *tblset)
-{
-	npf_addr_t addr_storage, *addr = &addr_storage;
-	const int alen = sizeof(struct in_addr);
-	const int nm = NPF_NO_NETMASK;
-
-	for (unsigned i = 0; i < __arraycount(ip_list); i++) {
-		npf_table_t *t;
-		int error;
-
-		addr->word32[0] = inet_addr(ip_list[i]);
-
-		t = npf_tableset_getbyname(tblset, IPSET_NAME);
-		error = npf_table_remove(t, alen, addr, nm);
-		CHECK_TRUE(error == 0);
-
-		error = npf_table_remove(t, alen, addr, nm);
-		CHECK_TRUE(error != 0);
-
-		t = npf_tableset_getbyname(tblset, LPM_NAME);
-		error = npf_table_remove(t, alen, addr, nm);
-		CHECK_TRUE(error == 0);
-
-		error = npf_table_remove(t, alen, addr, nm);
-		CHECK_TRUE(error != 0);
-	}
-	return true;
-}
-
-///////////////////////////////////////////////////////////////////////////
-
-static bool
-test_basic(npf_tableset_t *tblset)
-{
-	npf_addr_t addr_storage, *addr = &addr_storage;
-	const int alen = sizeof(struct in_addr);
-	npf_table_t *t;
-	int error;
-
-	/* Basic IP set. */
-	t = npf_table_create(IPSET_NAME, IPSET_TID, NPF_TABLE_IPSET, NULL, 0);
-	CHECK_TRUE(t != NULL);
-	error = npf_tableset_insert(tblset, t);
-	CHECK_TRUE(error == 0);
-
-	/* Check for double-insert. */
-	error = npf_tableset_insert(tblset, t);
-	CHECK_TRUE(error != 0);
-
-	/* Longest-prefix match (LPM). */
-	t = npf_table_create(LPM_NAME, LPM_TID, NPF_TABLE_LPM, NULL, 0);
-	CHECK_TRUE(t != NULL);
-	error = npf_tableset_insert(tblset, t);
-	CHECK_TRUE(error == 0);
-
-	/* Table for interface addresses. */
-	t = npf_table_create(IFADDR_NAME, IFADDR_TID, NPF_TABLE_IFADDR, NULL, 0);
-	CHECK_TRUE(t != NULL);
-	error = npf_tableset_insert(tblset, t);
-	CHECK_TRUE(error == 0);
-
-	/*
-	 * Attempt to match some non-existing entries - should fail.
-	 */
-	addr->word32[0] = inet_addr(ip_list[0]);
-
-	t = npf_tableset_getbyname(tblset, IPSET_NAME);
-	error = npf_table_lookup(t, alen, addr);
-	CHECK_TRUE(error != 0);
-
-	t = npf_tableset_getbyname(tblset, LPM_NAME);
-	error = npf_table_lookup(t, alen, addr);
-	CHECK_TRUE(error != 0);
-
-	return true;
-}
-
-static bool
-test_nocopy(npf_tableset_t *tblset)
-{
-	const int alen = sizeof(struct in_addr);
-	const char *tables[] = { IPSET_NAME, LPM_NAME, IFADDR_NAME };
-	npf_addr_t *addr, lookup_addr;
-
-	for (unsigned i = 0; i < __arraycount(tables); i++) {
-		npf_table_t *t;
-		int error;
-
-		addr = kmem_zalloc(sizeof(npf_addr_t), KM_SLEEP);
-		assert(addr != NULL);
-		addr->word32[0] = inet_addr("172.16.90.10");
-
-		t = npf_tableset_getbyname(tblset, tables[i]);
-		(void)npf_table_flush(t);
-
-		error = npf_table_insert(t, alen, addr, NPF_NO_NETMASK);
-		CHECK_TRUE(error == 0);
-
-		memcpy(&lookup_addr, addr, alen);
-		memset(addr, 0xa5, alen); // explicit memset
-
-		error = npf_table_lookup(t, alen, &lookup_addr);
-		CHECK_TRUE(error == 0);
-
-		CHECK_TRUE(*(volatile unsigned char *)addr == 0xa5);
-		kmem_free(addr, sizeof(npf_addr_t));
-	}
-	return true;
-}
-
-static bool
-test_ip6(npf_tableset_t *tblset)
-{
-	npf_addr_t addr_storage, *addr = &addr_storage;
-	const size_t alen = sizeof(struct in6_addr);
-	const int nm = NPF_NO_NETMASK;
-	npf_table_t *t;
-	int error;
-
-	/* IPv6 addresses. */
-	memcpy(addr, ip6_list[0], sizeof(ip6_list[0]));
-
-	t = npf_tableset_getbyname(tblset, IPSET_NAME);
-	error = npf_table_insert(t, alen, addr, nm);
-	CHECK_TRUE(error == 0);
-	error = npf_table_lookup(t, alen, addr);
-	CHECK_TRUE(error == 0);
-	error = npf_table_remove(t, alen, addr, nm);
-	CHECK_TRUE(error == 0);
-
-	t = npf_tableset_getbyname(tblset, LPM_NAME);
-	error = npf_table_insert(t, alen, addr, nm);
-	CHECK_TRUE(error == 0);
-	error = npf_table_lookup(t, alen, addr);
-	CHECK_TRUE(error == 0);
-	error = npf_table_remove(t, alen, addr, nm);
-	CHECK_TRUE(error == 0);
-
-	return true;
-}
-
-static bool
-test_lpm_masks4(npf_tableset_t *tblset)
-{
-	npf_table_t *t = npf_tableset_getbyname(tblset, LPM_NAME);
-	npf_addr_t addr_storage, *addr = &addr_storage;
-	const size_t alen = sizeof(struct in_addr);
-	int error;
-
-	addr->word32[0] = inet_addr("172.16.90.0");
-	error = npf_table_insert(t, alen, addr, 25);
-	CHECK_TRUE(error == 0);
-
-	addr->word32[0] = inet_addr("172.16.90.126");
-	error = npf_table_lookup(t, alen, addr);
-	CHECK_TRUE(error == 0);
-
-	addr->word32[0] = inet_addr("172.16.90.128");
-	error = npf_table_lookup(t, alen, addr);
-	CHECK_TRUE(error != 0);
-
-	return true;
-}
-
-static bool
-test_lpm_masks6(npf_tableset_t *tblset)
-{
-	npf_table_t *t = npf_tableset_getbyname(tblset, LPM_NAME);
-	npf_addr_t addr_storage, *addr = &addr_storage;
-	const size_t alen = sizeof(struct in6_addr);
-	int error;
-
-	/*
-	 * 96
-	 */
-	memcpy(addr, ip6_list[1], sizeof(ip6_list[1]));
-	error = npf_table_insert(t, alen, addr, 96);
-	CHECK_TRUE(error == 0);
-
-	memcpy(addr, ip6_list[0], sizeof(ip6_list[0]));
-	error = npf_table_lookup(t, alen, addr);
-	CHECK_TRUE(error == 0);
-
-	memcpy(addr, ip6_list[1], sizeof(ip6_list[1]));
-	error = npf_table_remove(t, alen, addr, 96);
-	CHECK_TRUE(error == 0);
-
-	/*
-	 * 32
-	 */
-	memcpy(addr, ip6_list[2], sizeof(ip6_list[2]));
-	error = npf_table_insert(t, alen, addr, 32);
-	CHECK_TRUE(error == 0);
-
-	memcpy(addr, ip6_list[0], sizeof(ip6_list[0]));
-	error = npf_table_lookup(t, alen, addr);
-	CHECK_TRUE(error == 0);
-
-	memcpy(addr, ip6_list[2], sizeof(ip6_list[2]));
-	error = npf_table_remove(t, alen, addr, 32);
-	CHECK_TRUE(error == 0);
-
-	/*
-	 * 126
-	 */
-	memcpy(addr, ip6_list[3], sizeof(ip6_list[3]));
-	error = npf_table_insert(t, alen, addr, 126);
-	CHECK_TRUE(error == 0);
-
-	memcpy(addr, ip6_list[0], sizeof(ip6_list[0]));
-	error = npf_table_lookup(t, alen, addr);
-	CHECK_TRUE(error != 0);
-
-	memcpy(addr, ip6_list[3], sizeof(ip6_list[3]));
-	error = npf_table_remove(t, alen, addr, 126);
-	CHECK_TRUE(error == 0);
-
-	return true;
-}
-
-static bool
-test_const_table(npf_tableset_t *tblset, void *blob, size_t size)
-{
-	npf_addr_t addr_storage, *addr = &addr_storage;
-	const int alen = sizeof(struct in_addr);
-	npf_table_t *t;
-	int error;
-
-	t = npf_table_create(CDB_NAME, CDB_TID, NPF_TABLE_CONST, blob, size);
-	CHECK_TRUE(t != NULL);
-
-	error = npf_tableset_insert(tblset, t);
-	CHECK_TRUE(error == 0);
-
-	addr->word32[0] = inet_addr(ip_list[0]);
-	error = npf_table_lookup(t, alen, addr);
-	CHECK_TRUE(error == 0);
-
-	for (unsigned i = 1; i < __arraycount(ip_list) - 1; i++) {
-		addr->word32[0] = inet_addr(ip_list[i]);
-		error = npf_table_lookup(t, alen, addr);
-		CHECK_TRUE(error != 0);
-	}
-	return true;
-}
-
-static bool
-test_ifaddr_table(npf_tableset_t *tblset)
-{
-	npf_addr_t addr_storage, *addr = &addr_storage;
-	npf_table_t *t = npf_tableset_getbyname(tblset, IFADDR_NAME);
-	int error;
-	bool ok;
-
-	/* Two IPv4 addresses. */
-	ok = ip4list_insert_lookup(t, 0);
-	CHECK_TRUE(ok);
-
-	ok = ip4list_insert_lookup(t, 1);
-	CHECK_TRUE(ok);
-
-	/* And one IPv6 address. */
-	memcpy(addr, ip6_list[0], sizeof(ip6_list[0]));
-	error = npf_table_insert(t, sizeof(struct in6_addr), addr, NPF_NO_NETMASK);
-	CHECK_TRUE(error == 0);
-
-	/*
-	 * Get IPv4 addresses.
-	 */
-	addr = npf_table_getsome(t, sizeof(struct in_addr), 0);
-	ok = check_ip4(addr, "192.168.1.1");
-	CHECK_TRUE(ok);
-
-	addr = npf_table_getsome(t, sizeof(struct in_addr), 1);
-	ok = check_ip4(addr, "10.0.0.1");
-	CHECK_TRUE(ok);
-
-	addr = npf_table_getsome(t, sizeof(struct in_addr), 2);
-	ok = check_ip4(addr, "192.168.1.1");
-	CHECK_TRUE(ok);
-
-	return true;
-}
-
-static void
-test_ipset_gc(npf_tableset_t *tblset)
-{
-	npf_table_t *t = npf_tableset_getbyname(tblset, IPSET_NAME);
-	npf_t *npf = npf_getkernctx();
-
-	npf_config_enter(npf);
-	npf_table_gc(npf, t);
-	npf_table_flush(t);
-	npf_config_exit(npf);
-}
-
-bool
-npf_table_test(bool verbose, void *blob, size_t size)
-{
-	npf_tableset_t *tblset;
-	bool ok;
-
-	(void)verbose;
-
-	tblset = npf_tableset_create(4);
-	CHECK_TRUE(tblset != NULL);
-
-	ok = test_basic(tblset);
-	CHECK_TRUE(ok);
-
-	/*
-	 * Fill IPSET and LPM tables with IPv4 addresses.
-	 * Keep them in the table during the other tests.
-	 */
-	ok = fill_with_ip4(tblset);
-	CHECK_TRUE(ok);
-
-	ok = verify_ip4(tblset);
-	CHECK_TRUE(ok);
-
-	ok = test_ip6(tblset);
-	CHECK_TRUE(ok);
-
-	ok = test_lpm_masks4(tblset);
-	CHECK_TRUE(ok);
-
-	ok = test_lpm_masks6(tblset);
-	CHECK_TRUE(ok);
-
-	ok = test_const_table(tblset, blob, size);
-	CHECK_TRUE(ok);
-
-	ok = test_ifaddr_table(tblset);
-	CHECK_TRUE(ok);
-
-	/*
-	 * Remove the above IPv4 addresses -- they must have been untouched.
-	 */
-	ok = clear_ip4(tblset);
-	CHECK_TRUE(ok);
-
-	ok = test_nocopy(tblset);
-	CHECK_TRUE(ok);
-
-	test_ipset_gc(tblset);
-
-	npf_tableset_destroy(tblset);
-	return true;
-}
diff --git a/src/npftest/libnpftest/npf_test.h b/src/npftest/libnpftest/npf_test.h
deleted file mode 100644
index 3ca7ed9..0000000
--- a/src/npftest/libnpftest/npf_test.h
+++ /dev/null
@@ -1,130 +0,0 @@
-/*
- * Public Domain.
- */
-
-#ifndef _LIB_NPF_TEST_H_
-#define _LIB_NPF_TEST_H_
-
-#ifdef _KERNEL
-#include <sys/types.h>
-#include <sys/mbuf.h>
-
-#include <netinet/in_systm.h>
-#include <netinet/in.h>
-#include <netinet6/in6.h>
-
-#include <netinet/ip.h>
-#include <netinet/ip6.h>
-#include <netinet/tcp.h>
-#include <netinet/udp.h>
-#include <netinet/ip_icmp.h>
-
-#include <net/if.h>
-#include <net/if_ether.h>
-#include <net/ethertypes.h>
-#endif
-
-#define	IFNAME_DUMMY	"npftest999"
-
-/* Test interfaces and IP addresses. */
-#define	IFNAME_EXT	"npftest0"
-#define	IFNAME_INT	"npftest1"
-#define	IFNAME_TEST	"npftest2"
-
-#define	LOCAL_IP1	"10.1.1.1"
-#define	LOCAL_IP2	"10.1.1.2"
-#define	LOCAL_IP3	"10.1.1.3"
-
-/* Note: RFC 5737 compliant addresses. */
-#define	PUB_IP1		"192.0.2.1"
-#define	PUB_IP2		"192.0.2.2"
-#define	PUB_IP3		"192.0.2.3"
-
-#define	REMOTE_IP1	"192.0.2.101"
-#define	REMOTE_IP2	"192.0.2.102"
-#define	REMOTE_IP3	"192.0.2.103"
-#define	REMOTE_IP4	"192.0.2.104"
-
-#define	LOCAL_IP6	"fd01:203:405:1::1234"
-#define	REMOTE_IP6	"2001:db8:fefe::1010"
-#define	EXPECTED_IP6	"2001:db8:1:d550::1234"
-
-#define	NET_A_IP1	"10.100.7.126"
-#define	NET_B_IP1	"10.255.7.126"
-
-#if defined(_NPF_STANDALONE)
-
-#define	MLEN		512
-
-struct mbuf {
-	unsigned	m_flags;
-	int		m_type;
-	unsigned	m_len;
-	void *		m_next;
-	struct {
-		int	len;
-	} m_pkthdr;
-	void *		m_data;
-	unsigned char	m_data0[MLEN];
-};
-
-#define	MT_FREE			0
-#define	M_UNWRITABLE(m, l)	false
-#define	M_NOWAIT		0x00001
-#define M_PKTHDR		0x00002
-
-#define	m_get(x, y)		npfkern_m_get(NULL, 0, MLEN)
-#define	m_gethdr(x, y)		npfkern_m_get(NULL, M_PKTHDR, MLEN)
-#define	m_length(m)		npfkern_m_length(m)
-#define	m_freem(m)		npfkern_m_freem(m)
-#define	mtod(m, t)		((t)((m)->m_data))
-
-#endif
-
-#define	CHECK_TRUE(x)	\
-    if (!(x)) { printf("FAIL: %s line %d\n", __func__, __LINE__); return 0; }
-
-extern const npf_mbufops_t	npftest_mbufops;
-extern const npf_ifops_t	npftest_ifops;
-
-struct mbuf *	npfkern_m_get(npf_t *, unsigned, size_t);
-size_t		npfkern_m_length(const struct mbuf *);
-void		npfkern_m_freem(struct mbuf *);
-
-void		npf_test_init(int (*)(int, const char *, void *),
-		    const char *(*)(int, const void *, char *, socklen_t),
-		    long (*)(void));
-void		npf_test_fini(void);
-int		npf_test_load(const void *, size_t, bool);
-ifnet_t *	npf_test_addif(const char *, bool, bool);
-ifnet_t *	npf_test_getif(const char *);
-
-int		npf_test_statetrack(const void *, size_t, ifnet_t *,
-		    bool, int64_t *);
-void		npf_test_conc(bool, unsigned);
-
-struct mbuf *	mbuf_getwithdata(const void *, size_t);
-struct mbuf *	mbuf_construct_ether(int);
-struct mbuf *	mbuf_construct(int);
-struct mbuf *	mbuf_construct6(int);
-void *		mbuf_return_hdrs(struct mbuf *, bool, struct ip **);
-void *		mbuf_return_hdrs6(struct mbuf *, struct ip6_hdr **);
-void		mbuf_icmp_append(struct mbuf *, struct mbuf *);
-
-struct mbuf *	mbuf_get_pkt(int, int, const char *, const char *, int, int);
-npf_cache_t *	get_cached_pkt(struct mbuf *, const char *);
-void		put_cached_pkt(npf_cache_t *);
-
-bool		npf_nbuf_test(bool);
-bool		npf_bpf_test(bool);
-bool		npf_table_test(bool, void *, size_t);
-bool		npf_state_test(bool);
-
-bool		npf_rule_test(bool);
-bool		npf_nat_test(bool);
-bool		npf_gc_test(bool);
-
-int		npf_inet_pton(int, const char *, void *);
-const char *	npf_inet_ntop(int, const void *, char *, socklen_t);
-
-#endif
diff --git a/src/npftest/libnpftest/npf_test_subr.c b/src/npftest/libnpftest/npf_test_subr.c
deleted file mode 100644
index 83ebedc..0000000
--- a/src/npftest/libnpftest/npf_test_subr.c
+++ /dev/null
@@ -1,273 +0,0 @@
-/*
- * NPF initialisation and handler routines.
- *
- * Public Domain.
- */
-
-#ifdef _KERNEL
-#include <sys/types.h>
-#include <sys/cprng.h>
-#include <sys/kmem.h>
-#include <net/if.h>
-#include <net/if_types.h>
-#endif
-
-#include "npf_impl.h"
-#include "npf_test.h"
-
-/* State of the current stream. */
-static npf_state_t	cstream_state;
-static void *		cstream_ptr;
-static bool		cstream_retval;
-
-static long		(*_random_func)(void);
-static int		(*_pton_func)(int, const char *, void *);
-static const char *	(*_ntop_func)(int, const void *, char *, socklen_t);
-
-static void		npf_state_sample(npf_state_t *, bool);
-
-static void		load_npf_config_ifs(nvlist_t *, bool);
-
-#ifndef __NetBSD__
-/*
- * Standalone NPF: we define the same struct ifnet members
- * to reduce the npf_ifops_t implementation differences.
- */
-struct ifnet {
-	char		if_xname[32];
-	void *		if_softc;
-	TAILQ_ENTRY(ifnet) if_list;
-};
-#endif
-
-static TAILQ_HEAD(, ifnet) npftest_ifnet_list =
-    TAILQ_HEAD_INITIALIZER(npftest_ifnet_list);
-
-static const char *	npftest_ifop_getname(npf_t *, ifnet_t *);
-static ifnet_t *	npftest_ifop_lookup(npf_t *, const char *);
-static void		npftest_ifop_flush(npf_t *, void *);
-static void *		npftest_ifop_getmeta(npf_t *, const ifnet_t *);
-static void		npftest_ifop_setmeta(npf_t *, ifnet_t *, void *);
-
-const npf_ifops_t npftest_ifops = {
-	.getname	= npftest_ifop_getname,
-	.lookup		= npftest_ifop_lookup,
-	.flush		= npftest_ifop_flush,
-	.getmeta	= npftest_ifop_getmeta,
-	.setmeta	= npftest_ifop_setmeta,
-};
-
-void
-npf_test_init(int (*pton_func)(int, const char *, void *),
-    const char *(*ntop_func)(int, const void *, char *, socklen_t),
-    long (*rndfunc)(void))
-{
-	npf_t *npf;
-
-	npfk_sysinit(0);
-	npf = npfk_create(0, &npftest_mbufops, &npftest_ifops, NULL);
-	npfk_thread_register(npf);
-	npf_setkernctx(npf);
-
-	npf_state_setsampler(npf_state_sample);
-	_pton_func = pton_func;
-	_ntop_func = ntop_func;
-	_random_func = rndfunc;
-
-	(void)npf_test_addif(IFNAME_DUMMY, false, false);
-}
-
-void
-npf_test_fini(void)
-{
-	npf_t *npf = npf_getkernctx();
-	npfk_thread_unregister(npf);
-	npfk_destroy(npf);
-	npfk_sysfini();
-}
-
-int
-npf_test_load(const void *buf, size_t len, bool verbose)
-{
-	nvlist_t *npf_dict;
-	npf_error_t error;
-	int ret;
-
-	npf_dict = nvlist_unpack(buf, len, 0);
-	if (!npf_dict) {
-		printf("%s: could not unpack the nvlist\n", __func__);
-		return EINVAL;
-	}
-	load_npf_config_ifs(npf_dict, verbose);
-	ret = npfk_load(npf_getkernctx(), npf_dict, &error);
-	nvlist_destroy(npf_dict);
-	return ret;
-}
-
-ifnet_t *
-npf_test_addif(const char *ifname, bool reg, bool verbose)
-{
-	npf_t *npf = npf_getkernctx();
-	ifnet_t *ifp = kmem_zalloc(sizeof(*ifp), KM_SLEEP);
-
-	/*
-	 * This is a "fake" interface with explicitly set index.
-	 * Note: test modules may not setup pfil(9) hooks and if_attach()
-	 * may not trigger npf_ifmap_attach(), so we call it manually.
-	 */
-	strlcpy(ifp->if_xname, ifname, sizeof(ifp->if_xname));
-	TAILQ_INSERT_TAIL(&npftest_ifnet_list, ifp, if_list);
-
-	npfk_ifmap_attach(npf, ifp);
-	if (reg) {
-		npf_ifmap_register(npf, ifname);
-	}
-
-	if (verbose) {
-		printf("+ Interface %s\n", ifname);
-	}
-	return ifp;
-}
-
-ifnet_t *
-npf_test_getif(const char *ifname)
-{
-	ifnet_t *ifp;
-
-	TAILQ_FOREACH(ifp, &npftest_ifnet_list, if_list) {
-		if (!strcmp(ifp->if_xname, ifname))
-			return ifp;
-	}
-	return NULL;
-}
-
-static void
-load_npf_config_ifs(nvlist_t *npf_dict, bool verbose)
-{
-	const nvlist_t * const *iflist;
-	const nvlist_t *dbg_dict;
-	size_t nitems;
-
-	dbg_dict = dnvlist_get_nvlist(npf_dict, "debug", NULL);
-	if (!dbg_dict) {
-		return;
-	}
-	if (!nvlist_exists_nvlist_array(dbg_dict, "interfaces")) {
-		return;
-	}
-	iflist = nvlist_get_nvlist_array(dbg_dict, "interfaces", &nitems);
-	for (unsigned i = 0; i < nitems; i++) {
-		const nvlist_t *ifdict = iflist[i];
-		const char *ifname;
-
-		if ((ifname = nvlist_get_string(ifdict, "name")) != NULL) {
-			(void)npf_test_addif(ifname, true, verbose);
-		}
-	}
-}
-
-static const char *
-npftest_ifop_getname(npf_t *npf __unused, ifnet_t *ifp)
-{
-	return ifp->if_xname;
-}
-
-static ifnet_t *
-npftest_ifop_lookup(npf_t *npf __unused, const char *ifname)
-{
-	return npf_test_getif(ifname);
-}
-
-static void
-npftest_ifop_flush(npf_t *npf __unused, void *arg)
-{
-	ifnet_t *ifp;
-
-	TAILQ_FOREACH(ifp, &npftest_ifnet_list, if_list)
-		ifp->if_softc = arg;
-}
-
-static void *
-npftest_ifop_getmeta(npf_t *npf __unused, const ifnet_t *ifp)
-{
-	return ifp->if_softc;
-}
-
-static void
-npftest_ifop_setmeta(npf_t *npf __unused, ifnet_t *ifp, void *arg)
-{
-	ifp->if_softc = arg;
-}
-
-/*
- * State sampler - this routine is called from inside of NPF state engine.
- */
-static void
-npf_state_sample(npf_state_t *nst, bool retval)
-{
-	/* Pointer will serve as an ID. */
-	cstream_ptr = nst;
-	memcpy(&cstream_state, nst, sizeof(npf_state_t));
-	cstream_retval = retval;
-}
-
-int
-npf_test_statetrack(const void *data, size_t len, ifnet_t *ifp,
-    bool forw, int64_t *result)
-{
-	npf_t *npf = npf_getkernctx();
-	struct mbuf *m;
-	int i = 0, error;
-
-	m = mbuf_getwithdata(data, len);
-	error = npfk_packet_handler(npf, &m, ifp, forw ? PFIL_OUT : PFIL_IN);
-	if (error) {
-		assert(m == NULL);
-		return error;
-	}
-	assert(m != NULL);
-	m_freem(m);
-
-	const int di = forw ? NPF_FLOW_FORW : NPF_FLOW_BACK;
-	npf_tcpstate_t *fstate = &cstream_state.nst_tcpst[di];
-	npf_tcpstate_t *tstate = &cstream_state.nst_tcpst[!di];
-
-	result[i++] = (intptr_t)cstream_ptr;
-	result[i++] = cstream_retval;
-	result[i++] = cstream_state.nst_state;
-
-	result[i++] = fstate->nst_end;
-	result[i++] = fstate->nst_maxend;
-	result[i++] = fstate->nst_maxwin;
-	result[i++] = fstate->nst_wscale;
-
-	result[i++] = tstate->nst_end;
-	result[i++] = tstate->nst_maxend;
-	result[i++] = tstate->nst_maxwin;
-	result[i++] = tstate->nst_wscale;
-
-	return 0;
-}
-
-int
-npf_inet_pton(int af, const char *src, void *dst)
-{
-	return _pton_func(af, src, dst);
-}
-
-const char *
-npf_inet_ntop(int af, const void *src, char *dst, socklen_t size)
-{
-	return _ntop_func(af, src, dst, size);
-}
-
-#ifdef _KERNEL
-/*
- * Need to override cprng_fast32() -- we need deterministic PRNG.
- */
-uint32_t
-cprng_fast32(void)
-{
-	return (uint32_t)(_random_func ? _random_func() : random());
-}
-#endif
diff --git a/src/npftest/npfstream.c b/src/npftest/npfstream.c
deleted file mode 100644
index e0a835b..0000000
--- a/src/npftest/npfstream.c
+++ /dev/null
@@ -1,125 +0,0 @@
-/*	$NetBSD: npfstream.c,v 1.8 2019/01/19 21:19:32 rmind Exp $	*/
-
-/*
- * NPF stream processor.
- *
- * Public Domain.
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <stdbool.h>
-#include <string.h>
-#include <inttypes.h>
-#include <err.h>
-#include <pcap.h>
-
-#include <arpa/inet.h>
-
-#if !defined(_NPF_STANDALONE)
-#include <net/if.h>
-#include <net/ethertypes.h>
-#include <net/if_ether.h>
-#include <netinet/in_systm.h>
-#include <netinet/ip.h>
-#include <netinet/ip.h>
-#include <netinet/tcp.h>
-
-#include <rump/rump.h>
-#endif
-
-#include "npftest.h"
-
-static struct in_addr	initial_ip;
-static int		snd_packet_no = 0;
-static int		rcv_packet_no = 0;
-
-static void
-process_tcpip(const void *data, size_t len, FILE *fp, ifnet_t *ifp)
-{
-	const struct ether_header *eth = data;
-	const struct ip *ip;
-	const struct tcphdr *th;
-	unsigned hlen, tcpdlen;
-	int error, packetno;
-	const void *p;
-	tcp_seq seq;
-	bool forw;
-
-	if (ntohs(eth->ether_type) != ETHERTYPE_IP) {
-		p = (const char *)data + 4;
-	} else {
-		p = eth + 1;
-	}
-	ip = (const struct ip *)p;
-	hlen = ip->ip_hl << 2;
-	p = (const uint8_t *)ip + hlen;
-	th = (const struct tcphdr *)p;
-
-	tcpdlen = ntohs(ip->ip_len) - hlen - (th->th_off << 2);
-	if (th->th_flags & TH_SYN) {
-		tcpdlen++;
-	}
-	if (th->th_flags & TH_FIN) {
-		tcpdlen++;
-	}
-	seq = ntohl(th->th_seq);
-
-	if (snd_packet_no == 0) {
-		memcpy(&initial_ip, &ip->ip_src, sizeof(struct in_addr));
-	}
-
-	forw = (initial_ip.s_addr == ip->ip_src.s_addr);
-	packetno = forw ? ++snd_packet_no : ++rcv_packet_no;
-
-	int64_t result[11];
-	memset(result, 0, sizeof(result));
-
-	len = ntohs(ip->ip_len);
-	error = rumpns_npf_test_statetrack(ip, len, ifp, forw, result);
-
-	fprintf(fp, "%s%2x %5d %3d %11u %11u %11u %11u %12" PRIxPTR,
-	    forw ? ">" : "<", (th->th_flags & (TH_SYN | TH_ACK | TH_FIN)),
-	    packetno, error, (unsigned)seq, (unsigned)ntohl(th->th_ack),
-	    tcpdlen, ntohs(th->th_win), (uintptr_t)result[0]);
-
-	for (unsigned i = 1; i < __arraycount(result); i++) {
-		fprintf(fp, "%11" PRIu64 " ", result[i]);
-	}
-	fputs("\n", fp);
-}
-
-int
-process_stream(const char *input, const char *output, ifnet_t *ifp)
-{
-	pcap_t *pcap;
-	char pcap_errbuf[PCAP_ERRBUF_SIZE];
-	struct pcap_pkthdr *phdr;
-	const uint8_t *data;
-	FILE *fp;
-
-	pcap = pcap_open_offline(input, pcap_errbuf);
-	if (pcap == NULL) {
-		errx(EXIT_FAILURE, "pcap_open_offline failed: %s", pcap_errbuf);
-	}
-	fp = output ? fopen(output, "w") : stdout;
-	if (fp == NULL) {
-		err(EXIT_FAILURE, "fopen");
-	}
-	fprintf(fp, "#FL %5s %3s %11s %11s %11s %11s %11s %11s %11s "
-	    "%11s %11s %11s %5s %11s %11s %11s %5s\n",
-	    "No", "Err", "Seq", "Ack", "TCP Len", "Win",
-	    "Stream", "RetVal", "State",
-	    "F.END", "F.MAXEND", "F.MAXWIN", "F.WSC",
-	    "T.END", "T.MAXEND", "T.MAXWIN", "T.WSC");
-	while (pcap_next_ex(pcap, &phdr, &data) > 0) {
-		if (phdr->len != phdr->caplen) {
-			warnx("process_stream: truncated packet");
-		}
-		process_tcpip(data, phdr->caplen, fp, ifp);
-	}
-	pcap_close(pcap);
-	fclose(fp);
-
-	return 0;
-}
diff --git a/src/npftest/npftest.c b/src/npftest/npftest.c
deleted file mode 100644
index 6aa857a..0000000
--- a/src/npftest/npftest.c
+++ /dev/null
@@ -1,354 +0,0 @@
-/*	$NetBSD: npftest.c,v 1.23 2019/01/19 21:19:32 rmind Exp $	*/
-
-/*
- * NPF testing framework.
- *
- * Public Domain.
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <stdbool.h>
-#include <string.h>
-#include <unistd.h>
-#include <assert.h>
-#include <fcntl.h>
-#include <err.h>
-
-#include <sys/mman.h>
-#include <sys/stat.h>
-#if !defined(_NPF_STANDALONE)
-#include <sys/ioctl.h>
-#include <net/if.h>
-#include <arpa/inet.h>
-
-#include <dnv.h>
-#include <nv.h>
-
-#include <rump/rump.h>
-#include <rump/rump_syscalls.h>
-#endif
-
-#include <cdbw.h>
-
-#include "npftest.h"
-
-static bool verbose, quiet;
-
-__dead static void
-usage(const char *progname)
-{
-	printf("usage:\n"
-	    "  %s [ -q | -v ] [ -c <config> ] "
-	        "[ -i <interface> ] < -b | -t | -s file >\n"
-	    "  %s -T <testname> -c <config>\n"
-	    "  %s -L\n"
-	    "where:\n"
-	    "\t-b: benchmark\n"
-	    "\t-t: regression test\n"
-	    "\t-T <testname>: specific test\n"
-	    "\t-s <file>: pcap stream\n"
-	    "\t-c <config>: NPF configuration file\n"
-	    "\t-i <interface>: primary interface\n"
-	    "\t-L: list testnames and description for -T\n"
-	    "\t-q: quiet mode\n"
-	    "\t-v: verbose mode\n",
-	    progname, progname, progname);
-	exit(EXIT_FAILURE);
-}
-
-__dead static void
-describe_tests(void)
-{
-	printf(	"nbuf\tbasic npf mbuf handling\n"
-		"bpf\tBPF coprocessor\n"
-		"table\ttable handling\n"
-		"state\tstate handling and processing\n"
-		"gc\tconnection G/C\n"
-		"rule\trule processing\n"
-		"nat\tNAT rule processing\n");
-	exit(EXIT_SUCCESS);
-}
-
-static bool
-result(const char *testcase, bool ok)
-{
-	if (!quiet) {
-		printf("NPF %-10s\t%s\n", testcase, ok ? "OK" : "fail");
-	}
-	if (verbose) {
-		puts("-----");
-	}
-	return !ok;
-}
-
-static void
-load_npf_config(const char *fpath)
-{
-	struct stat sb;
-	int error, fd;
-	size_t len;
-	void *buf;
-
-	/*
-	 * Read the configuration from the specified file.
-	 */
-	if ((fd = open(fpath, O_RDONLY)) == -1) {
-		err(EXIT_FAILURE, "open");
-	}
-	if (fstat(fd, &sb) == -1) {
-		err(EXIT_FAILURE, "fstat");
-	}
-	len = sb.st_size;
-	buf = mmap(NULL, len, PROT_READ, MAP_FILE | MAP_PRIVATE, fd, 0);
-	if (buf == MAP_FAILED) {
-		err(EXIT_FAILURE, "mmap");
-	}
-	close(fd);
-
-	/*
-	 * Load the NPF configuration.
-	 */
-	error = rumpns_npf_test_load(buf, len, verbose);
-	if (error) {
-		errx(EXIT_FAILURE, "npf_test_load: %s\n", strerror(error));
-	}
-	munmap(buf, len);
-
-	if (verbose) {
-		printf("Loaded NPF config at '%s'\n", fpath);
-	}
-}
-
-static void *
-generate_test_cdb(size_t *size)
-{
-	in_addr_t addr;
-	struct cdbw *cdbw;
-	struct stat sb;
-	char sfn[32];
-	int alen, fd;
-	void *cdb;
-
-	if ((cdbw = cdbw_open()) == NULL) {
-		err(EXIT_FAILURE, "cdbw_open");
-	}
-	strlcpy(sfn, "/tmp/npftest_cdb.XXXXXX", sizeof(sfn));
-	if ((fd = mkstemp(sfn)) == -1) {
-		err(EXIT_FAILURE, "mkstemp");
-	}
-	unlink(sfn);
-
-	addr = inet_addr("192.168.1.1"), alen = sizeof(struct in_addr);
-	if (cdbw_put(cdbw, &addr, alen, &addr, alen) == -1)
-		err(EXIT_FAILURE, "cdbw_put");
-
-	addr = inet_addr("10.0.0.2"), alen = sizeof(struct in_addr);
-	if (cdbw_put(cdbw, &addr, alen, &addr, alen) == -1)
-		err(EXIT_FAILURE, "cdbw_put");
-
-	if (cdbw_output(cdbw, fd, "npf-table-cdb", NULL) == -1) {
-		err(EXIT_FAILURE, "cdbw_output");
-	}
-	cdbw_close(cdbw);
-
-	if (fstat(fd, &sb) == -1) {
-		err(EXIT_FAILURE, "fstat");
-	}
-	if ((cdb = mmap(NULL, sb.st_size, PROT_READ,
-	    MAP_FILE | MAP_PRIVATE, fd, 0)) == MAP_FAILED) {
-		err(EXIT_FAILURE, "mmap");
-	}
-	close(fd);
-
-	*size = sb.st_size;
-	return cdb;
-}
-
-static void
-npf_kern_init(void)
-{
-#if !defined(_NPF_STANDALONE)
-	/* XXX rn_init */
-	extern int rumpns_max_keylen;
-	rumpns_max_keylen = 1;
-
-	rump_init();
-	rump_schedule();
-#endif
-}
-
-static void
-npf_kern_fini(void)
-{
-#if !defined(_NPF_STANDALONE)
-	rump_unschedule();
-#endif
-}
-
-int
-main(int argc, char **argv)
-{
-	bool test, ok, fail, tname_matched;
-	char *benchmark, *config, *interface, *stream, *testname;
-	unsigned nthreads = 0;
-	ifnet_t *ifp = NULL;
-	int ch;
-
-	benchmark = NULL;
-	test = false;
-
-	tname_matched = false;
-	testname = NULL;
-	config = NULL;
-	interface = NULL;
-	stream = NULL;
-
-	verbose = false;
-	quiet = false;
-
-	while ((ch = getopt(argc, argv, "b:qvc:i:s:tT:Lp:")) != -1) {
-		switch (ch) {
-		case 'b':
-			benchmark = optarg;
-			break;
-		case 'q':
-			quiet = true;
-			break;
-		case 'v':
-			verbose = true;
-			break;
-		case 'c':
-			config = optarg;
-			break;
-		case 'i':
-			interface = optarg;
-			break;
-		case 's':
-			stream = optarg;
-			break;
-		case 't':
-			test = true;
-			break;
-		case 'T':
-			test = true;
-			testname = optarg;
-			break;
-		case 'L':
-			describe_tests();
-			break;
-		case 'p':
-			/* Note: RUMP_NCPU must be high enough. */
-			if ((nthreads = atoi(optarg)) > 0 &&
-			    getenv("RUMP_NCPU") == NULL) {
-				static char nthr[64];
-				sprintf(nthr, "%u", nthreads + 1);
-				setenv("RUMP_NCPU", nthr, 1);
-			}
-			break;
-		default:
-			usage(argv[0]);
-		}
-	}
-
-	/*
-	 * Either benchmark or test.  If stream analysis, then the
-	 * interface should be specified.  If benchmark, then the
-	 * config should be loaded.
-	 */
-	if ((benchmark != NULL) == test && (stream && !interface)) {
-		usage(argv[0]);
-	}
-	if (benchmark && (!config || !nthreads)) {
-		errx(EXIT_FAILURE, "missing config for the benchmark or "
-		    "invalid thread count");
-	}
-
-	/*
-	 * Initialise the NPF kernel component.
-	 */
-	npf_kern_init();
-	rumpns_npf_test_init(inet_pton, inet_ntop, random);
-
-	if (config) {
-		load_npf_config(config);
-	}
-	if (interface && (ifp = rumpns_npf_test_getif(interface)) == 0) {
-		errx(EXIT_FAILURE, "failed to find the interface");
-	}
-
-	fail = false;
-
-	if (test) {
-		if (!testname || strcmp("nbuf", testname) == 0) {
-			ok = rumpns_npf_nbuf_test(verbose);
-			fail |= result("nbuf", ok);
-			tname_matched = true;
-		}
-
-		if (!testname || strcmp("bpf", testname) == 0) {
-			ok = rumpns_npf_bpf_test(verbose);
-			fail |= result("bpf", ok);
-			tname_matched = true;
-		}
-
-		if (!testname || strcmp("table", testname) == 0) {
-			void *cdb;
-			size_t len;
-
-			cdb = generate_test_cdb(&len);
-			ok = rumpns_npf_table_test(verbose, cdb, len);
-			fail |= result("table", ok);
-			tname_matched = true;
-			munmap(cdb, len);
-		}
-
-		if (!testname || strcmp("state", testname) == 0) {
-			ok = rumpns_npf_state_test(verbose);
-			fail |= result("state", ok);
-			tname_matched = true;
-		}
-
-		if (!testname || strcmp("gc", testname) == 0) {
-			ok = rumpns_npf_gc_test(verbose);
-			fail |= result("gc", ok);
-			tname_matched = true;
-		}
-	}
-
-	if (test && config) {
-		if (!testname || strcmp("rule", testname) == 0) {
-			ok = rumpns_npf_rule_test(verbose);
-			fail |= result("rule", ok);
-			tname_matched = true;
-		}
-
-		if (!testname || strcmp("nat", testname) == 0) {
-			srandom(1);
-			ok = rumpns_npf_nat_test(verbose);
-			fail |= result("nat", ok);
-			tname_matched = true;
-		}
-	}
-
-	if (stream) {
-		process_stream(stream, NULL, ifp);
-	}
-
-	if (benchmark) {
-		if (strcmp("rule", benchmark) == 0) {
-			rumpns_npf_test_conc(false, nthreads);
-		}
-		if (strcmp("state", benchmark) == 0) {
-			rumpns_npf_test_conc(true, nthreads);
-		}
-	}
-
-	rumpns_npf_test_fini();
-	npf_kern_fini();
-
-	if (testname && !tname_matched)
-		errx(EXIT_FAILURE, "test \"%s\" unknown", testname);
-
-	return fail ? EXIT_FAILURE : EXIT_SUCCESS;
-}
diff --git a/src/npftest/npftest.conf b/src/npftest/npftest.conf
deleted file mode 100644
index 00ad7c8..0000000
--- a/src/npftest/npftest.conf
+++ /dev/null
@@ -1,66 +0,0 @@
-# $NetBSD: npftest.conf,v 1.6 2019/01/19 21:19:32 rmind Exp $
-
-$ext_if = "npftest0"
-$int_if = "npftest1"
-
-set portmap.min_port 1024
-set portmap.max_port 65535
-
-#
-# RFC 5737
-#
-
-$pub_ip1 = 192.0.2.1
-$pub_ip2 = 192.0.2.2
-$pub_ip3 = 192.0.2.3
-
-$local_ip1 = 10.1.1.1
-$local_ip2 = 10.1.1.2
-$local_ip3 = 10.1.1.3
-$local_ip4 = 10.1.1.4
-
-$local_net = { 10.1.1.0/24 }
-$ports = { 8000, 9000 }
-
-map $ext_if static $local_ip3 <-> $pub_ip3
-map $ext_if dynamic $local_ip2 <-> $pub_ip2
-map $ext_if dynamic $local_net -> $pub_ip1
-map $ext_if dynamic $local_ip1 port 6000 <- $pub_ip1 port 8000
-
-$net6_inner = fd01:203:405::/48
-$net6_outer = 2001:db8:1::/48
-
-$net_a = 10.100.0.0/16
-$net_b = 10.255.0.0/16
-
-map $ext_if static algo npt66 $net6_inner <-> $net6_outer
-map $ext_if static algo netmap $net_a <-> $net_b
-map ruleset "map:some-daemon" on $ext_if
-
-group "ext" on $ext_if {
-	pass out final from $local_ip3
-	pass in final to $pub_ip3
-
-	pass out final from $net6_inner
-	pass in final to $net6_outer
-
-	pass out final from $net_a
-	pass in final to $net_b
-
-	pass stateful out final proto tcp flags S/SA all
-	pass stateful out final from $local_net
-	pass stateful in final to any port $ports
-	pass stateful in final proto icmp all
-	block all
-}
-
-group "int" on $int_if {
-	ruleset "test-rules"
-	pass stateful out final to $local_ip2
-	pass out final to $local_ip3
-	block final to $local_ip4
-}
-
-group default {
-	block all
-}
diff --git a/src/npftest/npftest.h b/src/npftest/npftest.h
deleted file mode 100644
index 964bb59..0000000
--- a/src/npftest/npftest.h
+++ /dev/null
@@ -1,57 +0,0 @@
-/*	$NetBSD$	*/
-
-/*
- * Public Domain.
- */
-
-#ifndef _NPF_TEST_H_
-#define _NPF_TEST_H_
-
-#include <inttypes.h>
-#include <stdbool.h>
-
-#if !defined(_NPF_STANDALONE)
-#include <net/if.h>
-#else
-#define	rumpns_npf_test_addif		npf_test_addif
-#define	rumpns_npf_test_load		npf_test_load
-#define	rumpns_npf_test_init		npf_test_init
-#define	rumpns_npf_test_fini		npf_test_fini
-#define	rumpns_npf_test_getif		npf_test_getif
-#define	rumpns_npf_nbuf_test		npf_nbuf_test
-#define	rumpns_npf_bpf_test		npf_bpf_test
-#define	rumpns_npf_table_test		npf_table_test
-#define	rumpns_npf_state_test		npf_state_test
-#define	rumpns_npf_rule_test		npf_rule_test
-#define	rumpns_npf_nat_test		npf_nat_test
-#define	rumpns_npf_gc_test		npf_gc_test
-#define	rumpns_npf_test_conc		npf_test_conc
-#define	rumpns_npf_test_statetrack	npf_test_statetrack
-#endif
-
-#include "npf.h"
-
-void		rumpns_npf_test_init(int (*)(int, const char *, void *),
-		    const char *(*)(int, const void *, char *, socklen_t),
-		    long (*)(void));
-void		rumpns_npf_test_fini(void);
-int		rumpns_npf_test_load(const void *, size_t, bool);
-ifnet_t *	rumpns_npf_test_addif(const char *, bool, bool);
-ifnet_t *	rumpns_npf_test_getif(const char *);
-
-int		rumpns_npf_test_statetrack(const void *, size_t,
-		    ifnet_t *, bool, int64_t *);
-void		rumpns_npf_test_conc(bool, unsigned);
-
-bool		rumpns_npf_nbuf_test(bool);
-bool		rumpns_npf_bpf_test(bool);
-bool		rumpns_npf_table_test(bool, void *, size_t);
-bool		rumpns_npf_state_test(bool);
-
-bool		rumpns_npf_rule_test(bool);
-bool		rumpns_npf_nat_test(bool);
-bool		rumpns_npf_gc_test(bool);
-
-int		process_stream(const char *, const char *, ifnet_t *);
-
-#endif
